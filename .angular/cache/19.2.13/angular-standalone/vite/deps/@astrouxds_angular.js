import {
  bootstrapLazy,
  promiseResolve
} from "./chunk-2AKL2EQZ.js";
import {
  getDOM
} from "./chunk-XXZOJUTR.js";
import {
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  Component,
  Directive,
  ElementRef,
  EventEmitter,
  Host,
  HostListener,
  Inject,
  Injectable,
  InjectionToken,
  Injector,
  Input,
  NgModule,
  NgZone,
  Optional,
  Output,
  Renderer2,
  RuntimeError,
  Self,
  SkipSelf,
  Subject,
  Version,
  __decorate,
  booleanAttribute,
  computed,
  forkJoin,
  forwardRef,
  from,
  fromEvent,
  inject,
  isPromise,
  isSubscribable,
  map,
  setClassMetadata,
  signal,
  untracked,
  ɵɵInheritDefinitionFeature,
  ɵɵNgOnChangesFeature,
  ɵɵProvidersFeature,
  ɵɵattribute,
  ɵɵclassProp,
  ɵɵdefineComponent,
  ɵɵdefineDirective,
  ɵɵdefineInjectable,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵdirectiveInject,
  ɵɵelementEnd,
  ɵɵelementStart,
  ɵɵgetInheritedFactory,
  ɵɵlistener,
  ɵɵprojection,
  ɵɵprojectionDef,
  ɵɵtext
} from "./chunk-CJOKQPU2.js";
import {
  __spreadProps,
  __spreadValues
} from "./chunk-QHQP2P2Z.js";

// node_modules/@angular/forms/fesm2022/forms.mjs
var BaseControlValueAccessor = class _BaseControlValueAccessor {
  _renderer;
  _elementRef;
  /**
   * The registered callback function called when a change or input event occurs on the input
   * element.
   * @docs-private
   */
  onChange = (_) => {
  };
  /**
   * The registered callback function called when a blur event occurs on the input element.
   * @docs-private
   */
  onTouched = () => {
  };
  constructor(_renderer, _elementRef) {
    this._renderer = _renderer;
    this._elementRef = _elementRef;
  }
  /**
   * Helper method that sets a property on a target element using the current Renderer
   * implementation.
   * @docs-private
   */
  setProperty(key, value) {
    this._renderer.setProperty(this._elementRef.nativeElement, key, value);
  }
  /**
   * Registers a function called when the control is touched.
   * @docs-private
   */
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  /**
   * Registers a function called when the control value changes.
   * @docs-private
   */
  registerOnChange(fn) {
    this.onChange = fn;
  }
  /**
   * Sets the "disabled" property on the range input element.
   * @docs-private
   */
  setDisabledState(isDisabled) {
    this.setProperty("disabled", isDisabled);
  }
  static ɵfac = function BaseControlValueAccessor_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BaseControlValueAccessor)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _BaseControlValueAccessor
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseControlValueAccessor, [{
    type: Directive
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }], null);
})();
var BuiltInControlValueAccessor = class _BuiltInControlValueAccessor extends BaseControlValueAccessor {
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵBuiltInControlValueAccessor_BaseFactory;
    return function BuiltInControlValueAccessor_Factory(__ngFactoryType__) {
      return (ɵBuiltInControlValueAccessor_BaseFactory || (ɵBuiltInControlValueAccessor_BaseFactory = ɵɵgetInheritedFactory(_BuiltInControlValueAccessor)))(__ngFactoryType__ || _BuiltInControlValueAccessor);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _BuiltInControlValueAccessor,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BuiltInControlValueAccessor, [{
    type: Directive
  }], null, null);
})();
var NG_VALUE_ACCESSOR = new InjectionToken(ngDevMode ? "NgValueAccessor" : "");
var CHECKBOX_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => CheckboxControlValueAccessor),
  multi: true
};
var CheckboxControlValueAccessor = class _CheckboxControlValueAccessor extends BuiltInControlValueAccessor {
  /**
   * Sets the "checked" property on the input element.
   * @docs-private
   */
  writeValue(value) {
    this.setProperty("checked", value);
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵCheckboxControlValueAccessor_BaseFactory;
    return function CheckboxControlValueAccessor_Factory(__ngFactoryType__) {
      return (ɵCheckboxControlValueAccessor_BaseFactory || (ɵCheckboxControlValueAccessor_BaseFactory = ɵɵgetInheritedFactory(_CheckboxControlValueAccessor)))(__ngFactoryType__ || _CheckboxControlValueAccessor);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _CheckboxControlValueAccessor,
    selectors: [["input", "type", "checkbox", "formControlName", ""], ["input", "type", "checkbox", "formControl", ""], ["input", "type", "checkbox", "ngModel", ""]],
    hostBindings: function CheckboxControlValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("change", function CheckboxControlValueAccessor_change_HostBindingHandler($event) {
          return ctx.onChange($event.target.checked);
        })("blur", function CheckboxControlValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    standalone: false,
    features: [ɵɵProvidersFeature([CHECKBOX_VALUE_ACCESSOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckboxControlValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]",
      host: {
        "(change)": "onChange($event.target.checked)",
        "(blur)": "onTouched()"
      },
      providers: [CHECKBOX_VALUE_ACCESSOR],
      standalone: false
    }]
  }], null, null);
})();
var DEFAULT_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => DefaultValueAccessor),
  multi: true
};
function _isAndroid() {
  const userAgent = getDOM() ? getDOM().getUserAgent() : "";
  return /android (\d+)/.test(userAgent.toLowerCase());
}
var COMPOSITION_BUFFER_MODE = new InjectionToken(ngDevMode ? "CompositionEventMode" : "");
var DefaultValueAccessor = class _DefaultValueAccessor extends BaseControlValueAccessor {
  _compositionMode;
  /** Whether the user is creating a composition string (IME events). */
  _composing = false;
  constructor(renderer, elementRef, _compositionMode) {
    super(renderer, elementRef);
    this._compositionMode = _compositionMode;
    if (this._compositionMode == null) {
      this._compositionMode = !_isAndroid();
    }
  }
  /**
   * Sets the "value" property on the input element.
   * @docs-private
   */
  writeValue(value) {
    const normalizedValue = value == null ? "" : value;
    this.setProperty("value", normalizedValue);
  }
  /** @internal */
  _handleInput(value) {
    if (!this._compositionMode || this._compositionMode && !this._composing) {
      this.onChange(value);
    }
  }
  /** @internal */
  _compositionStart() {
    this._composing = true;
  }
  /** @internal */
  _compositionEnd(value) {
    this._composing = false;
    this._compositionMode && this.onChange(value);
  }
  static ɵfac = function DefaultValueAccessor_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DefaultValueAccessor)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(COMPOSITION_BUFFER_MODE, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DefaultValueAccessor,
    selectors: [["input", "formControlName", "", 3, "type", "checkbox"], ["textarea", "formControlName", ""], ["input", "formControl", "", 3, "type", "checkbox"], ["textarea", "formControl", ""], ["input", "ngModel", "", 3, "type", "checkbox"], ["textarea", "ngModel", ""], ["", "ngDefaultControl", ""]],
    hostBindings: function DefaultValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("input", function DefaultValueAccessor_input_HostBindingHandler($event) {
          return ctx._handleInput($event.target.value);
        })("blur", function DefaultValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        })("compositionstart", function DefaultValueAccessor_compositionstart_HostBindingHandler() {
          return ctx._compositionStart();
        })("compositionend", function DefaultValueAccessor_compositionend_HostBindingHandler($event) {
          return ctx._compositionEnd($event.target.value);
        });
      }
    },
    standalone: false,
    features: [ɵɵProvidersFeature([DEFAULT_VALUE_ACCESSOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DefaultValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]",
      // TODO: vsavkin replace the above selector with the one below it once
      // https://github.com/angular/angular/issues/3011 is implemented
      // selector: '[ngModel],[formControl],[formControlName]',
      host: {
        "(input)": "$any(this)._handleInput($event.target.value)",
        "(blur)": "onTouched()",
        "(compositionstart)": "$any(this)._compositionStart()",
        "(compositionend)": "$any(this)._compositionEnd($event.target.value)"
      },
      providers: [DEFAULT_VALUE_ACCESSOR],
      standalone: false
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [COMPOSITION_BUFFER_MODE]
    }]
  }], null);
})();
function isEmptyInputValue(value) {
  return value == null || lengthOrSize(value) === 0;
}
function lengthOrSize(value) {
  if (value == null) {
    return null;
  } else if (Array.isArray(value) || typeof value === "string") {
    return value.length;
  } else if (value instanceof Set) {
    return value.size;
  }
  return null;
}
var NG_VALIDATORS = new InjectionToken(ngDevMode ? "NgValidators" : "");
var NG_ASYNC_VALIDATORS = new InjectionToken(ngDevMode ? "NgAsyncValidators" : "");
var EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
function minValidator(min) {
  return (control) => {
    if (control.value == null || min == null) {
      return null;
    }
    const value = parseFloat(control.value);
    return !isNaN(value) && value < min ? {
      "min": {
        "min": min,
        "actual": control.value
      }
    } : null;
  };
}
function maxValidator(max) {
  return (control) => {
    if (control.value == null || max == null) {
      return null;
    }
    const value = parseFloat(control.value);
    return !isNaN(value) && value > max ? {
      "max": {
        "max": max,
        "actual": control.value
      }
    } : null;
  };
}
function requiredValidator(control) {
  return isEmptyInputValue(control.value) ? {
    "required": true
  } : null;
}
function requiredTrueValidator(control) {
  return control.value === true ? null : {
    "required": true
  };
}
function emailValidator(control) {
  if (isEmptyInputValue(control.value)) {
    return null;
  }
  return EMAIL_REGEXP.test(control.value) ? null : {
    "email": true
  };
}
function minLengthValidator(minLength) {
  return (control) => {
    const length = control.value?.length ?? lengthOrSize(control.value);
    if (length === null || length === 0) {
      return null;
    }
    return length < minLength ? {
      "minlength": {
        "requiredLength": minLength,
        "actualLength": length
      }
    } : null;
  };
}
function maxLengthValidator(maxLength) {
  return (control) => {
    const length = control.value?.length ?? lengthOrSize(control.value);
    if (length !== null && length > maxLength) {
      return {
        "maxlength": {
          "requiredLength": maxLength,
          "actualLength": length
        }
      };
    }
    return null;
  };
}
function patternValidator(pattern) {
  if (!pattern) return nullValidator;
  let regex;
  let regexStr;
  if (typeof pattern === "string") {
    regexStr = "";
    if (pattern.charAt(0) !== "^") regexStr += "^";
    regexStr += pattern;
    if (pattern.charAt(pattern.length - 1) !== "$") regexStr += "$";
    regex = new RegExp(regexStr);
  } else {
    regexStr = pattern.toString();
    regex = pattern;
  }
  return (control) => {
    if (isEmptyInputValue(control.value)) {
      return null;
    }
    const value = control.value;
    return regex.test(value) ? null : {
      "pattern": {
        "requiredPattern": regexStr,
        "actualValue": value
      }
    };
  };
}
function nullValidator(control) {
  return null;
}
function isPresent(o) {
  return o != null;
}
function toObservable(value) {
  const obs = isPromise(value) ? from(value) : value;
  if ((typeof ngDevMode === "undefined" || ngDevMode) && !isSubscribable(obs)) {
    let errorMessage = `Expected async validator to return Promise or Observable.`;
    if (typeof value === "object") {
      errorMessage += " Are you using a synchronous validator where an async validator is expected?";
    }
    throw new RuntimeError(-1101, errorMessage);
  }
  return obs;
}
function mergeErrors(arrayOfErrors) {
  let res = {};
  arrayOfErrors.forEach((errors) => {
    res = errors != null ? __spreadValues(__spreadValues({}, res), errors) : res;
  });
  return Object.keys(res).length === 0 ? null : res;
}
function executeValidators(control, validators) {
  return validators.map((validator) => validator(control));
}
function isValidatorFn(validator) {
  return !validator.validate;
}
function normalizeValidators(validators) {
  return validators.map((validator) => {
    return isValidatorFn(validator) ? validator : (c) => validator.validate(c);
  });
}
function compose(validators) {
  if (!validators) return null;
  const presentValidators = validators.filter(isPresent);
  if (presentValidators.length == 0) return null;
  return function(control) {
    return mergeErrors(executeValidators(control, presentValidators));
  };
}
function composeValidators(validators) {
  return validators != null ? compose(normalizeValidators(validators)) : null;
}
function composeAsync(validators) {
  if (!validators) return null;
  const presentValidators = validators.filter(isPresent);
  if (presentValidators.length == 0) return null;
  return function(control) {
    const observables = executeValidators(control, presentValidators).map(toObservable);
    return forkJoin(observables).pipe(map(mergeErrors));
  };
}
function composeAsyncValidators(validators) {
  return validators != null ? composeAsync(normalizeValidators(validators)) : null;
}
function mergeValidators(controlValidators, dirValidator) {
  if (controlValidators === null) return [dirValidator];
  return Array.isArray(controlValidators) ? [...controlValidators, dirValidator] : [controlValidators, dirValidator];
}
function getControlValidators(control) {
  return control._rawValidators;
}
function getControlAsyncValidators(control) {
  return control._rawAsyncValidators;
}
function makeValidatorsArray(validators) {
  if (!validators) return [];
  return Array.isArray(validators) ? validators : [validators];
}
function hasValidator(validators, validator) {
  return Array.isArray(validators) ? validators.includes(validator) : validators === validator;
}
function addValidators(validators, currentValidators) {
  const current = makeValidatorsArray(currentValidators);
  const validatorsToAdd = makeValidatorsArray(validators);
  validatorsToAdd.forEach((v) => {
    if (!hasValidator(current, v)) {
      current.push(v);
    }
  });
  return current;
}
function removeValidators(validators, currentValidators) {
  return makeValidatorsArray(currentValidators).filter((v) => !hasValidator(validators, v));
}
var AbstractControlDirective = class {
  /**
   * @description
   * Reports the value of the control if it is present, otherwise null.
   */
  get value() {
    return this.control ? this.control.value : null;
  }
  /**
   * @description
   * Reports whether the control is valid. A control is considered valid if no
   * validation errors exist with the current value.
   * If the control is not present, null is returned.
   */
  get valid() {
    return this.control ? this.control.valid : null;
  }
  /**
   * @description
   * Reports whether the control is invalid, meaning that an error exists in the input value.
   * If the control is not present, null is returned.
   */
  get invalid() {
    return this.control ? this.control.invalid : null;
  }
  /**
   * @description
   * Reports whether a control is pending, meaning that async validation is occurring and
   * errors are not yet available for the input value. If the control is not present, null is
   * returned.
   */
  get pending() {
    return this.control ? this.control.pending : null;
  }
  /**
   * @description
   * Reports whether the control is disabled, meaning that the control is disabled
   * in the UI and is exempt from validation checks and excluded from aggregate
   * values of ancestor controls. If the control is not present, null is returned.
   */
  get disabled() {
    return this.control ? this.control.disabled : null;
  }
  /**
   * @description
   * Reports whether the control is enabled, meaning that the control is included in ancestor
   * calculations of validity or value. If the control is not present, null is returned.
   */
  get enabled() {
    return this.control ? this.control.enabled : null;
  }
  /**
   * @description
   * Reports the control's validation errors. If the control is not present, null is returned.
   */
  get errors() {
    return this.control ? this.control.errors : null;
  }
  /**
   * @description
   * Reports whether the control is pristine, meaning that the user has not yet changed
   * the value in the UI. If the control is not present, null is returned.
   */
  get pristine() {
    return this.control ? this.control.pristine : null;
  }
  /**
   * @description
   * Reports whether the control is dirty, meaning that the user has changed
   * the value in the UI. If the control is not present, null is returned.
   */
  get dirty() {
    return this.control ? this.control.dirty : null;
  }
  /**
   * @description
   * Reports whether the control is touched, meaning that the user has triggered
   * a `blur` event on it. If the control is not present, null is returned.
   */
  get touched() {
    return this.control ? this.control.touched : null;
  }
  /**
   * @description
   * Reports the validation status of the control. Possible values include:
   * 'VALID', 'INVALID', 'DISABLED', and 'PENDING'.
   * If the control is not present, null is returned.
   */
  get status() {
    return this.control ? this.control.status : null;
  }
  /**
   * @description
   * Reports whether the control is untouched, meaning that the user has not yet triggered
   * a `blur` event on it. If the control is not present, null is returned.
   */
  get untouched() {
    return this.control ? this.control.untouched : null;
  }
  /**
   * @description
   * Returns a multicasting observable that emits a validation status whenever it is
   * calculated for the control. If the control is not present, null is returned.
   */
  get statusChanges() {
    return this.control ? this.control.statusChanges : null;
  }
  /**
   * @description
   * Returns a multicasting observable of value changes for the control that emits every time the
   * value of the control changes in the UI or programmatically.
   * If the control is not present, null is returned.
   */
  get valueChanges() {
    return this.control ? this.control.valueChanges : null;
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return null;
  }
  /**
   * Contains the result of merging synchronous validators into a single validator function
   * (combined using `Validators.compose`).
   */
  _composedValidatorFn;
  /**
   * Contains the result of merging asynchronous validators into a single validator function
   * (combined using `Validators.composeAsync`).
   */
  _composedAsyncValidatorFn;
  /**
   * Set of synchronous validators as they were provided while calling `setValidators` function.
   * @internal
   */
  _rawValidators = [];
  /**
   * Set of asynchronous validators as they were provided while calling `setAsyncValidators`
   * function.
   * @internal
   */
  _rawAsyncValidators = [];
  /**
   * Sets synchronous validators for this directive.
   * @internal
   */
  _setValidators(validators) {
    this._rawValidators = validators || [];
    this._composedValidatorFn = composeValidators(this._rawValidators);
  }
  /**
   * Sets asynchronous validators for this directive.
   * @internal
   */
  _setAsyncValidators(validators) {
    this._rawAsyncValidators = validators || [];
    this._composedAsyncValidatorFn = composeAsyncValidators(this._rawAsyncValidators);
  }
  /**
   * @description
   * Synchronous validator function composed of all the synchronous validators registered with this
   * directive.
   */
  get validator() {
    return this._composedValidatorFn || null;
  }
  /**
   * @description
   * Asynchronous validator function composed of all the asynchronous validators registered with
   * this directive.
   */
  get asyncValidator() {
    return this._composedAsyncValidatorFn || null;
  }
  /*
   * The set of callbacks to be invoked when directive instance is being destroyed.
   */
  _onDestroyCallbacks = [];
  /**
   * Internal function to register callbacks that should be invoked
   * when directive instance is being destroyed.
   * @internal
   */
  _registerOnDestroy(fn) {
    this._onDestroyCallbacks.push(fn);
  }
  /**
   * Internal function to invoke all registered "on destroy" callbacks.
   * Note: calling this function also clears the list of callbacks.
   * @internal
   */
  _invokeOnDestroyCallbacks() {
    this._onDestroyCallbacks.forEach((fn) => fn());
    this._onDestroyCallbacks = [];
  }
  /**
   * @description
   * Resets the control with the provided value if the control is present.
   */
  reset(value = void 0) {
    if (this.control) this.control.reset(value);
  }
  /**
   * @description
   * Reports whether the control with the given path has the error specified.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   *
   * @usageNotes
   * For example, for the following `FormGroup`:
   *
   * ```ts
   * form = new FormGroup({
   *   address: new FormGroup({ street: new FormControl() })
   * });
   * ```
   *
   * The path to the 'street' control from the root form would be 'address' -> 'street'.
   *
   * It can be provided to this method in one of two formats:
   *
   * 1. An array of string control names, e.g. `['address', 'street']`
   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
   *
   * If no path is given, this method checks for the error on the current control.
   *
   * @returns whether the given error is present in the control at the given path.
   *
   * If the control is not present, false is returned.
   */
  hasError(errorCode, path) {
    return this.control ? this.control.hasError(errorCode, path) : false;
  }
  /**
   * @description
   * Reports error data for the control with the given path.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   *
   * @usageNotes
   * For example, for the following `FormGroup`:
   *
   * ```ts
   * form = new FormGroup({
   *   address: new FormGroup({ street: new FormControl() })
   * });
   * ```
   *
   * The path to the 'street' control from the root form would be 'address' -> 'street'.
   *
   * It can be provided to this method in one of two formats:
   *
   * 1. An array of string control names, e.g. `['address', 'street']`
   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
   *
   * @returns error data for that particular error. If the control or error is not present,
   * null is returned.
   */
  getError(errorCode, path) {
    return this.control ? this.control.getError(errorCode, path) : null;
  }
};
var ControlContainer = class extends AbstractControlDirective {
  /**
   * @description
   * The name for the control
   */
  name;
  /**
   * @description
   * The top-level form directive for the control.
   */
  get formDirective() {
    return null;
  }
  /**
   * @description
   * The path to this group.
   */
  get path() {
    return null;
  }
};
var NgControl = class extends AbstractControlDirective {
  /**
   * @description
   * The parent form for the control.
   *
   * @internal
   */
  _parent = null;
  /**
   * @description
   * The name for the control
   */
  name = null;
  /**
   * @description
   * The value accessor for the control
   */
  valueAccessor = null;
};
var AbstractControlStatus = class {
  _cd;
  constructor(cd) {
    this._cd = cd;
  }
  get isTouched() {
    this._cd?.control?._touched?.();
    return !!this._cd?.control?.touched;
  }
  get isUntouched() {
    return !!this._cd?.control?.untouched;
  }
  get isPristine() {
    this._cd?.control?._pristine?.();
    return !!this._cd?.control?.pristine;
  }
  get isDirty() {
    return !!this._cd?.control?.dirty;
  }
  get isValid() {
    this._cd?.control?._status?.();
    return !!this._cd?.control?.valid;
  }
  get isInvalid() {
    return !!this._cd?.control?.invalid;
  }
  get isPending() {
    return !!this._cd?.control?.pending;
  }
  get isSubmitted() {
    this._cd?._submitted?.();
    return !!this._cd?.submitted;
  }
};
var ngControlStatusHost = {
  "[class.ng-untouched]": "isUntouched",
  "[class.ng-touched]": "isTouched",
  "[class.ng-pristine]": "isPristine",
  "[class.ng-dirty]": "isDirty",
  "[class.ng-valid]": "isValid",
  "[class.ng-invalid]": "isInvalid",
  "[class.ng-pending]": "isPending"
};
var ngGroupStatusHost = __spreadProps(__spreadValues({}, ngControlStatusHost), {
  "[class.ng-submitted]": "isSubmitted"
});
var NgControlStatus = class _NgControlStatus extends AbstractControlStatus {
  constructor(cd) {
    super(cd);
  }
  static ɵfac = function NgControlStatus_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgControlStatus)(ɵɵdirectiveInject(NgControl, 2));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _NgControlStatus,
    selectors: [["", "formControlName", ""], ["", "ngModel", ""], ["", "formControl", ""]],
    hostVars: 14,
    hostBindings: function NgControlStatus_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("ng-untouched", ctx.isUntouched)("ng-touched", ctx.isTouched)("ng-pristine", ctx.isPristine)("ng-dirty", ctx.isDirty)("ng-valid", ctx.isValid)("ng-invalid", ctx.isInvalid)("ng-pending", ctx.isPending);
      }
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgControlStatus, [{
    type: Directive,
    args: [{
      selector: "[formControlName],[ngModel],[formControl]",
      host: ngControlStatusHost,
      standalone: false
    }]
  }], () => [{
    type: NgControl,
    decorators: [{
      type: Self
    }]
  }], null);
})();
var NgControlStatusGroup = class _NgControlStatusGroup extends AbstractControlStatus {
  constructor(cd) {
    super(cd);
  }
  static ɵfac = function NgControlStatusGroup_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgControlStatusGroup)(ɵɵdirectiveInject(ControlContainer, 10));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _NgControlStatusGroup,
    selectors: [["", "formGroupName", ""], ["", "formArrayName", ""], ["", "ngModelGroup", ""], ["", "formGroup", ""], ["form", 3, "ngNoForm", ""], ["", "ngForm", ""]],
    hostVars: 16,
    hostBindings: function NgControlStatusGroup_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("ng-untouched", ctx.isUntouched)("ng-touched", ctx.isTouched)("ng-pristine", ctx.isPristine)("ng-dirty", ctx.isDirty)("ng-valid", ctx.isValid)("ng-invalid", ctx.isInvalid)("ng-pending", ctx.isPending)("ng-submitted", ctx.isSubmitted);
      }
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgControlStatusGroup, [{
    type: Directive,
    args: [{
      selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]",
      host: ngGroupStatusHost,
      standalone: false
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }]
  }], null);
})();
var formControlNameExample = `
  <div [formGroup]="myGroup">
    <input formControlName="firstName">
  </div>

  In your class:

  this.myGroup = new FormGroup({
      firstName: new FormControl()
  });`;
var formGroupNameExample = `
  <div [formGroup]="myGroup">
      <div formGroupName="person">
        <input formControlName="firstName">
      </div>
  </div>

  In your class:

  this.myGroup = new FormGroup({
      person: new FormGroup({ firstName: new FormControl() })
  });`;
var formArrayNameExample = `
  <div [formGroup]="myGroup">
    <div formArrayName="cities">
      <div *ngFor="let city of cityArray.controls; index as i">
        <input [formControlName]="i">
      </div>
    </div>
  </div>

  In your class:

  this.cityArray = new FormArray([new FormControl('SF')]);
  this.myGroup = new FormGroup({
    cities: this.cityArray
  });`;
var ngModelGroupExample = `
  <form>
      <div ngModelGroup="person">
        <input [(ngModel)]="person.name" name="firstName">
      </div>
  </form>`;
var ngModelWithFormGroupExample = `
  <div [formGroup]="myGroup">
      <input formControlName="firstName">
      <input [(ngModel)]="showMoreControls" [ngModelOptions]="{standalone: true}">
  </div>
`;
function controlParentException(nameOrIndex) {
  return new RuntimeError(1050, `formControlName must be used with a parent formGroup directive. You'll want to add a formGroup
      directive and pass it an existing FormGroup instance (you can create one in your class).

      ${describeFormControl(nameOrIndex)}

    Example:

    ${formControlNameExample}`);
}
function describeFormControl(nameOrIndex) {
  if (nameOrIndex == null || nameOrIndex === "") {
    return "";
  }
  const valueType = typeof nameOrIndex === "string" ? "name" : "index";
  return `Affected Form Control ${valueType}: "${nameOrIndex}"`;
}
function ngModelGroupException() {
  return new RuntimeError(1051, `formControlName cannot be used with an ngModelGroup parent. It is only compatible with parents
      that also have a "form" prefix: formGroupName, formArrayName, or formGroup.

      Option 1:  Update the parent to be formGroupName (reactive form strategy)

      ${formGroupNameExample}

      Option 2: Use ngModel instead of formControlName (template-driven strategy)

      ${ngModelGroupExample}`);
}
function missingFormException() {
  return new RuntimeError(1052, `formGroup expects a FormGroup instance. Please pass one in.

      Example:

      ${formControlNameExample}`);
}
function groupParentException() {
  return new RuntimeError(1053, `formGroupName must be used with a parent formGroup directive.  You'll want to add a formGroup
    directive and pass it an existing FormGroup instance (you can create one in your class).

    Example:

    ${formGroupNameExample}`);
}
function arrayParentException() {
  return new RuntimeError(1054, `formArrayName must be used with a parent formGroup directive.  You'll want to add a formGroup
      directive and pass it an existing FormGroup instance (you can create one in your class).

      Example:

      ${formArrayNameExample}`);
}
var disabledAttrWarning = `
  It looks like you're using the disabled attribute with a reactive form directive. If you set disabled to true
  when you set up this control in your component class, the disabled attribute will actually be set in the DOM for
  you. We recommend using this approach to avoid 'changed after checked' errors.

  Example:
  // Specify the \`disabled\` property at control creation time:
  form = new FormGroup({
    first: new FormControl({value: 'Nancy', disabled: true}, Validators.required),
    last: new FormControl('Drew', Validators.required)
  });

  // Controls can also be enabled/disabled after creation:
  form.get('first')?.enable();
  form.get('last')?.disable();
`;
var asyncValidatorsDroppedWithOptsWarning = `
  It looks like you're constructing using a FormControl with both an options argument and an
  async validators argument. Mixing these arguments will cause your async validators to be dropped.
  You should either put all your validators in the options object, or in separate validators
  arguments. For example:

  // Using validators arguments
  fc = new FormControl(42, Validators.required, myAsyncValidator);

  // Using AbstractControlOptions
  fc = new FormControl(42, {validators: Validators.required, asyncValidators: myAV});

  // Do NOT mix them: async validators will be dropped!
  fc = new FormControl(42, {validators: Validators.required}, /* Oops! */ myAsyncValidator);
`;
function ngModelWarning(directiveName) {
  return `
  It looks like you're using ngModel on the same form field as ${directiveName}.
  Support for using the ngModel input property and ngModelChange event with
  reactive form directives has been deprecated in Angular v6 and will be removed
  in a future version of Angular.

  For more information on this, see our API docs here:
  https://angular.io/api/forms/${directiveName === "formControl" ? "FormControlDirective" : "FormControlName"}#use-with-ngmodel
  `;
}
function describeKey(isFormGroup, key) {
  return isFormGroup ? `with name: '${key}'` : `at index: ${key}`;
}
function noControlsError(isFormGroup) {
  return `
    There are no form controls registered with this ${isFormGroup ? "group" : "array"} yet. If you're using ngModel,
    you may want to check next tick (e.g. use setTimeout).
  `;
}
function missingControlError(isFormGroup, key) {
  return `Cannot find form control ${describeKey(isFormGroup, key)}`;
}
function missingControlValueError(isFormGroup, key) {
  return `Must supply a value for form control ${describeKey(isFormGroup, key)}`;
}
var VALID = "VALID";
var INVALID = "INVALID";
var PENDING = "PENDING";
var DISABLED = "DISABLED";
var ControlEvent = class {
};
var ValueChangeEvent = class extends ControlEvent {
  value;
  source;
  constructor(value, source) {
    super();
    this.value = value;
    this.source = source;
  }
};
var PristineChangeEvent = class extends ControlEvent {
  pristine;
  source;
  constructor(pristine, source) {
    super();
    this.pristine = pristine;
    this.source = source;
  }
};
var TouchedChangeEvent = class extends ControlEvent {
  touched;
  source;
  constructor(touched, source) {
    super();
    this.touched = touched;
    this.source = source;
  }
};
var StatusChangeEvent = class extends ControlEvent {
  status;
  source;
  constructor(status, source) {
    super();
    this.status = status;
    this.source = source;
  }
};
var FormSubmittedEvent = class extends ControlEvent {
  source;
  constructor(source) {
    super();
    this.source = source;
  }
};
var FormResetEvent = class extends ControlEvent {
  source;
  constructor(source) {
    super();
    this.source = source;
  }
};
function pickValidators(validatorOrOpts) {
  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.validators : validatorOrOpts) || null;
}
function coerceToValidator(validator) {
  return Array.isArray(validator) ? composeValidators(validator) : validator || null;
}
function pickAsyncValidators(asyncValidator, validatorOrOpts) {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (isOptionsObj(validatorOrOpts) && asyncValidator) {
      console.warn(asyncValidatorsDroppedWithOptsWarning);
    }
  }
  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.asyncValidators : asyncValidator) || null;
}
function coerceToAsyncValidator(asyncValidator) {
  return Array.isArray(asyncValidator) ? composeAsyncValidators(asyncValidator) : asyncValidator || null;
}
function isOptionsObj(validatorOrOpts) {
  return validatorOrOpts != null && !Array.isArray(validatorOrOpts) && typeof validatorOrOpts === "object";
}
function assertControlPresent(parent, isGroup, key) {
  const controls = parent.controls;
  const collection = isGroup ? Object.keys(controls) : controls;
  if (!collection.length) {
    throw new RuntimeError(1e3, typeof ngDevMode === "undefined" || ngDevMode ? noControlsError(isGroup) : "");
  }
  if (!controls[key]) {
    throw new RuntimeError(1001, typeof ngDevMode === "undefined" || ngDevMode ? missingControlError(isGroup, key) : "");
  }
}
function assertAllValuesPresent(control, isGroup, value) {
  control._forEachChild((_, key) => {
    if (value[key] === void 0) {
      throw new RuntimeError(1002, typeof ngDevMode === "undefined" || ngDevMode ? missingControlValueError(isGroup, key) : "");
    }
  });
}
var AbstractControl = class {
  /** @internal */
  _pendingDirty = false;
  /**
   * Indicates that a control has its own pending asynchronous validation in progress.
   * It also stores if the control should emit events when the validation status changes.
   *
   * @internal
   */
  _hasOwnPendingAsyncValidator = null;
  /** @internal */
  _pendingTouched = false;
  /** @internal */
  _onCollectionChange = () => {
  };
  /** @internal */
  _updateOn;
  _parent = null;
  _asyncValidationSubscription;
  /**
   * Contains the result of merging synchronous validators into a single validator function
   * (combined using `Validators.compose`).
   *
   * @internal
   */
  _composedValidatorFn;
  /**
   * Contains the result of merging asynchronous validators into a single validator function
   * (combined using `Validators.composeAsync`).
   *
   * @internal
   */
  _composedAsyncValidatorFn;
  /**
   * Synchronous validators as they were provided:
   *  - in `AbstractControl` constructor
   *  - as an argument while calling `setValidators` function
   *  - while calling the setter on the `validator` field (e.g. `control.validator = validatorFn`)
   *
   * @internal
   */
  _rawValidators;
  /**
   * Asynchronous validators as they were provided:
   *  - in `AbstractControl` constructor
   *  - as an argument while calling `setAsyncValidators` function
   *  - while calling the setter on the `asyncValidator` field (e.g. `control.asyncValidator =
   * asyncValidatorFn`)
   *
   * @internal
   */
  _rawAsyncValidators;
  /**
   * The current value of the control.
   *
   * * For a `FormControl`, the current value.
   * * For an enabled `FormGroup`, the values of enabled controls as an object
   * with a key-value pair for each member of the group.
   * * For a disabled `FormGroup`, the values of all controls as an object
   * with a key-value pair for each member of the group.
   * * For a `FormArray`, the values of enabled controls as an array.
   *
   */
  value;
  /**
   * Initialize the AbstractControl instance.
   *
   * @param validators The function or array of functions that is used to determine the validity of
   *     this control synchronously.
   * @param asyncValidators The function or array of functions that is used to determine validity of
   *     this control asynchronously.
   */
  constructor(validators, asyncValidators) {
    this._assignValidators(validators);
    this._assignAsyncValidators(asyncValidators);
  }
  /**
   * Returns the function that is used to determine the validity of this control synchronously.
   * If multiple validators have been added, this will be a single composed function.
   * See `Validators.compose()` for additional information.
   */
  get validator() {
    return this._composedValidatorFn;
  }
  set validator(validatorFn) {
    this._rawValidators = this._composedValidatorFn = validatorFn;
  }
  /**
   * Returns the function that is used to determine the validity of this control asynchronously.
   * If multiple validators have been added, this will be a single composed function.
   * See `Validators.compose()` for additional information.
   */
  get asyncValidator() {
    return this._composedAsyncValidatorFn;
  }
  set asyncValidator(asyncValidatorFn) {
    this._rawAsyncValidators = this._composedAsyncValidatorFn = asyncValidatorFn;
  }
  /**
   * The parent control.
   */
  get parent() {
    return this._parent;
  }
  /**
   * The validation status of the control.
   *
   * @see {@link FormControlStatus}
   *
   * These status values are mutually exclusive, so a control cannot be
   * both valid AND invalid or invalid AND disabled.
   */
  get status() {
    return untracked(this.statusReactive);
  }
  set status(v) {
    untracked(() => this.statusReactive.set(v));
  }
  /** @internal */
  _status = computed(() => this.statusReactive());
  statusReactive = signal(void 0);
  /**
   * A control is `valid` when its `status` is `VALID`.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if the control has passed all of its validation tests,
   * false otherwise.
   */
  get valid() {
    return this.status === VALID;
  }
  /**
   * A control is `invalid` when its `status` is `INVALID`.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if this control has failed one or more of its validation checks,
   * false otherwise.
   */
  get invalid() {
    return this.status === INVALID;
  }
  /**
   * A control is `pending` when its `status` is `PENDING`.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if this control is in the process of conducting a validation check,
   * false otherwise.
   */
  get pending() {
    return this.status == PENDING;
  }
  /**
   * A control is `disabled` when its `status` is `DISABLED`.
   *
   * Disabled controls are exempt from validation checks and
   * are not included in the aggregate value of their ancestor
   * controls.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if the control is disabled, false otherwise.
   */
  get disabled() {
    return this.status === DISABLED;
  }
  /**
   * A control is `enabled` as long as its `status` is not `DISABLED`.
   *
   * @returns True if the control has any status other than 'DISABLED',
   * false if the status is 'DISABLED'.
   *
   * @see {@link AbstractControl.status}
   *
   */
  get enabled() {
    return this.status !== DISABLED;
  }
  /**
   * An object containing any errors generated by failing validation,
   * or null if there are no errors.
   */
  errors;
  /**
   * A control is `pristine` if the user has not yet changed
   * the value in the UI.
   *
   * @returns True if the user has not yet changed the value in the UI; compare `dirty`.
   * Programmatic changes to a control's value do not mark it dirty.
   */
  get pristine() {
    return untracked(this.pristineReactive);
  }
  set pristine(v) {
    untracked(() => this.pristineReactive.set(v));
  }
  /** @internal */
  _pristine = computed(() => this.pristineReactive());
  pristineReactive = signal(true);
  /**
   * A control is `dirty` if the user has changed the value
   * in the UI.
   *
   * @returns True if the user has changed the value of this control in the UI; compare `pristine`.
   * Programmatic changes to a control's value do not mark it dirty.
   */
  get dirty() {
    return !this.pristine;
  }
  /**
   * True if the control is marked as `touched`.
   *
   * A control is marked `touched` once the user has triggered
   * a `blur` event on it.
   */
  get touched() {
    return untracked(this.touchedReactive);
  }
  set touched(v) {
    untracked(() => this.touchedReactive.set(v));
  }
  /** @internal */
  _touched = computed(() => this.touchedReactive());
  touchedReactive = signal(false);
  /**
   * True if the control has not been marked as touched
   *
   * A control is `untouched` if the user has not yet triggered
   * a `blur` event on it.
   */
  get untouched() {
    return !this.touched;
  }
  /**
   * Exposed as observable, see below.
   *
   * @internal
   */
  _events = new Subject();
  /**
   * A multicasting observable that emits an event every time the state of the control changes.
   * It emits for value, status, pristine or touched changes.
   *
   * **Note**: On value change, the emit happens right after a value of this control is updated. The
   * value of a parent control (for example if this FormControl is a part of a FormGroup) is updated
   * later, so accessing a value of a parent control (using the `value` property) from the callback
   * of this event might result in getting a value that has not been updated yet. Subscribe to the
   * `events` of the parent control instead.
   * For other event types, the events are emitted after the parent control has been updated.
   *
   */
  events = this._events.asObservable();
  /**
   * A multicasting observable that emits an event every time the value of the control changes, in
   * the UI or programmatically. It also emits an event each time you call enable() or disable()
   * without passing along {emitEvent: false} as a function argument.
   *
   * **Note**: the emit happens right after a value of this control is updated. The value of a
   * parent control (for example if this FormControl is a part of a FormGroup) is updated later, so
   * accessing a value of a parent control (using the `value` property) from the callback of this
   * event might result in getting a value that has not been updated yet. Subscribe to the
   * `valueChanges` event of the parent control instead.
   */
  valueChanges;
  /**
   * A multicasting observable that emits an event every time the validation `status` of the control
   * recalculates.
   *
   * @see {@link FormControlStatus}
   * @see {@link AbstractControl.status}
   */
  statusChanges;
  /**
   * Reports the update strategy of the `AbstractControl` (meaning
   * the event on which the control updates itself).
   * Possible values: `'change'` | `'blur'` | `'submit'`
   * Default value: `'change'`
   */
  get updateOn() {
    return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change";
  }
  /**
   * Sets the synchronous validators that are active on this control.  Calling
   * this overwrites any existing synchronous validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * If you want to add a new validator without affecting existing ones, consider
   * using `addValidators()` method instead.
   */
  setValidators(validators) {
    this._assignValidators(validators);
  }
  /**
   * Sets the asynchronous validators that are active on this control. Calling this
   * overwrites any existing asynchronous validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * If you want to add a new validator without affecting existing ones, consider
   * using `addAsyncValidators()` method instead.
   */
  setAsyncValidators(validators) {
    this._assignAsyncValidators(validators);
  }
  /**
   * Add a synchronous validator or validators to this control, without affecting other validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * Adding a validator that already exists will have no effect. If duplicate validator functions
   * are present in the `validators` array, only the first instance would be added to a form
   * control.
   *
   * @param validators The new validator function or functions to add to this control.
   */
  addValidators(validators) {
    this.setValidators(addValidators(validators, this._rawValidators));
  }
  /**
   * Add an asynchronous validator or validators to this control, without affecting other
   * validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * Adding a validator that already exists will have no effect.
   *
   * @param validators The new asynchronous validator function or functions to add to this control.
   */
  addAsyncValidators(validators) {
    this.setAsyncValidators(addValidators(validators, this._rawAsyncValidators));
  }
  /**
   * Remove a synchronous validator from this control, without affecting other validators.
   * Validators are compared by function reference; you must pass a reference to the exact same
   * validator function as the one that was originally set. If a provided validator is not found,
   * it is ignored.
   *
   * @usageNotes
   *
   * ### Reference to a ValidatorFn
   *
   * ```
   * // Reference to the RequiredValidator
   * const ctrl = new FormControl<string | null>('', Validators.required);
   * ctrl.removeValidators(Validators.required);
   *
   * // Reference to anonymous function inside MinValidator
   * const minValidator = Validators.min(3);
   * const ctrl = new FormControl<string | null>('', minValidator);
   * expect(ctrl.hasValidator(minValidator)).toEqual(true)
   * expect(ctrl.hasValidator(Validators.min(3))).toEqual(false)
   *
   * ctrl.removeValidators(minValidator);
   * ```
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * @param validators The validator or validators to remove.
   */
  removeValidators(validators) {
    this.setValidators(removeValidators(validators, this._rawValidators));
  }
  /**
   * Remove an asynchronous validator from this control, without affecting other validators.
   * Validators are compared by function reference; you must pass a reference to the exact same
   * validator function as the one that was originally set. If a provided validator is not found, it
   * is ignored.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * @param validators The asynchronous validator or validators to remove.
   */
  removeAsyncValidators(validators) {
    this.setAsyncValidators(removeValidators(validators, this._rawAsyncValidators));
  }
  /**
   * Check whether a synchronous validator function is present on this control. The provided
   * validator must be a reference to the exact same function that was provided.
   *
   * @usageNotes
   *
   * ### Reference to a ValidatorFn
   *
   * ```
   * // Reference to the RequiredValidator
   * const ctrl = new FormControl<number | null>(0, Validators.required);
   * expect(ctrl.hasValidator(Validators.required)).toEqual(true)
   *
   * // Reference to anonymous function inside MinValidator
   * const minValidator = Validators.min(3);
   * const ctrl = new FormControl<number | null>(0, minValidator);
   * expect(ctrl.hasValidator(minValidator)).toEqual(true)
   * expect(ctrl.hasValidator(Validators.min(3))).toEqual(false)
   * ```
   *
   * @param validator The validator to check for presence. Compared by function reference.
   * @returns Whether the provided validator was found on this control.
   */
  hasValidator(validator) {
    return hasValidator(this._rawValidators, validator);
  }
  /**
   * Check whether an asynchronous validator function is present on this control. The provided
   * validator must be a reference to the exact same function that was provided.
   *
   * @param validator The asynchronous validator to check for presence. Compared by function
   *     reference.
   * @returns Whether the provided asynchronous validator was found on this control.
   */
  hasAsyncValidator(validator) {
    return hasValidator(this._rawAsyncValidators, validator);
  }
  /**
   * Empties out the synchronous validator list.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   */
  clearValidators() {
    this.validator = null;
  }
  /**
   * Empties out the async validator list.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   */
  clearAsyncValidators() {
    this.asyncValidator = null;
  }
  markAsTouched(opts = {}) {
    const changed = this.touched === false;
    this.touched = true;
    const sourceControl = opts.sourceControl ?? this;
    if (this._parent && !opts.onlySelf) {
      this._parent.markAsTouched(__spreadProps(__spreadValues({}, opts), {
        sourceControl
      }));
    }
    if (changed && opts.emitEvent !== false) {
      this._events.next(new TouchedChangeEvent(true, sourceControl));
    }
  }
  /**
   * Marks the control and all its descendant controls as `touched`.
   * @see {@link markAsTouched()}
   *
   * @param opts Configuration options that determine how the control propagates changes
   * and emits events after marking is applied.
   * * `emitEvent`: When true or not supplied (the default), the `events`
   * observable emits a `TouchedChangeEvent` with the `touched` property being `true`.
   * When false, no events are emitted.
   */
  markAllAsTouched(opts = {}) {
    this.markAsTouched({
      onlySelf: true,
      emitEvent: opts.emitEvent,
      sourceControl: this
    });
    this._forEachChild((control) => control.markAllAsTouched(opts));
  }
  markAsUntouched(opts = {}) {
    const changed = this.touched === true;
    this.touched = false;
    this._pendingTouched = false;
    const sourceControl = opts.sourceControl ?? this;
    this._forEachChild((control) => {
      control.markAsUntouched({
        onlySelf: true,
        emitEvent: opts.emitEvent,
        sourceControl
      });
    });
    if (this._parent && !opts.onlySelf) {
      this._parent._updateTouched(opts, sourceControl);
    }
    if (changed && opts.emitEvent !== false) {
      this._events.next(new TouchedChangeEvent(false, sourceControl));
    }
  }
  markAsDirty(opts = {}) {
    const changed = this.pristine === true;
    this.pristine = false;
    const sourceControl = opts.sourceControl ?? this;
    if (this._parent && !opts.onlySelf) {
      this._parent.markAsDirty(__spreadProps(__spreadValues({}, opts), {
        sourceControl
      }));
    }
    if (changed && opts.emitEvent !== false) {
      this._events.next(new PristineChangeEvent(false, sourceControl));
    }
  }
  markAsPristine(opts = {}) {
    const changed = this.pristine === false;
    this.pristine = true;
    this._pendingDirty = false;
    const sourceControl = opts.sourceControl ?? this;
    this._forEachChild((control) => {
      control.markAsPristine({
        onlySelf: true,
        emitEvent: opts.emitEvent
      });
    });
    if (this._parent && !opts.onlySelf) {
      this._parent._updatePristine(opts, sourceControl);
    }
    if (changed && opts.emitEvent !== false) {
      this._events.next(new PristineChangeEvent(true, sourceControl));
    }
  }
  markAsPending(opts = {}) {
    this.status = PENDING;
    const sourceControl = opts.sourceControl ?? this;
    if (opts.emitEvent !== false) {
      this._events.next(new StatusChangeEvent(this.status, sourceControl));
      this.statusChanges.emit(this.status);
    }
    if (this._parent && !opts.onlySelf) {
      this._parent.markAsPending(__spreadProps(__spreadValues({}, opts), {
        sourceControl
      }));
    }
  }
  disable(opts = {}) {
    const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);
    this.status = DISABLED;
    this.errors = null;
    this._forEachChild((control) => {
      control.disable(__spreadProps(__spreadValues({}, opts), {
        onlySelf: true
      }));
    });
    this._updateValue();
    const sourceControl = opts.sourceControl ?? this;
    if (opts.emitEvent !== false) {
      this._events.next(new ValueChangeEvent(this.value, sourceControl));
      this._events.next(new StatusChangeEvent(this.status, sourceControl));
      this.valueChanges.emit(this.value);
      this.statusChanges.emit(this.status);
    }
    this._updateAncestors(__spreadProps(__spreadValues({}, opts), {
      skipPristineCheck
    }), this);
    this._onDisabledChange.forEach((changeFn) => changeFn(true));
  }
  /**
   * Enables the control. This means the control is included in validation checks and
   * the aggregate value of its parent. Its status recalculates based on its value and
   * its validators.
   *
   * By default, if the control has children, all children are enabled.
   *
   * @see {@link AbstractControl.status}
   *
   * @param opts Configure options that control how the control propagates changes and
   * emits events when marked as untouched
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   * * `emitEvent`: When true or not supplied (the default), the `statusChanges`,
   * `valueChanges` and `events`
   * observables emit events with the latest status and value when the control is enabled.
   * When false, no events are emitted.
   */
  enable(opts = {}) {
    const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);
    this.status = VALID;
    this._forEachChild((control) => {
      control.enable(__spreadProps(__spreadValues({}, opts), {
        onlySelf: true
      }));
    });
    this.updateValueAndValidity({
      onlySelf: true,
      emitEvent: opts.emitEvent
    });
    this._updateAncestors(__spreadProps(__spreadValues({}, opts), {
      skipPristineCheck
    }), this);
    this._onDisabledChange.forEach((changeFn) => changeFn(false));
  }
  _updateAncestors(opts, sourceControl) {
    if (this._parent && !opts.onlySelf) {
      this._parent.updateValueAndValidity(opts);
      if (!opts.skipPristineCheck) {
        this._parent._updatePristine({}, sourceControl);
      }
      this._parent._updateTouched({}, sourceControl);
    }
  }
  /**
   * Sets the parent of the control
   *
   * @param parent The new parent.
   */
  setParent(parent) {
    this._parent = parent;
  }
  /**
   * The raw value of this control. For most control implementations, the raw value will include
   * disabled children.
   */
  getRawValue() {
    return this.value;
  }
  updateValueAndValidity(opts = {}) {
    this._setInitialStatus();
    this._updateValue();
    if (this.enabled) {
      const shouldHaveEmitted = this._cancelExistingSubscription();
      this.errors = this._runValidator();
      this.status = this._calculateStatus();
      if (this.status === VALID || this.status === PENDING) {
        this._runAsyncValidator(shouldHaveEmitted, opts.emitEvent);
      }
    }
    const sourceControl = opts.sourceControl ?? this;
    if (opts.emitEvent !== false) {
      this._events.next(new ValueChangeEvent(this.value, sourceControl));
      this._events.next(new StatusChangeEvent(this.status, sourceControl));
      this.valueChanges.emit(this.value);
      this.statusChanges.emit(this.status);
    }
    if (this._parent && !opts.onlySelf) {
      this._parent.updateValueAndValidity(__spreadProps(__spreadValues({}, opts), {
        sourceControl
      }));
    }
  }
  /** @internal */
  _updateTreeValidity(opts = {
    emitEvent: true
  }) {
    this._forEachChild((ctrl) => ctrl._updateTreeValidity(opts));
    this.updateValueAndValidity({
      onlySelf: true,
      emitEvent: opts.emitEvent
    });
  }
  _setInitialStatus() {
    this.status = this._allControlsDisabled() ? DISABLED : VALID;
  }
  _runValidator() {
    return this.validator ? this.validator(this) : null;
  }
  _runAsyncValidator(shouldHaveEmitted, emitEvent) {
    if (this.asyncValidator) {
      this.status = PENDING;
      this._hasOwnPendingAsyncValidator = {
        emitEvent: emitEvent !== false
      };
      const obs = toObservable(this.asyncValidator(this));
      this._asyncValidationSubscription = obs.subscribe((errors) => {
        this._hasOwnPendingAsyncValidator = null;
        this.setErrors(errors, {
          emitEvent,
          shouldHaveEmitted
        });
      });
    }
  }
  _cancelExistingSubscription() {
    if (this._asyncValidationSubscription) {
      this._asyncValidationSubscription.unsubscribe();
      const shouldHaveEmitted = this._hasOwnPendingAsyncValidator?.emitEvent ?? false;
      this._hasOwnPendingAsyncValidator = null;
      return shouldHaveEmitted;
    }
    return false;
  }
  setErrors(errors, opts = {}) {
    this.errors = errors;
    this._updateControlsErrors(opts.emitEvent !== false, this, opts.shouldHaveEmitted);
  }
  /**
   * Retrieves a child control given the control's name or path.
   *
   * @param path A dot-delimited string or array of string/number values that define the path to the
   * control. If a string is provided, passing it as a string literal will result in improved type
   * information. Likewise, if an array is provided, passing it `as const` will cause improved type
   * information to be available.
   *
   * @usageNotes
   * ### Retrieve a nested control
   *
   * For example, to get a `name` control nested within a `person` sub-group:
   *
   * * `this.form.get('person.name');`
   *
   * -OR-
   *
   * * `this.form.get(['person', 'name'] as const);` // `as const` gives improved typings
   *
   * ### Retrieve a control in a FormArray
   *
   * When accessing an element inside a FormArray, you can use an element index.
   * For example, to get a `price` control from the first element in an `items` array you can use:
   *
   * * `this.form.get('items.0.price');`
   *
   * -OR-
   *
   * * `this.form.get(['items', 0, 'price']);`
   */
  get(path) {
    let currPath = path;
    if (currPath == null) return null;
    if (!Array.isArray(currPath)) currPath = currPath.split(".");
    if (currPath.length === 0) return null;
    return currPath.reduce((control, name) => control && control._find(name), this);
  }
  /**
   * @description
   * Reports error data for the control with the given path.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   *
   * @usageNotes
   * For example, for the following `FormGroup`:
   *
   * ```ts
   * form = new FormGroup({
   *   address: new FormGroup({ street: new FormControl() })
   * });
   * ```
   *
   * The path to the 'street' control from the root form would be 'address' -> 'street'.
   *
   * It can be provided to this method in one of two formats:
   *
   * 1. An array of string control names, e.g. `['address', 'street']`
   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
   *
   * @returns error data for that particular error. If the control or error is not present,
   * null is returned.
   */
  getError(errorCode, path) {
    const control = path ? this.get(path) : this;
    return control && control.errors ? control.errors[errorCode] : null;
  }
  /**
   * @description
   * Reports whether the control with the given path has the error specified.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   *
   * @usageNotes
   * For example, for the following `FormGroup`:
   *
   * ```ts
   * form = new FormGroup({
   *   address: new FormGroup({ street: new FormControl() })
   * });
   * ```
   *
   * The path to the 'street' control from the root form would be 'address' -> 'street'.
   *
   * It can be provided to this method in one of two formats:
   *
   * 1. An array of string control names, e.g. `['address', 'street']`
   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
   *
   * If no path is given, this method checks for the error on the current control.
   *
   * @returns whether the given error is present in the control at the given path.
   *
   * If the control is not present, false is returned.
   */
  hasError(errorCode, path) {
    return !!this.getError(errorCode, path);
  }
  /**
   * Retrieves the top-level ancestor of this control.
   */
  get root() {
    let x = this;
    while (x._parent) {
      x = x._parent;
    }
    return x;
  }
  /** @internal */
  _updateControlsErrors(emitEvent, changedControl, shouldHaveEmitted) {
    this.status = this._calculateStatus();
    if (emitEvent) {
      this.statusChanges.emit(this.status);
    }
    if (emitEvent || shouldHaveEmitted) {
      this._events.next(new StatusChangeEvent(this.status, changedControl));
    }
    if (this._parent) {
      this._parent._updateControlsErrors(emitEvent, changedControl, shouldHaveEmitted);
    }
  }
  /** @internal */
  _initObservables() {
    this.valueChanges = new EventEmitter();
    this.statusChanges = new EventEmitter();
  }
  _calculateStatus() {
    if (this._allControlsDisabled()) return DISABLED;
    if (this.errors) return INVALID;
    if (this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(PENDING)) return PENDING;
    if (this._anyControlsHaveStatus(INVALID)) return INVALID;
    return VALID;
  }
  /** @internal */
  _anyControlsHaveStatus(status) {
    return this._anyControls((control) => control.status === status);
  }
  /** @internal */
  _anyControlsDirty() {
    return this._anyControls((control) => control.dirty);
  }
  /** @internal */
  _anyControlsTouched() {
    return this._anyControls((control) => control.touched);
  }
  /** @internal */
  _updatePristine(opts, changedControl) {
    const newPristine = !this._anyControlsDirty();
    const changed = this.pristine !== newPristine;
    this.pristine = newPristine;
    if (this._parent && !opts.onlySelf) {
      this._parent._updatePristine(opts, changedControl);
    }
    if (changed) {
      this._events.next(new PristineChangeEvent(this.pristine, changedControl));
    }
  }
  /** @internal */
  _updateTouched(opts = {}, changedControl) {
    this.touched = this._anyControlsTouched();
    this._events.next(new TouchedChangeEvent(this.touched, changedControl));
    if (this._parent && !opts.onlySelf) {
      this._parent._updateTouched(opts, changedControl);
    }
  }
  /** @internal */
  _onDisabledChange = [];
  /** @internal */
  _registerOnCollectionChange(fn) {
    this._onCollectionChange = fn;
  }
  /** @internal */
  _setUpdateStrategy(opts) {
    if (isOptionsObj(opts) && opts.updateOn != null) {
      this._updateOn = opts.updateOn;
    }
  }
  /**
   * Check to see if parent has been marked artificially dirty.
   *
   * @internal
   */
  _parentMarkedDirty(onlySelf) {
    const parentDirty = this._parent && this._parent.dirty;
    return !onlySelf && !!parentDirty && !this._parent._anyControlsDirty();
  }
  /** @internal */
  _find(name) {
    return null;
  }
  /**
   * Internal implementation of the `setValidators` method. Needs to be separated out into a
   * different method, because it is called in the constructor and it can break cases where
   * a control is extended.
   */
  _assignValidators(validators) {
    this._rawValidators = Array.isArray(validators) ? validators.slice() : validators;
    this._composedValidatorFn = coerceToValidator(this._rawValidators);
  }
  /**
   * Internal implementation of the `setAsyncValidators` method. Needs to be separated out into a
   * different method, because it is called in the constructor and it can break cases where
   * a control is extended.
   */
  _assignAsyncValidators(validators) {
    this._rawAsyncValidators = Array.isArray(validators) ? validators.slice() : validators;
    this._composedAsyncValidatorFn = coerceToAsyncValidator(this._rawAsyncValidators);
  }
};
var FormGroup = class extends AbstractControl {
  /**
   * Creates a new `FormGroup` instance.
   *
   * @param controls A collection of child controls. The key for each child is the name
   * under which it is registered.
   *
   * @param validatorOrOpts A synchronous validator function, or an array of
   * such functions, or an `AbstractControlOptions` object that contains validation functions
   * and a validation trigger.
   *
   * @param asyncValidator A single async validator or array of async validator functions
   *
   */
  constructor(controls, validatorOrOpts, asyncValidator) {
    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
    (typeof ngDevMode === "undefined" || ngDevMode) && validateFormGroupControls(controls);
    this.controls = controls;
    this._initObservables();
    this._setUpdateStrategy(validatorOrOpts);
    this._setUpControls();
    this.updateValueAndValidity({
      onlySelf: true,
      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
      // `VALID` or `INVALID`. The status should be broadcasted via the `statusChanges` observable,
      // so we set `emitEvent` to `true` to allow that during the control creation process.
      emitEvent: !!this.asyncValidator
    });
  }
  controls;
  registerControl(name, control) {
    if (this.controls[name]) return this.controls[name];
    this.controls[name] = control;
    control.setParent(this);
    control._registerOnCollectionChange(this._onCollectionChange);
    return control;
  }
  addControl(name, control, options = {}) {
    this.registerControl(name, control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  /**
   * Remove a control from this group. In a strongly-typed group, required controls cannot be
   * removed.
   *
   * This method also updates the value and validity of the control.
   *
   * @param name The control name to remove from the collection
   * @param options Specifies whether this FormGroup instance should emit events after a
   *     control is removed.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * removed. When false, no events are emitted.
   */
  removeControl(name, options = {}) {
    if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {
    });
    delete this.controls[name];
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  setControl(name, control, options = {}) {
    if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {
    });
    delete this.controls[name];
    if (control) this.registerControl(name, control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  contains(controlName) {
    return this.controls.hasOwnProperty(controlName) && this.controls[controlName].enabled;
  }
  /**
   * Sets the value of the `FormGroup`. It accepts an object that matches
   * the structure of the group, with control names as keys.
   *
   * @usageNotes
   * ### Set the complete value for the form group
   *
   * ```ts
   * const form = new FormGroup({
   *   first: new FormControl(),
   *   last: new FormControl()
   * });
   *
   * console.log(form.value);   // {first: null, last: null}
   *
   * form.setValue({first: 'Nancy', last: 'Drew'});
   * console.log(form.value);   // {first: 'Nancy', last: 'Drew'}
   * ```
   *
   * @throws When strict checks fail, such as setting the value of a control
   * that doesn't exist or if you exclude a value of a control that does exist.
   *
   * @param value The new value for the control that matches the structure of the group.
   * @param options Configuration options that determine how the control propagates changes
   * and emits events after the value changes.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is
   * false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control value is updated.
   * When false, no events are emitted.
   */
  setValue(value, options = {}) {
    assertAllValuesPresent(this, true, value);
    Object.keys(value).forEach((name) => {
      assertControlPresent(this, true, name);
      this.controls[name].setValue(value[name], {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Patches the value of the `FormGroup`. It accepts an object with control
   * names as keys, and does its best to match the values to the correct controls
   * in the group.
   *
   * It accepts both super-sets and sub-sets of the group without throwing an error.
   *
   * @usageNotes
   * ### Patch the value for a form group
   *
   * ```ts
   * const form = new FormGroup({
   *    first: new FormControl(),
   *    last: new FormControl()
   * });
   * console.log(form.value);   // {first: null, last: null}
   *
   * form.patchValue({first: 'Nancy'});
   * console.log(form.value);   // {first: 'Nancy', last: null}
   * ```
   *
   * @param value The object that matches the structure of the group.
   * @param options Configuration options that determine how the control propagates changes and
   * emits events after the value is patched.
   * * `onlySelf`: When true, each change only affects this control and not its parent. Default is
   * true.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control value
   * is updated. When false, no events are emitted. The configuration options are passed to
   * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.
   */
  patchValue(value, options = {}) {
    if (value == null) return;
    Object.keys(value).forEach((name) => {
      const control = this.controls[name];
      if (control) {
        control.patchValue(
          /* Guaranteed to be present, due to the outer forEach. */
          value[name],
          {
            onlySelf: true,
            emitEvent: options.emitEvent
          }
        );
      }
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Resets the `FormGroup`, marks all descendants `pristine` and `untouched` and sets
   * the value of all descendants to their default values, or null if no defaults were provided.
   *
   * You reset to a specific form state by passing in a map of states
   * that matches the structure of your form, with control names as keys. The state
   * is a standalone value or a form state object with both a value and a disabled
   * status.
   *
   * @param value Resets the control with an initial value,
   * or an object that defines the initial value and disabled state.
   *
   * @param options Configuration options that determine how the control propagates changes
   * and emits events when the group is reset.
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is
   * false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control is reset.
   * When false, no events are emitted.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   *
   * @usageNotes
   *
   * ### Reset the form group values
   *
   * ```ts
   * const form = new FormGroup({
   *   first: new FormControl('first name'),
   *   last: new FormControl('last name')
   * });
   *
   * console.log(form.value);  // {first: 'first name', last: 'last name'}
   *
   * form.reset({ first: 'name', last: 'last name' });
   *
   * console.log(form.value);  // {first: 'name', last: 'last name'}
   * ```
   *
   * ### Reset the form group values and disabled status
   *
   * ```ts
   * const form = new FormGroup({
   *   first: new FormControl('first name'),
   *   last: new FormControl('last name')
   * });
   *
   * form.reset({
   *   first: {value: 'name', disabled: true},
   *   last: 'last'
   * });
   *
   * console.log(form.value);  // {last: 'last'}
   * console.log(form.get('first').status);  // 'DISABLED'
   * ```
   */
  reset(value = {}, options = {}) {
    this._forEachChild((control, name) => {
      control.reset(value ? value[name] : null, {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this._updatePristine(options, this);
    this._updateTouched(options, this);
    this.updateValueAndValidity(options);
  }
  /**
   * The aggregate value of the `FormGroup`, including any disabled controls.
   *
   * Retrieves all values regardless of disabled status.
   */
  getRawValue() {
    return this._reduceChildren({}, (acc, control, name) => {
      acc[name] = control.getRawValue();
      return acc;
    });
  }
  /** @internal */
  _syncPendingControls() {
    let subtreeUpdated = this._reduceChildren(false, (updated, child) => {
      return child._syncPendingControls() ? true : updated;
    });
    if (subtreeUpdated) this.updateValueAndValidity({
      onlySelf: true
    });
    return subtreeUpdated;
  }
  /** @internal */
  _forEachChild(cb) {
    Object.keys(this.controls).forEach((key) => {
      const control = this.controls[key];
      control && cb(control, key);
    });
  }
  /** @internal */
  _setUpControls() {
    this._forEachChild((control) => {
      control.setParent(this);
      control._registerOnCollectionChange(this._onCollectionChange);
    });
  }
  /** @internal */
  _updateValue() {
    this.value = this._reduceValue();
  }
  /** @internal */
  _anyControls(condition) {
    for (const [controlName, control] of Object.entries(this.controls)) {
      if (this.contains(controlName) && condition(control)) {
        return true;
      }
    }
    return false;
  }
  /** @internal */
  _reduceValue() {
    let acc = {};
    return this._reduceChildren(acc, (acc2, control, name) => {
      if (control.enabled || this.disabled) {
        acc2[name] = control.value;
      }
      return acc2;
    });
  }
  /** @internal */
  _reduceChildren(initValue, fn) {
    let res = initValue;
    this._forEachChild((control, name) => {
      res = fn(res, control, name);
    });
    return res;
  }
  /** @internal */
  _allControlsDisabled() {
    for (const controlName of Object.keys(this.controls)) {
      if (this.controls[controlName].enabled) {
        return false;
      }
    }
    return Object.keys(this.controls).length > 0 || this.disabled;
  }
  /** @internal */
  _find(name) {
    return this.controls.hasOwnProperty(name) ? this.controls[name] : null;
  }
};
function validateFormGroupControls(controls) {
  const invalidKeys = Object.keys(controls).filter((key) => key.includes("."));
  if (invalidKeys.length > 0) {
    console.warn(`FormGroup keys cannot include \`.\`, please replace the keys for: ${invalidKeys.join(",")}.`);
  }
}
var FormRecord = class extends FormGroup {
};
var CALL_SET_DISABLED_STATE = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "CallSetDisabledState" : "", {
  providedIn: "root",
  factory: () => setDisabledStateDefault
});
var setDisabledStateDefault = "always";
function controlPath(name, parent) {
  return [...parent.path, name];
}
function setUpControl(control, dir, callSetDisabledState = setDisabledStateDefault) {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (!control) _throwError(dir, "Cannot find control with");
    if (!dir.valueAccessor) _throwMissingValueAccessorError(dir);
  }
  setUpValidators(control, dir);
  dir.valueAccessor.writeValue(control.value);
  if (control.disabled || callSetDisabledState === "always") {
    dir.valueAccessor.setDisabledState?.(control.disabled);
  }
  setUpViewChangePipeline(control, dir);
  setUpModelChangePipeline(control, dir);
  setUpBlurPipeline(control, dir);
  setUpDisabledChangeHandler(control, dir);
}
function cleanUpControl(control, dir, validateControlPresenceOnChange = true) {
  const noop = () => {
    if (validateControlPresenceOnChange && (typeof ngDevMode === "undefined" || ngDevMode)) {
      _noControlError(dir);
    }
  };
  if (dir.valueAccessor) {
    dir.valueAccessor.registerOnChange(noop);
    dir.valueAccessor.registerOnTouched(noop);
  }
  cleanUpValidators(control, dir);
  if (control) {
    dir._invokeOnDestroyCallbacks();
    control._registerOnCollectionChange(() => {
    });
  }
}
function registerOnValidatorChange(validators, onChange) {
  validators.forEach((validator) => {
    if (validator.registerOnValidatorChange) validator.registerOnValidatorChange(onChange);
  });
}
function setUpDisabledChangeHandler(control, dir) {
  if (dir.valueAccessor.setDisabledState) {
    const onDisabledChange = (isDisabled) => {
      dir.valueAccessor.setDisabledState(isDisabled);
    };
    control.registerOnDisabledChange(onDisabledChange);
    dir._registerOnDestroy(() => {
      control._unregisterOnDisabledChange(onDisabledChange);
    });
  }
}
function setUpValidators(control, dir) {
  const validators = getControlValidators(control);
  if (dir.validator !== null) {
    control.setValidators(mergeValidators(validators, dir.validator));
  } else if (typeof validators === "function") {
    control.setValidators([validators]);
  }
  const asyncValidators = getControlAsyncValidators(control);
  if (dir.asyncValidator !== null) {
    control.setAsyncValidators(mergeValidators(asyncValidators, dir.asyncValidator));
  } else if (typeof asyncValidators === "function") {
    control.setAsyncValidators([asyncValidators]);
  }
  const onValidatorChange = () => control.updateValueAndValidity();
  registerOnValidatorChange(dir._rawValidators, onValidatorChange);
  registerOnValidatorChange(dir._rawAsyncValidators, onValidatorChange);
}
function cleanUpValidators(control, dir) {
  let isControlUpdated = false;
  if (control !== null) {
    if (dir.validator !== null) {
      const validators = getControlValidators(control);
      if (Array.isArray(validators) && validators.length > 0) {
        const updatedValidators = validators.filter((validator) => validator !== dir.validator);
        if (updatedValidators.length !== validators.length) {
          isControlUpdated = true;
          control.setValidators(updatedValidators);
        }
      }
    }
    if (dir.asyncValidator !== null) {
      const asyncValidators = getControlAsyncValidators(control);
      if (Array.isArray(asyncValidators) && asyncValidators.length > 0) {
        const updatedAsyncValidators = asyncValidators.filter((asyncValidator) => asyncValidator !== dir.asyncValidator);
        if (updatedAsyncValidators.length !== asyncValidators.length) {
          isControlUpdated = true;
          control.setAsyncValidators(updatedAsyncValidators);
        }
      }
    }
  }
  const noop = () => {
  };
  registerOnValidatorChange(dir._rawValidators, noop);
  registerOnValidatorChange(dir._rawAsyncValidators, noop);
  return isControlUpdated;
}
function setUpViewChangePipeline(control, dir) {
  dir.valueAccessor.registerOnChange((newValue) => {
    control._pendingValue = newValue;
    control._pendingChange = true;
    control._pendingDirty = true;
    if (control.updateOn === "change") updateControl(control, dir);
  });
}
function setUpBlurPipeline(control, dir) {
  dir.valueAccessor.registerOnTouched(() => {
    control._pendingTouched = true;
    if (control.updateOn === "blur" && control._pendingChange) updateControl(control, dir);
    if (control.updateOn !== "submit") control.markAsTouched();
  });
}
function updateControl(control, dir) {
  if (control._pendingDirty) control.markAsDirty();
  control.setValue(control._pendingValue, {
    emitModelToViewChange: false
  });
  dir.viewToModelUpdate(control._pendingValue);
  control._pendingChange = false;
}
function setUpModelChangePipeline(control, dir) {
  const onChange = (newValue, emitModelEvent) => {
    dir.valueAccessor.writeValue(newValue);
    if (emitModelEvent) dir.viewToModelUpdate(newValue);
  };
  control.registerOnChange(onChange);
  dir._registerOnDestroy(() => {
    control._unregisterOnChange(onChange);
  });
}
function setUpFormContainer(control, dir) {
  if (control == null && (typeof ngDevMode === "undefined" || ngDevMode)) _throwError(dir, "Cannot find control with");
  setUpValidators(control, dir);
}
function cleanUpFormContainer(control, dir) {
  return cleanUpValidators(control, dir);
}
function _noControlError(dir) {
  return _throwError(dir, "There is no FormControl instance attached to form control element with");
}
function _throwError(dir, message) {
  const messageEnd = _describeControlLocation(dir);
  throw new Error(`${message} ${messageEnd}`);
}
function _describeControlLocation(dir) {
  const path = dir.path;
  if (path && path.length > 1) return `path: '${path.join(" -> ")}'`;
  if (path?.[0]) return `name: '${path}'`;
  return "unspecified name attribute";
}
function _throwMissingValueAccessorError(dir) {
  const loc = _describeControlLocation(dir);
  throw new RuntimeError(-1203, `No value accessor for form control ${loc}.`);
}
function _throwInvalidValueAccessorError(dir) {
  const loc = _describeControlLocation(dir);
  throw new RuntimeError(1200, `Value accessor was not provided as an array for form control with ${loc}. Check that the \`NG_VALUE_ACCESSOR\` token is configured as a \`multi: true\` provider.`);
}
function isPropertyUpdated(changes, viewModel) {
  if (!changes.hasOwnProperty("model")) return false;
  const change = changes["model"];
  if (change.isFirstChange()) return true;
  return !Object.is(viewModel, change.currentValue);
}
function isBuiltInAccessor(valueAccessor) {
  return Object.getPrototypeOf(valueAccessor.constructor) === BuiltInControlValueAccessor;
}
function syncPendingControls(form, directives) {
  form._syncPendingControls();
  directives.forEach((dir) => {
    const control = dir.control;
    if (control.updateOn === "submit" && control._pendingChange) {
      dir.viewToModelUpdate(control._pendingValue);
      control._pendingChange = false;
    }
  });
}
function selectValueAccessor(dir, valueAccessors) {
  if (!valueAccessors) return null;
  if (!Array.isArray(valueAccessors) && (typeof ngDevMode === "undefined" || ngDevMode)) _throwInvalidValueAccessorError(dir);
  let defaultAccessor = void 0;
  let builtinAccessor = void 0;
  let customAccessor = void 0;
  valueAccessors.forEach((v) => {
    if (v.constructor === DefaultValueAccessor) {
      defaultAccessor = v;
    } else if (isBuiltInAccessor(v)) {
      if (builtinAccessor && (typeof ngDevMode === "undefined" || ngDevMode)) _throwError(dir, "More than one built-in value accessor matches form control with");
      builtinAccessor = v;
    } else {
      if (customAccessor && (typeof ngDevMode === "undefined" || ngDevMode)) _throwError(dir, "More than one custom value accessor matches form control with");
      customAccessor = v;
    }
  });
  if (customAccessor) return customAccessor;
  if (builtinAccessor) return builtinAccessor;
  if (defaultAccessor) return defaultAccessor;
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    _throwError(dir, "No valid value accessor for form control with");
  }
  return null;
}
function removeListItem$1(list, el) {
  const index = list.indexOf(el);
  if (index > -1) list.splice(index, 1);
}
function _ngModelWarning(name, type, instance, warningConfig) {
  if (warningConfig === "never") return;
  if ((warningConfig === null || warningConfig === "once") && !type._ngModelWarningSentOnce || warningConfig === "always" && !instance._ngModelWarningSent) {
    console.warn(ngModelWarning(name));
    type._ngModelWarningSentOnce = true;
    instance._ngModelWarningSent = true;
  }
}
var formDirectiveProvider$1 = {
  provide: ControlContainer,
  useExisting: forwardRef(() => NgForm)
};
var resolvedPromise$1 = (() => Promise.resolve())();
var NgForm = class _NgForm extends ControlContainer {
  callSetDisabledState;
  /**
   * @description
   * Returns whether the form submission has been triggered.
   */
  get submitted() {
    return untracked(this.submittedReactive);
  }
  /** @internal */
  _submitted = computed(() => this.submittedReactive());
  submittedReactive = signal(false);
  _directives = /* @__PURE__ */ new Set();
  /**
   * @description
   * The `FormGroup` instance created for this form.
   */
  form;
  /**
   * @description
   * Event emitter for the "ngSubmit" event
   */
  ngSubmit = new EventEmitter();
  /**
   * @description
   * Tracks options for the `NgForm` instance.
   *
   * **updateOn**: Sets the default `updateOn` value for all child `NgModels` below it
   * unless explicitly set by a child `NgModel` using `ngModelOptions`). Defaults to 'change'.
   * Possible values: `'change'` | `'blur'` | `'submit'`.
   *
   */
  options;
  constructor(validators, asyncValidators, callSetDisabledState) {
    super();
    this.callSetDisabledState = callSetDisabledState;
    this.form = new FormGroup({}, composeValidators(validators), composeAsyncValidators(asyncValidators));
  }
  /** @docs-private */
  ngAfterViewInit() {
    this._setUpdateStrategy();
  }
  /**
   * @description
   * The directive instance.
   */
  get formDirective() {
    return this;
  }
  /**
   * @description
   * The internal `FormGroup` instance.
   */
  get control() {
    return this.form;
  }
  /**
   * @description
   * Returns an array representing the path to this group. Because this directive
   * always lives at the top level of a form, it is always an empty array.
   */
  get path() {
    return [];
  }
  /**
   * @description
   * Returns a map of the controls in this group.
   */
  get controls() {
    return this.form.controls;
  }
  /**
   * @description
   * Method that sets up the control directive in this group, re-calculates its value
   * and validity, and adds the instance to the internal list of directives.
   *
   * @param dir The `NgModel` directive instance.
   */
  addControl(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      dir.control = container.registerControl(dir.name, dir.control);
      setUpControl(dir.control, dir, this.callSetDisabledState);
      dir.control.updateValueAndValidity({
        emitEvent: false
      });
      this._directives.add(dir);
    });
  }
  /**
   * @description
   * Retrieves the `FormControl` instance from the provided `NgModel` directive.
   *
   * @param dir The `NgModel` directive instance.
   */
  getControl(dir) {
    return this.form.get(dir.path);
  }
  /**
   * @description
   * Removes the `NgModel` instance from the internal list of directives
   *
   * @param dir The `NgModel` directive instance.
   */
  removeControl(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      if (container) {
        container.removeControl(dir.name);
      }
      this._directives.delete(dir);
    });
  }
  /**
   * @description
   * Adds a new `NgModelGroup` directive instance to the form.
   *
   * @param dir The `NgModelGroup` directive instance.
   */
  addFormGroup(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      const group = new FormGroup({});
      setUpFormContainer(group, dir);
      container.registerControl(dir.name, group);
      group.updateValueAndValidity({
        emitEvent: false
      });
    });
  }
  /**
   * @description
   * Removes the `NgModelGroup` directive instance from the form.
   *
   * @param dir The `NgModelGroup` directive instance.
   */
  removeFormGroup(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      if (container) {
        container.removeControl(dir.name);
      }
    });
  }
  /**
   * @description
   * Retrieves the `FormGroup` for a provided `NgModelGroup` directive instance
   *
   * @param dir The `NgModelGroup` directive instance.
   */
  getFormGroup(dir) {
    return this.form.get(dir.path);
  }
  /**
   * Sets the new value for the provided `NgControl` directive.
   *
   * @param dir The `NgControl` directive instance.
   * @param value The new value for the directive's control.
   */
  updateModel(dir, value) {
    resolvedPromise$1.then(() => {
      const ctrl = this.form.get(dir.path);
      ctrl.setValue(value);
    });
  }
  /**
   * @description
   * Sets the value for this `FormGroup`.
   *
   * @param value The new value
   */
  setValue(value) {
    this.control.setValue(value);
  }
  /**
   * @description
   * Method called when the "submit" event is triggered on the form.
   * Triggers the `ngSubmit` emitter to emit the "submit" event as its payload.
   *
   * @param $event The "submit" event object
   */
  onSubmit($event) {
    this.submittedReactive.set(true);
    syncPendingControls(this.form, this._directives);
    this.ngSubmit.emit($event);
    this.form._events.next(new FormSubmittedEvent(this.control));
    return $event?.target?.method === "dialog";
  }
  /**
   * @description
   * Method called when the "reset" event is triggered on the form.
   */
  onReset() {
    this.resetForm();
  }
  /**
   * @description
   * Resets the form to an initial value and resets its submitted status.
   *
   * @param value The new value for the form.
   */
  resetForm(value = void 0) {
    this.form.reset(value);
    this.submittedReactive.set(false);
    this.form._events.next(new FormResetEvent(this.form));
  }
  _setUpdateStrategy() {
    if (this.options && this.options.updateOn != null) {
      this.form._updateOn = this.options.updateOn;
    }
  }
  _findContainer(path) {
    path.pop();
    return path.length ? this.form.get(path) : this.form;
  }
  static ɵfac = function NgForm_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgForm)(ɵɵdirectiveInject(NG_VALIDATORS, 10), ɵɵdirectiveInject(NG_ASYNC_VALIDATORS, 10), ɵɵdirectiveInject(CALL_SET_DISABLED_STATE, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _NgForm,
    selectors: [["form", 3, "ngNoForm", "", 3, "formGroup", ""], ["ng-form"], ["", "ngForm", ""]],
    hostBindings: function NgForm_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("submit", function NgForm_submit_HostBindingHandler($event) {
          return ctx.onSubmit($event);
        })("reset", function NgForm_reset_HostBindingHandler() {
          return ctx.onReset();
        });
      }
    },
    inputs: {
      options: [0, "ngFormOptions", "options"]
    },
    outputs: {
      ngSubmit: "ngSubmit"
    },
    exportAs: ["ngForm"],
    standalone: false,
    features: [ɵɵProvidersFeature([formDirectiveProvider$1]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgForm, [{
    type: Directive,
    args: [{
      selector: "form:not([ngNoForm]):not([formGroup]),ng-form,[ngForm]",
      providers: [formDirectiveProvider$1],
      host: {
        "(submit)": "onSubmit($event)",
        "(reset)": "onReset()"
      },
      outputs: ["ngSubmit"],
      exportAs: "ngForm",
      standalone: false
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], {
    options: [{
      type: Input,
      args: ["ngFormOptions"]
    }]
  });
})();
function removeListItem(list, el) {
  const index = list.indexOf(el);
  if (index > -1) list.splice(index, 1);
}
function isFormControlState(formState) {
  return typeof formState === "object" && formState !== null && Object.keys(formState).length === 2 && "value" in formState && "disabled" in formState;
}
var FormControl = class FormControl2 extends AbstractControl {
  /** @publicApi */
  defaultValue = null;
  /** @internal */
  _onChange = [];
  /** @internal */
  _pendingValue;
  /** @internal */
  _pendingChange = false;
  constructor(formState = null, validatorOrOpts, asyncValidator) {
    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
    this._applyFormState(formState);
    this._setUpdateStrategy(validatorOrOpts);
    this._initObservables();
    this.updateValueAndValidity({
      onlySelf: true,
      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
      // `VALID` or `INVALID`.
      // The status should be broadcasted via the `statusChanges` observable, so we set
      // `emitEvent` to `true` to allow that during the control creation process.
      emitEvent: !!this.asyncValidator
    });
    if (isOptionsObj(validatorOrOpts) && (validatorOrOpts.nonNullable || validatorOrOpts.initialValueIsDefault)) {
      if (isFormControlState(formState)) {
        this.defaultValue = formState.value;
      } else {
        this.defaultValue = formState;
      }
    }
  }
  setValue(value, options = {}) {
    this.value = this._pendingValue = value;
    if (this._onChange.length && options.emitModelToViewChange !== false) {
      this._onChange.forEach((changeFn) => changeFn(this.value, options.emitViewToModelChange !== false));
    }
    this.updateValueAndValidity(options);
  }
  patchValue(value, options = {}) {
    this.setValue(value, options);
  }
  reset(formState = this.defaultValue, options = {}) {
    this._applyFormState(formState);
    this.markAsPristine(options);
    this.markAsUntouched(options);
    this.setValue(this.value, options);
    this._pendingChange = false;
  }
  /**  @internal */
  _updateValue() {
  }
  /**  @internal */
  _anyControls(condition) {
    return false;
  }
  /**  @internal */
  _allControlsDisabled() {
    return this.disabled;
  }
  registerOnChange(fn) {
    this._onChange.push(fn);
  }
  /** @internal */
  _unregisterOnChange(fn) {
    removeListItem(this._onChange, fn);
  }
  registerOnDisabledChange(fn) {
    this._onDisabledChange.push(fn);
  }
  /** @internal */
  _unregisterOnDisabledChange(fn) {
    removeListItem(this._onDisabledChange, fn);
  }
  /** @internal */
  _forEachChild(cb) {
  }
  /** @internal */
  _syncPendingControls() {
    if (this.updateOn === "submit") {
      if (this._pendingDirty) this.markAsDirty();
      if (this._pendingTouched) this.markAsTouched();
      if (this._pendingChange) {
        this.setValue(this._pendingValue, {
          onlySelf: true,
          emitModelToViewChange: false
        });
        return true;
      }
    }
    return false;
  }
  _applyFormState(formState) {
    if (isFormControlState(formState)) {
      this.value = this._pendingValue = formState.value;
      formState.disabled ? this.disable({
        onlySelf: true,
        emitEvent: false
      }) : this.enable({
        onlySelf: true,
        emitEvent: false
      });
    } else {
      this.value = this._pendingValue = formState;
    }
  }
};
var isFormControl = (control) => control instanceof FormControl;
var AbstractFormGroupDirective = class _AbstractFormGroupDirective extends ControlContainer {
  /**
   * @description
   * The parent control for the group
   *
   * @internal
   */
  _parent;
  /** @docs-private */
  ngOnInit() {
    this._checkParentType();
    this.formDirective.addFormGroup(this);
  }
  /** @docs-private */
  ngOnDestroy() {
    if (this.formDirective) {
      this.formDirective.removeFormGroup(this);
    }
  }
  /**
   * @description
   * The `FormGroup` bound to this directive.
   */
  get control() {
    return this.formDirective.getFormGroup(this);
  }
  /**
   * @description
   * The path to this group from the top-level directive.
   */
  get path() {
    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
  }
  /**
   * @description
   * The top-level directive for this group if present, otherwise null.
   */
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  /** @internal */
  _checkParentType() {
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵAbstractFormGroupDirective_BaseFactory;
    return function AbstractFormGroupDirective_Factory(__ngFactoryType__) {
      return (ɵAbstractFormGroupDirective_BaseFactory || (ɵAbstractFormGroupDirective_BaseFactory = ɵɵgetInheritedFactory(_AbstractFormGroupDirective)))(__ngFactoryType__ || _AbstractFormGroupDirective);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _AbstractFormGroupDirective,
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AbstractFormGroupDirective, [{
    type: Directive,
    args: [{
      standalone: false
    }]
  }], null, null);
})();
function modelParentException() {
  return new RuntimeError(1350, `
    ngModel cannot be used to register form controls with a parent formGroup directive.  Try using
    formGroup's partner directive "formControlName" instead.  Example:

    ${formControlNameExample}

    Or, if you'd like to avoid registering this form control, indicate that it's standalone in ngModelOptions:

    Example:

    ${ngModelWithFormGroupExample}`);
}
function formGroupNameException() {
  return new RuntimeError(1351, `
    ngModel cannot be used to register form controls with a parent formGroupName or formArrayName directive.

    Option 1: Use formControlName instead of ngModel (reactive strategy):

    ${formGroupNameExample}

    Option 2:  Update ngModel's parent be ngModelGroup (template-driven strategy):

    ${ngModelGroupExample}`);
}
function missingNameException() {
  return new RuntimeError(1352, `If ngModel is used within a form tag, either the name attribute must be set or the form
    control must be defined as 'standalone' in ngModelOptions.

    Example 1: <input [(ngModel)]="person.firstName" name="first">
    Example 2: <input [(ngModel)]="person.firstName" [ngModelOptions]="{standalone: true}">`);
}
function modelGroupParentException() {
  return new RuntimeError(1353, `
    ngModelGroup cannot be used with a parent formGroup directive.

    Option 1: Use formGroupName instead of ngModelGroup (reactive strategy):

    ${formGroupNameExample}

    Option 2:  Use a regular form tag instead of the formGroup directive (template-driven strategy):

    ${ngModelGroupExample}`);
}
var modelGroupProvider = {
  provide: ControlContainer,
  useExisting: forwardRef(() => NgModelGroup)
};
var NgModelGroup = class _NgModelGroup extends AbstractFormGroupDirective {
  /**
   * @description
   * Tracks the name of the `NgModelGroup` bound to the directive. The name corresponds
   * to a key in the parent `NgForm`.
   */
  name = "";
  constructor(parent, validators, asyncValidators) {
    super();
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  /** @internal */
  _checkParentType() {
    if (!(this._parent instanceof _NgModelGroup) && !(this._parent instanceof NgForm) && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw modelGroupParentException();
    }
  }
  static ɵfac = function NgModelGroup_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgModelGroup)(ɵɵdirectiveInject(ControlContainer, 5), ɵɵdirectiveInject(NG_VALIDATORS, 10), ɵɵdirectiveInject(NG_ASYNC_VALIDATORS, 10));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _NgModelGroup,
    selectors: [["", "ngModelGroup", ""]],
    inputs: {
      name: [0, "ngModelGroup", "name"]
    },
    exportAs: ["ngModelGroup"],
    standalone: false,
    features: [ɵɵProvidersFeature([modelGroupProvider]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgModelGroup, [{
    type: Directive,
    args: [{
      selector: "[ngModelGroup]",
      providers: [modelGroupProvider],
      exportAs: "ngModelGroup",
      standalone: false
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Host
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }], {
    name: [{
      type: Input,
      args: ["ngModelGroup"]
    }]
  });
})();
var formControlBinding$1 = {
  provide: NgControl,
  useExisting: forwardRef(() => NgModel)
};
var resolvedPromise = (() => Promise.resolve())();
var NgModel = class _NgModel extends NgControl {
  _changeDetectorRef;
  callSetDisabledState;
  control = new FormControl();
  // At runtime we coerce arbitrary values assigned to the "disabled" input to a "boolean".
  // This is not reflected in the type of the property because outside of templates, consumers
  // should only deal with booleans. In templates, a string is allowed for convenience and to
  // match the native "disabled attribute" semantics which can be observed on input elements.
  // This static member tells the compiler that values of type "string" can also be assigned
  // to the input in a template.
  /** @docs-private */
  static ngAcceptInputType_isDisabled;
  /** @internal */
  _registered = false;
  /**
   * Internal reference to the view model value.
   * @docs-private
   */
  viewModel;
  /**
   * @description
   * Tracks the name bound to the directive. If a parent form exists, it
   * uses this name as a key to retrieve this control's value.
   */
  name = "";
  /**
   * @description
   * Tracks whether the control is disabled.
   */
  isDisabled;
  /**
   * @description
   * Tracks the value bound to this directive.
   */
  model;
  /**
   * @description
   * Tracks the configuration options for this `ngModel` instance.
   *
   * **name**: An alternative to setting the name attribute on the form control element. See
   * the [example](api/forms/NgModel#using-ngmodel-on-a-standalone-control) for using `NgModel`
   * as a standalone control.
   *
   * **standalone**: When set to true, the `ngModel` will not register itself with its parent form,
   * and acts as if it's not in the form. Defaults to false. If no parent form exists, this option
   * has no effect.
   *
   * **updateOn**: Defines the event upon which the form control value and validity update.
   * Defaults to 'change'. Possible values: `'change'` | `'blur'` | `'submit'`.
   *
   */
  options;
  /**
   * @description
   * Event emitter for producing the `ngModelChange` event after
   * the view model updates.
   */
  update = new EventEmitter();
  constructor(parent, validators, asyncValidators, valueAccessors, _changeDetectorRef, callSetDisabledState) {
    super();
    this._changeDetectorRef = _changeDetectorRef;
    this.callSetDisabledState = callSetDisabledState;
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
    this.valueAccessor = selectValueAccessor(this, valueAccessors);
  }
  /** @docs-private */
  ngOnChanges(changes) {
    this._checkForErrors();
    if (!this._registered || "name" in changes) {
      if (this._registered) {
        this._checkName();
        if (this.formDirective) {
          const oldName = changes["name"].previousValue;
          this.formDirective.removeControl({
            name: oldName,
            path: this._getPath(oldName)
          });
        }
      }
      this._setUpControl();
    }
    if ("isDisabled" in changes) {
      this._updateDisabled(changes);
    }
    if (isPropertyUpdated(changes, this.viewModel)) {
      this._updateValue(this.model);
      this.viewModel = this.model;
    }
  }
  /** @docs-private */
  ngOnDestroy() {
    this.formDirective && this.formDirective.removeControl(this);
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return this._getPath(this.name);
  }
  /**
   * @description
   * The top-level directive for this control if present, otherwise null.
   */
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  /**
   * @description
   * Sets the new value for the view model and emits an `ngModelChange` event.
   *
   * @param newValue The new value emitted by `ngModelChange`.
   */
  viewToModelUpdate(newValue) {
    this.viewModel = newValue;
    this.update.emit(newValue);
  }
  _setUpControl() {
    this._setUpdateStrategy();
    this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this);
    this._registered = true;
  }
  _setUpdateStrategy() {
    if (this.options && this.options.updateOn != null) {
      this.control._updateOn = this.options.updateOn;
    }
  }
  _isStandalone() {
    return !this._parent || !!(this.options && this.options.standalone);
  }
  _setUpStandalone() {
    setUpControl(this.control, this, this.callSetDisabledState);
    this.control.updateValueAndValidity({
      emitEvent: false
    });
  }
  _checkForErrors() {
    if ((typeof ngDevMode === "undefined" || ngDevMode) && !this._isStandalone()) {
      checkParentType$1(this._parent);
    }
    this._checkName();
  }
  _checkName() {
    if (this.options && this.options.name) this.name = this.options.name;
    if (!this._isStandalone() && !this.name && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw missingNameException();
    }
  }
  _updateValue(value) {
    resolvedPromise.then(() => {
      this.control.setValue(value, {
        emitViewToModelChange: false
      });
      this._changeDetectorRef?.markForCheck();
    });
  }
  _updateDisabled(changes) {
    const disabledValue = changes["isDisabled"].currentValue;
    const isDisabled = disabledValue !== 0 && booleanAttribute(disabledValue);
    resolvedPromise.then(() => {
      if (isDisabled && !this.control.disabled) {
        this.control.disable();
      } else if (!isDisabled && this.control.disabled) {
        this.control.enable();
      }
      this._changeDetectorRef?.markForCheck();
    });
  }
  _getPath(controlName) {
    return this._parent ? controlPath(controlName, this._parent) : [controlName];
  }
  static ɵfac = function NgModel_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgModel)(ɵɵdirectiveInject(ControlContainer, 9), ɵɵdirectiveInject(NG_VALIDATORS, 10), ɵɵdirectiveInject(NG_ASYNC_VALIDATORS, 10), ɵɵdirectiveInject(NG_VALUE_ACCESSOR, 10), ɵɵdirectiveInject(ChangeDetectorRef, 8), ɵɵdirectiveInject(CALL_SET_DISABLED_STATE, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _NgModel,
    selectors: [["", "ngModel", "", 3, "formControlName", "", 3, "formControl", ""]],
    inputs: {
      name: "name",
      isDisabled: [0, "disabled", "isDisabled"],
      model: [0, "ngModel", "model"],
      options: [0, "ngModelOptions", "options"]
    },
    outputs: {
      update: "ngModelChange"
    },
    exportAs: ["ngModel"],
    standalone: false,
    features: [ɵɵProvidersFeature([formControlBinding$1]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgModel, [{
    type: Directive,
    args: [{
      selector: "[ngModel]:not([formControlName]):not([formControl])",
      providers: [formControlBinding$1],
      exportAs: "ngModel",
      standalone: false
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALUE_ACCESSOR]
    }]
  }, {
    type: ChangeDetectorRef,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [ChangeDetectorRef]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], {
    name: [{
      type: Input
    }],
    isDisabled: [{
      type: Input,
      args: ["disabled"]
    }],
    model: [{
      type: Input,
      args: ["ngModel"]
    }],
    options: [{
      type: Input,
      args: ["ngModelOptions"]
    }],
    update: [{
      type: Output,
      args: ["ngModelChange"]
    }]
  });
})();
function checkParentType$1(parent) {
  if (!(parent instanceof NgModelGroup) && parent instanceof AbstractFormGroupDirective) {
    throw formGroupNameException();
  } else if (!(parent instanceof NgModelGroup) && !(parent instanceof NgForm)) {
    throw modelParentException();
  }
}
var ɵNgNoValidate = class _ɵNgNoValidate {
  static ɵfac = function ɵNgNoValidate_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ɵNgNoValidate)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ɵNgNoValidate,
    selectors: [["form", 3, "ngNoForm", "", 3, "ngNativeValidate", ""]],
    hostAttrs: ["novalidate", ""],
    standalone: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ɵNgNoValidate, [{
    type: Directive,
    args: [{
      selector: "form:not([ngNoForm]):not([ngNativeValidate])",
      host: {
        "novalidate": ""
      },
      standalone: false
    }]
  }], null, null);
})();
var NUMBER_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => NumberValueAccessor),
  multi: true
};
var NumberValueAccessor = class _NumberValueAccessor extends BuiltInControlValueAccessor {
  /**
   * Sets the "value" property on the input element.
   * @docs-private
   */
  writeValue(value) {
    const normalizedValue = value == null ? "" : value;
    this.setProperty("value", normalizedValue);
  }
  /**
   * Registers a function called when the control value changes.
   * @docs-private
   */
  registerOnChange(fn) {
    this.onChange = (value) => {
      fn(value == "" ? null : parseFloat(value));
    };
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵNumberValueAccessor_BaseFactory;
    return function NumberValueAccessor_Factory(__ngFactoryType__) {
      return (ɵNumberValueAccessor_BaseFactory || (ɵNumberValueAccessor_BaseFactory = ɵɵgetInheritedFactory(_NumberValueAccessor)))(__ngFactoryType__ || _NumberValueAccessor);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _NumberValueAccessor,
    selectors: [["input", "type", "number", "formControlName", ""], ["input", "type", "number", "formControl", ""], ["input", "type", "number", "ngModel", ""]],
    hostBindings: function NumberValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("input", function NumberValueAccessor_input_HostBindingHandler($event) {
          return ctx.onChange($event.target.value);
        })("blur", function NumberValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    standalone: false,
    features: [ɵɵProvidersFeature([NUMBER_VALUE_ACCESSOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumberValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]",
      host: {
        "(input)": "onChange($event.target.value)",
        "(blur)": "onTouched()"
      },
      providers: [NUMBER_VALUE_ACCESSOR],
      standalone: false
    }]
  }], null, null);
})();
var RADIO_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => RadioControlValueAccessor),
  multi: true
};
function throwNameError() {
  throw new RuntimeError(1202, `
      If you define both a name and a formControlName attribute on your radio button, their values
      must match. Ex: <input type="radio" formControlName="food" name="food">
    `);
}
var RadioControlRegistry = class _RadioControlRegistry {
  _accessors = [];
  /**
   * @description
   * Adds a control to the internal registry. For internal use only.
   */
  add(control, accessor) {
    this._accessors.push([control, accessor]);
  }
  /**
   * @description
   * Removes a control from the internal registry. For internal use only.
   */
  remove(accessor) {
    for (let i = this._accessors.length - 1; i >= 0; --i) {
      if (this._accessors[i][1] === accessor) {
        this._accessors.splice(i, 1);
        return;
      }
    }
  }
  /**
   * @description
   * Selects a radio button. For internal use only.
   */
  select(accessor) {
    this._accessors.forEach((c) => {
      if (this._isSameGroup(c, accessor) && c[1] !== accessor) {
        c[1].fireUncheck(accessor.value);
      }
    });
  }
  _isSameGroup(controlPair, accessor) {
    if (!controlPair[0].control) return false;
    return controlPair[0]._parent === accessor._control._parent && controlPair[1].name === accessor.name;
  }
  static ɵfac = function RadioControlRegistry_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RadioControlRegistry)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _RadioControlRegistry,
    factory: _RadioControlRegistry.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RadioControlRegistry, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var RadioControlValueAccessor = class _RadioControlValueAccessor extends BuiltInControlValueAccessor {
  _registry;
  _injector;
  /** @internal */
  _state;
  /** @internal */
  _control;
  /** @internal */
  _fn;
  setDisabledStateFired = false;
  /**
   * The registered callback function called when a change event occurs on the input element.
   * Note: we declare `onChange` here (also used as host listener) as a function with no arguments
   * to override the `onChange` function (which expects 1 argument) in the parent
   * `BaseControlValueAccessor` class.
   * @docs-private
   */
  onChange = () => {
  };
  /**
   * @description
   * Tracks the name of the radio input element.
   */
  name;
  /**
   * @description
   * Tracks the name of the `FormControl` bound to the directive. The name corresponds
   * to a key in the parent `FormGroup` or `FormArray`.
   */
  formControlName;
  /**
   * @description
   * Tracks the value of the radio input element
   */
  value;
  callSetDisabledState = inject(CALL_SET_DISABLED_STATE, {
    optional: true
  }) ?? setDisabledStateDefault;
  constructor(renderer, elementRef, _registry, _injector) {
    super(renderer, elementRef);
    this._registry = _registry;
    this._injector = _injector;
  }
  /** @docs-private */
  ngOnInit() {
    this._control = this._injector.get(NgControl);
    this._checkName();
    this._registry.add(this._control, this);
  }
  /** @docs-private */
  ngOnDestroy() {
    this._registry.remove(this);
  }
  /**
   * Sets the "checked" property value on the radio input element.
   * @docs-private
   */
  writeValue(value) {
    this._state = value === this.value;
    this.setProperty("checked", this._state);
  }
  /**
   * Registers a function called when the control value changes.
   * @docs-private
   */
  registerOnChange(fn) {
    this._fn = fn;
    this.onChange = () => {
      fn(this.value);
      this._registry.select(this);
    };
  }
  /** @docs-private */
  setDisabledState(isDisabled) {
    if (this.setDisabledStateFired || isDisabled || this.callSetDisabledState === "whenDisabledForLegacyCode") {
      this.setProperty("disabled", isDisabled);
    }
    this.setDisabledStateFired = true;
  }
  /**
   * Sets the "value" on the radio input element and unchecks it.
   *
   * @param value
   */
  fireUncheck(value) {
    this.writeValue(value);
  }
  _checkName() {
    if (this.name && this.formControlName && this.name !== this.formControlName && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throwNameError();
    }
    if (!this.name && this.formControlName) this.name = this.formControlName;
  }
  static ɵfac = function RadioControlValueAccessor_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RadioControlValueAccessor)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(RadioControlRegistry), ɵɵdirectiveInject(Injector));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _RadioControlValueAccessor,
    selectors: [["input", "type", "radio", "formControlName", ""], ["input", "type", "radio", "formControl", ""], ["input", "type", "radio", "ngModel", ""]],
    hostBindings: function RadioControlValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("change", function RadioControlValueAccessor_change_HostBindingHandler() {
          return ctx.onChange();
        })("blur", function RadioControlValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    inputs: {
      name: "name",
      formControlName: "formControlName",
      value: "value"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([RADIO_VALUE_ACCESSOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RadioControlValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input[type=radio][formControlName],input[type=radio][formControl],input[type=radio][ngModel]",
      host: {
        "(change)": "onChange()",
        "(blur)": "onTouched()"
      },
      providers: [RADIO_VALUE_ACCESSOR],
      standalone: false
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: RadioControlRegistry
  }, {
    type: Injector
  }], {
    name: [{
      type: Input
    }],
    formControlName: [{
      type: Input
    }],
    value: [{
      type: Input
    }]
  });
})();
var RANGE_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => RangeValueAccessor),
  multi: true
};
var RangeValueAccessor = class _RangeValueAccessor extends BuiltInControlValueAccessor {
  /**
   * Sets the "value" property on the input element.
   * @docs-private
   */
  writeValue(value) {
    this.setProperty("value", parseFloat(value));
  }
  /**
   * Registers a function called when the control value changes.
   * @docs-private
   */
  registerOnChange(fn) {
    this.onChange = (value) => {
      fn(value == "" ? null : parseFloat(value));
    };
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵRangeValueAccessor_BaseFactory;
    return function RangeValueAccessor_Factory(__ngFactoryType__) {
      return (ɵRangeValueAccessor_BaseFactory || (ɵRangeValueAccessor_BaseFactory = ɵɵgetInheritedFactory(_RangeValueAccessor)))(__ngFactoryType__ || _RangeValueAccessor);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _RangeValueAccessor,
    selectors: [["input", "type", "range", "formControlName", ""], ["input", "type", "range", "formControl", ""], ["input", "type", "range", "ngModel", ""]],
    hostBindings: function RangeValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("change", function RangeValueAccessor_change_HostBindingHandler($event) {
          return ctx.onChange($event.target.value);
        })("input", function RangeValueAccessor_input_HostBindingHandler($event) {
          return ctx.onChange($event.target.value);
        })("blur", function RangeValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    standalone: false,
    features: [ɵɵProvidersFeature([RANGE_VALUE_ACCESSOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RangeValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input[type=range][formControlName],input[type=range][formControl],input[type=range][ngModel]",
      host: {
        "(change)": "onChange($event.target.value)",
        "(input)": "onChange($event.target.value)",
        "(blur)": "onTouched()"
      },
      providers: [RANGE_VALUE_ACCESSOR],
      standalone: false
    }]
  }], null, null);
})();
var NG_MODEL_WITH_FORM_CONTROL_WARNING = new InjectionToken(ngDevMode ? "NgModelWithFormControlWarning" : "");
var formControlBinding = {
  provide: NgControl,
  useExisting: forwardRef(() => FormControlDirective)
};
var FormControlDirective = class _FormControlDirective extends NgControl {
  _ngModelWarningConfig;
  callSetDisabledState;
  /**
   * Internal reference to the view model value.
   * @docs-private
   */
  viewModel;
  /**
   * @description
   * Tracks the `FormControl` instance bound to the directive.
   */
  form;
  /**
   * @description
   * Triggers a warning in dev mode that this input should not be used with reactive forms.
   */
  set isDisabled(isDisabled) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      console.warn(disabledAttrWarning);
    }
  }
  // TODO(kara): remove next 4 properties once deprecation period is over
  /** @deprecated as of v6 */
  model;
  /** @deprecated as of v6 */
  update = new EventEmitter();
  /**
   * @description
   * Static property used to track whether any ngModel warnings have been sent across
   * all instances of FormControlDirective. Used to support warning config of "once".
   *
   * @internal
   */
  static _ngModelWarningSentOnce = false;
  /**
   * @description
   * Instance property used to track whether an ngModel warning has been sent out for this
   * particular `FormControlDirective` instance. Used to support warning config of "always".
   *
   * @internal
   */
  _ngModelWarningSent = false;
  constructor(validators, asyncValidators, valueAccessors, _ngModelWarningConfig, callSetDisabledState) {
    super();
    this._ngModelWarningConfig = _ngModelWarningConfig;
    this.callSetDisabledState = callSetDisabledState;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
    this.valueAccessor = selectValueAccessor(this, valueAccessors);
  }
  /** @docs-private */
  ngOnChanges(changes) {
    if (this._isControlChanged(changes)) {
      const previousForm = changes["form"].previousValue;
      if (previousForm) {
        cleanUpControl(
          previousForm,
          this,
          /* validateControlPresenceOnChange */
          false
        );
      }
      setUpControl(this.form, this, this.callSetDisabledState);
      this.form.updateValueAndValidity({
        emitEvent: false
      });
    }
    if (isPropertyUpdated(changes, this.viewModel)) {
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        _ngModelWarning("formControl", _FormControlDirective, this, this._ngModelWarningConfig);
      }
      this.form.setValue(this.model);
      this.viewModel = this.model;
    }
  }
  /** @docs-private */
  ngOnDestroy() {
    if (this.form) {
      cleanUpControl(
        this.form,
        this,
        /* validateControlPresenceOnChange */
        false
      );
    }
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return [];
  }
  /**
   * @description
   * The `FormControl` bound to this directive.
   */
  get control() {
    return this.form;
  }
  /**
   * @description
   * Sets the new value for the view model and emits an `ngModelChange` event.
   *
   * @param newValue The new value for the view model.
   */
  viewToModelUpdate(newValue) {
    this.viewModel = newValue;
    this.update.emit(newValue);
  }
  _isControlChanged(changes) {
    return changes.hasOwnProperty("form");
  }
  static ɵfac = function FormControlDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormControlDirective)(ɵɵdirectiveInject(NG_VALIDATORS, 10), ɵɵdirectiveInject(NG_ASYNC_VALIDATORS, 10), ɵɵdirectiveInject(NG_VALUE_ACCESSOR, 10), ɵɵdirectiveInject(NG_MODEL_WITH_FORM_CONTROL_WARNING, 8), ɵɵdirectiveInject(CALL_SET_DISABLED_STATE, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FormControlDirective,
    selectors: [["", "formControl", ""]],
    inputs: {
      form: [0, "formControl", "form"],
      isDisabled: [0, "disabled", "isDisabled"],
      model: [0, "ngModel", "model"]
    },
    outputs: {
      update: "ngModelChange"
    },
    exportAs: ["ngForm"],
    standalone: false,
    features: [ɵɵProvidersFeature([formControlBinding]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormControlDirective, [{
    type: Directive,
    args: [{
      selector: "[formControl]",
      providers: [formControlBinding],
      exportAs: "ngForm",
      standalone: false
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALUE_ACCESSOR]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [NG_MODEL_WITH_FORM_CONTROL_WARNING]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], {
    form: [{
      type: Input,
      args: ["formControl"]
    }],
    isDisabled: [{
      type: Input,
      args: ["disabled"]
    }],
    model: [{
      type: Input,
      args: ["ngModel"]
    }],
    update: [{
      type: Output,
      args: ["ngModelChange"]
    }]
  });
})();
var formDirectiveProvider = {
  provide: ControlContainer,
  useExisting: forwardRef(() => FormGroupDirective)
};
var FormGroupDirective = class _FormGroupDirective extends ControlContainer {
  callSetDisabledState;
  /**
   * @description
   * Reports whether the form submission has been triggered.
   */
  get submitted() {
    return untracked(this._submittedReactive);
  }
  // TODO(atscott): Remove once invalid API usage is cleaned up internally
  set submitted(value) {
    this._submittedReactive.set(value);
  }
  /** @internal */
  _submitted = computed(() => this._submittedReactive());
  _submittedReactive = signal(false);
  /**
   * Reference to an old form group input value, which is needed to cleanup
   * old instance in case it was replaced with a new one.
   */
  _oldForm;
  /**
   * Callback that should be invoked when controls in FormGroup or FormArray collection change
   * (added or removed). This callback triggers corresponding DOM updates.
   */
  _onCollectionChange = () => this._updateDomValue();
  /**
   * @description
   * Tracks the list of added `FormControlName` instances
   */
  directives = [];
  /**
   * @description
   * Tracks the `FormGroup` bound to this directive.
   */
  form = null;
  /**
   * @description
   * Emits an event when the form submission has been triggered.
   */
  ngSubmit = new EventEmitter();
  constructor(validators, asyncValidators, callSetDisabledState) {
    super();
    this.callSetDisabledState = callSetDisabledState;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  /** @docs-private */
  ngOnChanges(changes) {
    if ((typeof ngDevMode === "undefined" || ngDevMode) && !this.form) {
      throw missingFormException();
    }
    if (changes.hasOwnProperty("form")) {
      this._updateValidators();
      this._updateDomValue();
      this._updateRegistrations();
      this._oldForm = this.form;
    }
  }
  /** @docs-private */
  ngOnDestroy() {
    if (this.form) {
      cleanUpValidators(this.form, this);
      if (this.form._onCollectionChange === this._onCollectionChange) {
        this.form._registerOnCollectionChange(() => {
        });
      }
    }
  }
  /**
   * @description
   * Returns this directive's instance.
   */
  get formDirective() {
    return this;
  }
  /**
   * @description
   * Returns the `FormGroup` bound to this directive.
   */
  get control() {
    return this.form;
  }
  /**
   * @description
   * Returns an array representing the path to this group. Because this directive
   * always lives at the top level of a form, it always an empty array.
   */
  get path() {
    return [];
  }
  /**
   * @description
   * Method that sets up the control directive in this group, re-calculates its value
   * and validity, and adds the instance to the internal list of directives.
   *
   * @param dir The `FormControlName` directive instance.
   */
  addControl(dir) {
    const ctrl = this.form.get(dir.path);
    setUpControl(ctrl, dir, this.callSetDisabledState);
    ctrl.updateValueAndValidity({
      emitEvent: false
    });
    this.directives.push(dir);
    return ctrl;
  }
  /**
   * @description
   * Retrieves the `FormControl` instance from the provided `FormControlName` directive
   *
   * @param dir The `FormControlName` directive instance.
   */
  getControl(dir) {
    return this.form.get(dir.path);
  }
  /**
   * @description
   * Removes the `FormControlName` instance from the internal list of directives
   *
   * @param dir The `FormControlName` directive instance.
   */
  removeControl(dir) {
    cleanUpControl(
      dir.control || null,
      dir,
      /* validateControlPresenceOnChange */
      false
    );
    removeListItem$1(this.directives, dir);
  }
  /**
   * Adds a new `FormGroupName` directive instance to the form.
   *
   * @param dir The `FormGroupName` directive instance.
   */
  addFormGroup(dir) {
    this._setUpFormContainer(dir);
  }
  /**
   * Performs the necessary cleanup when a `FormGroupName` directive instance is removed from the
   * view.
   *
   * @param dir The `FormGroupName` directive instance.
   */
  removeFormGroup(dir) {
    this._cleanUpFormContainer(dir);
  }
  /**
   * @description
   * Retrieves the `FormGroup` for a provided `FormGroupName` directive instance
   *
   * @param dir The `FormGroupName` directive instance.
   */
  getFormGroup(dir) {
    return this.form.get(dir.path);
  }
  /**
   * Performs the necessary setup when a `FormArrayName` directive instance is added to the view.
   *
   * @param dir The `FormArrayName` directive instance.
   */
  addFormArray(dir) {
    this._setUpFormContainer(dir);
  }
  /**
   * Performs the necessary cleanup when a `FormArrayName` directive instance is removed from the
   * view.
   *
   * @param dir The `FormArrayName` directive instance.
   */
  removeFormArray(dir) {
    this._cleanUpFormContainer(dir);
  }
  /**
   * @description
   * Retrieves the `FormArray` for a provided `FormArrayName` directive instance.
   *
   * @param dir The `FormArrayName` directive instance.
   */
  getFormArray(dir) {
    return this.form.get(dir.path);
  }
  /**
   * Sets the new value for the provided `FormControlName` directive.
   *
   * @param dir The `FormControlName` directive instance.
   * @param value The new value for the directive's control.
   */
  updateModel(dir, value) {
    const ctrl = this.form.get(dir.path);
    ctrl.setValue(value);
  }
  /**
   * @description
   * Method called with the "submit" event is triggered on the form.
   * Triggers the `ngSubmit` emitter to emit the "submit" event as its payload.
   *
   * @param $event The "submit" event object
   */
  onSubmit($event) {
    this._submittedReactive.set(true);
    syncPendingControls(this.form, this.directives);
    this.ngSubmit.emit($event);
    this.form._events.next(new FormSubmittedEvent(this.control));
    return $event?.target?.method === "dialog";
  }
  /**
   * @description
   * Method called when the "reset" event is triggered on the form.
   */
  onReset() {
    this.resetForm();
  }
  /**
   * @description
   * Resets the form to an initial value and resets its submitted status.
   *
   * @param value The new value for the form.
   */
  resetForm(value = void 0) {
    this.form.reset(value);
    this._submittedReactive.set(false);
    this.form._events.next(new FormResetEvent(this.form));
  }
  /** @internal */
  _updateDomValue() {
    this.directives.forEach((dir) => {
      const oldCtrl = dir.control;
      const newCtrl = this.form.get(dir.path);
      if (oldCtrl !== newCtrl) {
        cleanUpControl(oldCtrl || null, dir);
        if (isFormControl(newCtrl)) {
          setUpControl(newCtrl, dir, this.callSetDisabledState);
          dir.control = newCtrl;
        }
      }
    });
    this.form._updateTreeValidity({
      emitEvent: false
    });
  }
  _setUpFormContainer(dir) {
    const ctrl = this.form.get(dir.path);
    setUpFormContainer(ctrl, dir);
    ctrl.updateValueAndValidity({
      emitEvent: false
    });
  }
  _cleanUpFormContainer(dir) {
    if (this.form) {
      const ctrl = this.form.get(dir.path);
      if (ctrl) {
        const isControlUpdated = cleanUpFormContainer(ctrl, dir);
        if (isControlUpdated) {
          ctrl.updateValueAndValidity({
            emitEvent: false
          });
        }
      }
    }
  }
  _updateRegistrations() {
    this.form._registerOnCollectionChange(this._onCollectionChange);
    if (this._oldForm) {
      this._oldForm._registerOnCollectionChange(() => {
      });
    }
  }
  _updateValidators() {
    setUpValidators(this.form, this);
    if (this._oldForm) {
      cleanUpValidators(this._oldForm, this);
    }
  }
  static ɵfac = function FormGroupDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormGroupDirective)(ɵɵdirectiveInject(NG_VALIDATORS, 10), ɵɵdirectiveInject(NG_ASYNC_VALIDATORS, 10), ɵɵdirectiveInject(CALL_SET_DISABLED_STATE, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FormGroupDirective,
    selectors: [["", "formGroup", ""]],
    hostBindings: function FormGroupDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("submit", function FormGroupDirective_submit_HostBindingHandler($event) {
          return ctx.onSubmit($event);
        })("reset", function FormGroupDirective_reset_HostBindingHandler() {
          return ctx.onReset();
        });
      }
    },
    inputs: {
      form: [0, "formGroup", "form"]
    },
    outputs: {
      ngSubmit: "ngSubmit"
    },
    exportAs: ["ngForm"],
    standalone: false,
    features: [ɵɵProvidersFeature([formDirectiveProvider]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormGroupDirective, [{
    type: Directive,
    args: [{
      selector: "[formGroup]",
      providers: [formDirectiveProvider],
      host: {
        "(submit)": "onSubmit($event)",
        "(reset)": "onReset()"
      },
      exportAs: "ngForm",
      standalone: false
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], {
    form: [{
      type: Input,
      args: ["formGroup"]
    }],
    ngSubmit: [{
      type: Output
    }]
  });
})();
var formGroupNameProvider = {
  provide: ControlContainer,
  useExisting: forwardRef(() => FormGroupName)
};
var FormGroupName = class _FormGroupName extends AbstractFormGroupDirective {
  /**
   * @description
   * Tracks the name of the `FormGroup` bound to the directive. The name corresponds
   * to a key in the parent `FormGroup` or `FormArray`.
   * Accepts a name as a string or a number.
   * The name in the form of a string is useful for individual forms,
   * while the numerical form allows for form groups to be bound
   * to indices when iterating over groups in a `FormArray`.
   */
  name = null;
  constructor(parent, validators, asyncValidators) {
    super();
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  /** @internal */
  _checkParentType() {
    if (hasInvalidParent(this._parent) && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw groupParentException();
    }
  }
  static ɵfac = function FormGroupName_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormGroupName)(ɵɵdirectiveInject(ControlContainer, 13), ɵɵdirectiveInject(NG_VALIDATORS, 10), ɵɵdirectiveInject(NG_ASYNC_VALIDATORS, 10));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FormGroupName,
    selectors: [["", "formGroupName", ""]],
    inputs: {
      name: [0, "formGroupName", "name"]
    },
    standalone: false,
    features: [ɵɵProvidersFeature([formGroupNameProvider]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormGroupName, [{
    type: Directive,
    args: [{
      selector: "[formGroupName]",
      providers: [formGroupNameProvider],
      standalone: false
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }], {
    name: [{
      type: Input,
      args: ["formGroupName"]
    }]
  });
})();
var formArrayNameProvider = {
  provide: ControlContainer,
  useExisting: forwardRef(() => FormArrayName)
};
var FormArrayName = class _FormArrayName extends ControlContainer {
  /** @internal */
  _parent;
  /**
   * @description
   * Tracks the name of the `FormArray` bound to the directive. The name corresponds
   * to a key in the parent `FormGroup` or `FormArray`.
   * Accepts a name as a string or a number.
   * The name in the form of a string is useful for individual forms,
   * while the numerical form allows for form arrays to be bound
   * to indices when iterating over arrays in a `FormArray`.
   */
  name = null;
  constructor(parent, validators, asyncValidators) {
    super();
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  /**
   * A lifecycle method called when the directive's inputs are initialized. For internal use only.
   * @throws If the directive does not have a valid parent.
   * @docs-private
   */
  ngOnInit() {
    if (hasInvalidParent(this._parent) && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw arrayParentException();
    }
    this.formDirective.addFormArray(this);
  }
  /**
   * A lifecycle method called before the directive's instance is destroyed. For internal use only.
   * @docs-private
   */
  ngOnDestroy() {
    this.formDirective?.removeFormArray(this);
  }
  /**
   * @description
   * The `FormArray` bound to this directive.
   */
  get control() {
    return this.formDirective.getFormArray(this);
  }
  /**
   * @description
   * The top-level directive for this group if present, otherwise null.
   */
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
  }
  static ɵfac = function FormArrayName_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormArrayName)(ɵɵdirectiveInject(ControlContainer, 13), ɵɵdirectiveInject(NG_VALIDATORS, 10), ɵɵdirectiveInject(NG_ASYNC_VALIDATORS, 10));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FormArrayName,
    selectors: [["", "formArrayName", ""]],
    inputs: {
      name: [0, "formArrayName", "name"]
    },
    standalone: false,
    features: [ɵɵProvidersFeature([formArrayNameProvider]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormArrayName, [{
    type: Directive,
    args: [{
      selector: "[formArrayName]",
      providers: [formArrayNameProvider],
      standalone: false
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }], {
    name: [{
      type: Input,
      args: ["formArrayName"]
    }]
  });
})();
function hasInvalidParent(parent) {
  return !(parent instanceof FormGroupName) && !(parent instanceof FormGroupDirective) && !(parent instanceof FormArrayName);
}
var controlNameBinding = {
  provide: NgControl,
  useExisting: forwardRef(() => FormControlName)
};
var FormControlName = class _FormControlName extends NgControl {
  _ngModelWarningConfig;
  _added = false;
  /**
   * Internal reference to the view model value.
   * @internal
   */
  viewModel;
  /**
   * @description
   * Tracks the `FormControl` instance bound to the directive.
   */
  control;
  /**
   * @description
   * Tracks the name of the `FormControl` bound to the directive. The name corresponds
   * to a key in the parent `FormGroup` or `FormArray`.
   * Accepts a name as a string or a number.
   * The name in the form of a string is useful for individual forms,
   * while the numerical form allows for form controls to be bound
   * to indices when iterating over controls in a `FormArray`.
   */
  name = null;
  /**
   * @description
   * Triggers a warning in dev mode that this input should not be used with reactive forms.
   */
  set isDisabled(isDisabled) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      console.warn(disabledAttrWarning);
    }
  }
  // TODO(kara): remove next 4 properties once deprecation period is over
  /** @deprecated as of v6 */
  model;
  /** @deprecated as of v6 */
  update = new EventEmitter();
  /**
   * @description
   * Static property used to track whether any ngModel warnings have been sent across
   * all instances of FormControlName. Used to support warning config of "once".
   *
   * @internal
   */
  static _ngModelWarningSentOnce = false;
  /**
   * @description
   * Instance property used to track whether an ngModel warning has been sent out for this
   * particular FormControlName instance. Used to support warning config of "always".
   *
   * @internal
   */
  _ngModelWarningSent = false;
  constructor(parent, validators, asyncValidators, valueAccessors, _ngModelWarningConfig) {
    super();
    this._ngModelWarningConfig = _ngModelWarningConfig;
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
    this.valueAccessor = selectValueAccessor(this, valueAccessors);
  }
  /** @docs-private */
  ngOnChanges(changes) {
    if (!this._added) this._setUpControl();
    if (isPropertyUpdated(changes, this.viewModel)) {
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        _ngModelWarning("formControlName", _FormControlName, this, this._ngModelWarningConfig);
      }
      this.viewModel = this.model;
      this.formDirective.updateModel(this, this.model);
    }
  }
  /** @docs-private */
  ngOnDestroy() {
    if (this.formDirective) {
      this.formDirective.removeControl(this);
    }
  }
  /**
   * @description
   * Sets the new value for the view model and emits an `ngModelChange` event.
   *
   * @param newValue The new value for the view model.
   */
  viewToModelUpdate(newValue) {
    this.viewModel = newValue;
    this.update.emit(newValue);
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
  }
  /**
   * @description
   * The top-level directive for this group if present, otherwise null.
   */
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  _setUpControl() {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      checkParentType(this._parent, this.name);
    }
    this.control = this.formDirective.addControl(this);
    this._added = true;
  }
  static ɵfac = function FormControlName_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormControlName)(ɵɵdirectiveInject(ControlContainer, 13), ɵɵdirectiveInject(NG_VALIDATORS, 10), ɵɵdirectiveInject(NG_ASYNC_VALIDATORS, 10), ɵɵdirectiveInject(NG_VALUE_ACCESSOR, 10), ɵɵdirectiveInject(NG_MODEL_WITH_FORM_CONTROL_WARNING, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FormControlName,
    selectors: [["", "formControlName", ""]],
    inputs: {
      name: [0, "formControlName", "name"],
      isDisabled: [0, "disabled", "isDisabled"],
      model: [0, "ngModel", "model"]
    },
    outputs: {
      update: "ngModelChange"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([controlNameBinding]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormControlName, [{
    type: Directive,
    args: [{
      selector: "[formControlName]",
      providers: [controlNameBinding],
      standalone: false
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALUE_ACCESSOR]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [NG_MODEL_WITH_FORM_CONTROL_WARNING]
    }]
  }], {
    name: [{
      type: Input,
      args: ["formControlName"]
    }],
    isDisabled: [{
      type: Input,
      args: ["disabled"]
    }],
    model: [{
      type: Input,
      args: ["ngModel"]
    }],
    update: [{
      type: Output,
      args: ["ngModelChange"]
    }]
  });
})();
function checkParentType(parent, name) {
  if (!(parent instanceof FormGroupName) && parent instanceof AbstractFormGroupDirective) {
    throw ngModelGroupException();
  } else if (!(parent instanceof FormGroupName) && !(parent instanceof FormGroupDirective) && !(parent instanceof FormArrayName)) {
    throw controlParentException(name);
  }
}
var SELECT_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => SelectControlValueAccessor),
  multi: true
};
function _buildValueString$1(id, value) {
  if (id == null) return `${value}`;
  if (value && typeof value === "object") value = "Object";
  return `${id}: ${value}`.slice(0, 50);
}
function _extractId$1(valueString) {
  return valueString.split(":")[0];
}
var SelectControlValueAccessor = class _SelectControlValueAccessor extends BuiltInControlValueAccessor {
  /** @docs-private */
  value;
  /** @internal */
  _optionMap = /* @__PURE__ */ new Map();
  /** @internal */
  _idCounter = 0;
  /**
   * @description
   * Tracks the option comparison algorithm for tracking identities when
   * checking for changes.
   */
  set compareWith(fn) {
    if (typeof fn !== "function" && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw new RuntimeError(1201, `compareWith must be a function, but received ${JSON.stringify(fn)}`);
    }
    this._compareWith = fn;
  }
  _compareWith = Object.is;
  /**
   * Sets the "value" property on the select element.
   * @docs-private
   */
  writeValue(value) {
    this.value = value;
    const id = this._getOptionId(value);
    const valueString = _buildValueString$1(id, value);
    this.setProperty("value", valueString);
  }
  /**
   * Registers a function called when the control value changes.
   * @docs-private
   */
  registerOnChange(fn) {
    this.onChange = (valueString) => {
      this.value = this._getOptionValue(valueString);
      fn(this.value);
    };
  }
  /** @internal */
  _registerOption() {
    return (this._idCounter++).toString();
  }
  /** @internal */
  _getOptionId(value) {
    for (const id of this._optionMap.keys()) {
      if (this._compareWith(this._optionMap.get(id), value)) return id;
    }
    return null;
  }
  /** @internal */
  _getOptionValue(valueString) {
    const id = _extractId$1(valueString);
    return this._optionMap.has(id) ? this._optionMap.get(id) : valueString;
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵSelectControlValueAccessor_BaseFactory;
    return function SelectControlValueAccessor_Factory(__ngFactoryType__) {
      return (ɵSelectControlValueAccessor_BaseFactory || (ɵSelectControlValueAccessor_BaseFactory = ɵɵgetInheritedFactory(_SelectControlValueAccessor)))(__ngFactoryType__ || _SelectControlValueAccessor);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _SelectControlValueAccessor,
    selectors: [["select", "formControlName", "", 3, "multiple", ""], ["select", "formControl", "", 3, "multiple", ""], ["select", "ngModel", "", 3, "multiple", ""]],
    hostBindings: function SelectControlValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("change", function SelectControlValueAccessor_change_HostBindingHandler($event) {
          return ctx.onChange($event.target.value);
        })("blur", function SelectControlValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    inputs: {
      compareWith: "compareWith"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([SELECT_VALUE_ACCESSOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectControlValueAccessor, [{
    type: Directive,
    args: [{
      selector: "select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]",
      host: {
        "(change)": "onChange($event.target.value)",
        "(blur)": "onTouched()"
      },
      providers: [SELECT_VALUE_ACCESSOR],
      standalone: false
    }]
  }], null, {
    compareWith: [{
      type: Input
    }]
  });
})();
var NgSelectOption = class _NgSelectOption {
  _element;
  _renderer;
  _select;
  /**
   * @description
   * ID of the option element
   */
  id;
  constructor(_element, _renderer, _select) {
    this._element = _element;
    this._renderer = _renderer;
    this._select = _select;
    if (this._select) this.id = this._select._registerOption();
  }
  /**
   * @description
   * Tracks the value bound to the option element. Unlike the value binding,
   * ngValue supports binding to objects.
   */
  set ngValue(value) {
    if (this._select == null) return;
    this._select._optionMap.set(this.id, value);
    this._setElementValue(_buildValueString$1(this.id, value));
    this._select.writeValue(this._select.value);
  }
  /**
   * @description
   * Tracks simple string values bound to the option element.
   * For objects, use the `ngValue` input binding.
   */
  set value(value) {
    this._setElementValue(value);
    if (this._select) this._select.writeValue(this._select.value);
  }
  /** @internal */
  _setElementValue(value) {
    this._renderer.setProperty(this._element.nativeElement, "value", value);
  }
  /** @docs-private */
  ngOnDestroy() {
    if (this._select) {
      this._select._optionMap.delete(this.id);
      this._select.writeValue(this._select.value);
    }
  }
  static ɵfac = function NgSelectOption_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgSelectOption)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(SelectControlValueAccessor, 9));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _NgSelectOption,
    selectors: [["option"]],
    inputs: {
      ngValue: "ngValue",
      value: "value"
    },
    standalone: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgSelectOption, [{
    type: Directive,
    args: [{
      selector: "option",
      standalone: false
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: SelectControlValueAccessor,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }], {
    ngValue: [{
      type: Input,
      args: ["ngValue"]
    }],
    value: [{
      type: Input,
      args: ["value"]
    }]
  });
})();
var SELECT_MULTIPLE_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => SelectMultipleControlValueAccessor),
  multi: true
};
function _buildValueString(id, value) {
  if (id == null) return `${value}`;
  if (typeof value === "string") value = `'${value}'`;
  if (value && typeof value === "object") value = "Object";
  return `${id}: ${value}`.slice(0, 50);
}
function _extractId(valueString) {
  return valueString.split(":")[0];
}
var SelectMultipleControlValueAccessor = class _SelectMultipleControlValueAccessor extends BuiltInControlValueAccessor {
  /**
   * The current value.
   * @docs-private
   */
  value;
  /** @internal */
  _optionMap = /* @__PURE__ */ new Map();
  /** @internal */
  _idCounter = 0;
  /**
   * @description
   * Tracks the option comparison algorithm for tracking identities when
   * checking for changes.
   */
  set compareWith(fn) {
    if (typeof fn !== "function" && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw new RuntimeError(1201, `compareWith must be a function, but received ${JSON.stringify(fn)}`);
    }
    this._compareWith = fn;
  }
  _compareWith = Object.is;
  /**
   * Sets the "value" property on one or of more of the select's options.
   * @docs-private
   */
  writeValue(value) {
    this.value = value;
    let optionSelectedStateSetter;
    if (Array.isArray(value)) {
      const ids = value.map((v) => this._getOptionId(v));
      optionSelectedStateSetter = (opt, o) => {
        opt._setSelected(ids.indexOf(o.toString()) > -1);
      };
    } else {
      optionSelectedStateSetter = (opt, o) => {
        opt._setSelected(false);
      };
    }
    this._optionMap.forEach(optionSelectedStateSetter);
  }
  /**
   * Registers a function called when the control value changes
   * and writes an array of the selected options.
   * @docs-private
   */
  registerOnChange(fn) {
    this.onChange = (element) => {
      const selected = [];
      const selectedOptions = element.selectedOptions;
      if (selectedOptions !== void 0) {
        const options = selectedOptions;
        for (let i = 0; i < options.length; i++) {
          const opt = options[i];
          const val = this._getOptionValue(opt.value);
          selected.push(val);
        }
      } else {
        const options = element.options;
        for (let i = 0; i < options.length; i++) {
          const opt = options[i];
          if (opt.selected) {
            const val = this._getOptionValue(opt.value);
            selected.push(val);
          }
        }
      }
      this.value = selected;
      fn(selected);
    };
  }
  /** @internal */
  _registerOption(value) {
    const id = (this._idCounter++).toString();
    this._optionMap.set(id, value);
    return id;
  }
  /** @internal */
  _getOptionId(value) {
    for (const id of this._optionMap.keys()) {
      if (this._compareWith(this._optionMap.get(id)._value, value)) return id;
    }
    return null;
  }
  /** @internal */
  _getOptionValue(valueString) {
    const id = _extractId(valueString);
    return this._optionMap.has(id) ? this._optionMap.get(id)._value : valueString;
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵSelectMultipleControlValueAccessor_BaseFactory;
    return function SelectMultipleControlValueAccessor_Factory(__ngFactoryType__) {
      return (ɵSelectMultipleControlValueAccessor_BaseFactory || (ɵSelectMultipleControlValueAccessor_BaseFactory = ɵɵgetInheritedFactory(_SelectMultipleControlValueAccessor)))(__ngFactoryType__ || _SelectMultipleControlValueAccessor);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _SelectMultipleControlValueAccessor,
    selectors: [["select", "multiple", "", "formControlName", ""], ["select", "multiple", "", "formControl", ""], ["select", "multiple", "", "ngModel", ""]],
    hostBindings: function SelectMultipleControlValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("change", function SelectMultipleControlValueAccessor_change_HostBindingHandler($event) {
          return ctx.onChange($event.target);
        })("blur", function SelectMultipleControlValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    inputs: {
      compareWith: "compareWith"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([SELECT_MULTIPLE_VALUE_ACCESSOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectMultipleControlValueAccessor, [{
    type: Directive,
    args: [{
      selector: "select[multiple][formControlName],select[multiple][formControl],select[multiple][ngModel]",
      host: {
        "(change)": "onChange($event.target)",
        "(blur)": "onTouched()"
      },
      providers: [SELECT_MULTIPLE_VALUE_ACCESSOR],
      standalone: false
    }]
  }], null, {
    compareWith: [{
      type: Input
    }]
  });
})();
var ɵNgSelectMultipleOption = class _ɵNgSelectMultipleOption {
  _element;
  _renderer;
  _select;
  id;
  /** @internal */
  _value;
  constructor(_element, _renderer, _select) {
    this._element = _element;
    this._renderer = _renderer;
    this._select = _select;
    if (this._select) {
      this.id = this._select._registerOption(this);
    }
  }
  /**
   * @description
   * Tracks the value bound to the option element. Unlike the value binding,
   * ngValue supports binding to objects.
   */
  set ngValue(value) {
    if (this._select == null) return;
    this._value = value;
    this._setElementValue(_buildValueString(this.id, value));
    this._select.writeValue(this._select.value);
  }
  /**
   * @description
   * Tracks simple string values bound to the option element.
   * For objects, use the `ngValue` input binding.
   */
  set value(value) {
    if (this._select) {
      this._value = value;
      this._setElementValue(_buildValueString(this.id, value));
      this._select.writeValue(this._select.value);
    } else {
      this._setElementValue(value);
    }
  }
  /** @internal */
  _setElementValue(value) {
    this._renderer.setProperty(this._element.nativeElement, "value", value);
  }
  /** @internal */
  _setSelected(selected) {
    this._renderer.setProperty(this._element.nativeElement, "selected", selected);
  }
  /** @docs-private */
  ngOnDestroy() {
    if (this._select) {
      this._select._optionMap.delete(this.id);
      this._select.writeValue(this._select.value);
    }
  }
  static ɵfac = function ɵNgSelectMultipleOption_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ɵNgSelectMultipleOption)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(SelectMultipleControlValueAccessor, 9));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ɵNgSelectMultipleOption,
    selectors: [["option"]],
    inputs: {
      ngValue: "ngValue",
      value: "value"
    },
    standalone: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ɵNgSelectMultipleOption, [{
    type: Directive,
    args: [{
      selector: "option",
      standalone: false
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: SelectMultipleControlValueAccessor,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }], {
    ngValue: [{
      type: Input,
      args: ["ngValue"]
    }],
    value: [{
      type: Input,
      args: ["value"]
    }]
  });
})();
function toInteger(value) {
  return typeof value === "number" ? value : parseInt(value, 10);
}
function toFloat(value) {
  return typeof value === "number" ? value : parseFloat(value);
}
var AbstractValidatorDirective = class _AbstractValidatorDirective {
  _validator = nullValidator;
  _onChange;
  /**
   * A flag that tracks whether this validator is enabled.
   *
   * Marking it `internal` (vs `protected`), so that this flag can be used in host bindings of
   * directive classes that extend this base class.
   * @internal
   */
  _enabled;
  /** @docs-private */
  ngOnChanges(changes) {
    if (this.inputName in changes) {
      const input = this.normalizeInput(changes[this.inputName].currentValue);
      this._enabled = this.enabled(input);
      this._validator = this._enabled ? this.createValidator(input) : nullValidator;
      if (this._onChange) {
        this._onChange();
      }
    }
  }
  /** @docs-private */
  validate(control) {
    return this._validator(control);
  }
  /** @docs-private */
  registerOnValidatorChange(fn) {
    this._onChange = fn;
  }
  /**
   * @description
   * Determines whether this validator should be active or not based on an input.
   * Base class implementation checks whether an input is defined (if the value is different from
   * `null` and `undefined`). Validator classes that extend this base class can override this
   * function with the logic specific to a particular validator directive.
   */
  enabled(input) {
    return input != null;
  }
  static ɵfac = function AbstractValidatorDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AbstractValidatorDirective)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _AbstractValidatorDirective,
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AbstractValidatorDirective, [{
    type: Directive
  }], null, null);
})();
var MAX_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MaxValidator),
  multi: true
};
var MaxValidator = class _MaxValidator extends AbstractValidatorDirective {
  /**
   * @description
   * Tracks changes to the max bound to this directive.
   */
  max;
  /** @internal */
  inputName = "max";
  /** @internal */
  normalizeInput = (input) => toFloat(input);
  /** @internal */
  createValidator = (max) => maxValidator(max);
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵMaxValidator_BaseFactory;
    return function MaxValidator_Factory(__ngFactoryType__) {
      return (ɵMaxValidator_BaseFactory || (ɵMaxValidator_BaseFactory = ɵɵgetInheritedFactory(_MaxValidator)))(__ngFactoryType__ || _MaxValidator);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _MaxValidator,
    selectors: [["input", "type", "number", "max", "", "formControlName", ""], ["input", "type", "number", "max", "", "formControl", ""], ["input", "type", "number", "max", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function MaxValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("max", ctx._enabled ? ctx.max : null);
      }
    },
    inputs: {
      max: "max"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([MAX_VALIDATOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MaxValidator, [{
    type: Directive,
    args: [{
      selector: "input[type=number][max][formControlName],input[type=number][max][formControl],input[type=number][max][ngModel]",
      providers: [MAX_VALIDATOR],
      host: {
        "[attr.max]": "_enabled ? max : null"
      },
      standalone: false
    }]
  }], null, {
    max: [{
      type: Input
    }]
  });
})();
var MIN_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MinValidator),
  multi: true
};
var MinValidator = class _MinValidator extends AbstractValidatorDirective {
  /**
   * @description
   * Tracks changes to the min bound to this directive.
   */
  min;
  /** @internal */
  inputName = "min";
  /** @internal */
  normalizeInput = (input) => toFloat(input);
  /** @internal */
  createValidator = (min) => minValidator(min);
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵMinValidator_BaseFactory;
    return function MinValidator_Factory(__ngFactoryType__) {
      return (ɵMinValidator_BaseFactory || (ɵMinValidator_BaseFactory = ɵɵgetInheritedFactory(_MinValidator)))(__ngFactoryType__ || _MinValidator);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _MinValidator,
    selectors: [["input", "type", "number", "min", "", "formControlName", ""], ["input", "type", "number", "min", "", "formControl", ""], ["input", "type", "number", "min", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function MinValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("min", ctx._enabled ? ctx.min : null);
      }
    },
    inputs: {
      min: "min"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([MIN_VALIDATOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MinValidator, [{
    type: Directive,
    args: [{
      selector: "input[type=number][min][formControlName],input[type=number][min][formControl],input[type=number][min][ngModel]",
      providers: [MIN_VALIDATOR],
      host: {
        "[attr.min]": "_enabled ? min : null"
      },
      standalone: false
    }]
  }], null, {
    min: [{
      type: Input
    }]
  });
})();
var REQUIRED_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => RequiredValidator),
  multi: true
};
var CHECKBOX_REQUIRED_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => CheckboxRequiredValidator),
  multi: true
};
var RequiredValidator = class _RequiredValidator extends AbstractValidatorDirective {
  /**
   * @description
   * Tracks changes to the required attribute bound to this directive.
   */
  required;
  /** @internal */
  inputName = "required";
  /** @internal */
  normalizeInput = booleanAttribute;
  /** @internal */
  createValidator = (input) => requiredValidator;
  /** @docs-private */
  enabled(input) {
    return input;
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵRequiredValidator_BaseFactory;
    return function RequiredValidator_Factory(__ngFactoryType__) {
      return (ɵRequiredValidator_BaseFactory || (ɵRequiredValidator_BaseFactory = ɵɵgetInheritedFactory(_RequiredValidator)))(__ngFactoryType__ || _RequiredValidator);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _RequiredValidator,
    selectors: [["", "required", "", "formControlName", "", 3, "type", "checkbox"], ["", "required", "", "formControl", "", 3, "type", "checkbox"], ["", "required", "", "ngModel", "", 3, "type", "checkbox"]],
    hostVars: 1,
    hostBindings: function RequiredValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("required", ctx._enabled ? "" : null);
      }
    },
    inputs: {
      required: "required"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([REQUIRED_VALIDATOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RequiredValidator, [{
    type: Directive,
    args: [{
      selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]",
      providers: [REQUIRED_VALIDATOR],
      host: {
        "[attr.required]": '_enabled ? "" : null'
      },
      standalone: false
    }]
  }], null, {
    required: [{
      type: Input
    }]
  });
})();
var CheckboxRequiredValidator = class _CheckboxRequiredValidator extends RequiredValidator {
  /** @internal */
  createValidator = (input) => requiredTrueValidator;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵCheckboxRequiredValidator_BaseFactory;
    return function CheckboxRequiredValidator_Factory(__ngFactoryType__) {
      return (ɵCheckboxRequiredValidator_BaseFactory || (ɵCheckboxRequiredValidator_BaseFactory = ɵɵgetInheritedFactory(_CheckboxRequiredValidator)))(__ngFactoryType__ || _CheckboxRequiredValidator);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _CheckboxRequiredValidator,
    selectors: [["input", "type", "checkbox", "required", "", "formControlName", ""], ["input", "type", "checkbox", "required", "", "formControl", ""], ["input", "type", "checkbox", "required", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function CheckboxRequiredValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("required", ctx._enabled ? "" : null);
      }
    },
    standalone: false,
    features: [ɵɵProvidersFeature([CHECKBOX_REQUIRED_VALIDATOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckboxRequiredValidator, [{
    type: Directive,
    args: [{
      selector: "input[type=checkbox][required][formControlName],input[type=checkbox][required][formControl],input[type=checkbox][required][ngModel]",
      providers: [CHECKBOX_REQUIRED_VALIDATOR],
      host: {
        "[attr.required]": '_enabled ? "" : null'
      },
      standalone: false
    }]
  }], null, null);
})();
var EMAIL_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => EmailValidator),
  multi: true
};
var EmailValidator = class _EmailValidator extends AbstractValidatorDirective {
  /**
   * @description
   * Tracks changes to the email attribute bound to this directive.
   */
  email;
  /** @internal */
  inputName = "email";
  /** @internal */
  normalizeInput = booleanAttribute;
  /** @internal */
  createValidator = (input) => emailValidator;
  /** @docs-private */
  enabled(input) {
    return input;
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵEmailValidator_BaseFactory;
    return function EmailValidator_Factory(__ngFactoryType__) {
      return (ɵEmailValidator_BaseFactory || (ɵEmailValidator_BaseFactory = ɵɵgetInheritedFactory(_EmailValidator)))(__ngFactoryType__ || _EmailValidator);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _EmailValidator,
    selectors: [["", "email", "", "formControlName", ""], ["", "email", "", "formControl", ""], ["", "email", "", "ngModel", ""]],
    inputs: {
      email: "email"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([EMAIL_VALIDATOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EmailValidator, [{
    type: Directive,
    args: [{
      selector: "[email][formControlName],[email][formControl],[email][ngModel]",
      providers: [EMAIL_VALIDATOR],
      standalone: false
    }]
  }], null, {
    email: [{
      type: Input
    }]
  });
})();
var MIN_LENGTH_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MinLengthValidator),
  multi: true
};
var MinLengthValidator = class _MinLengthValidator extends AbstractValidatorDirective {
  /**
   * @description
   * Tracks changes to the minimum length bound to this directive.
   */
  minlength;
  /** @internal */
  inputName = "minlength";
  /** @internal */
  normalizeInput = (input) => toInteger(input);
  /** @internal */
  createValidator = (minlength) => minLengthValidator(minlength);
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵMinLengthValidator_BaseFactory;
    return function MinLengthValidator_Factory(__ngFactoryType__) {
      return (ɵMinLengthValidator_BaseFactory || (ɵMinLengthValidator_BaseFactory = ɵɵgetInheritedFactory(_MinLengthValidator)))(__ngFactoryType__ || _MinLengthValidator);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _MinLengthValidator,
    selectors: [["", "minlength", "", "formControlName", ""], ["", "minlength", "", "formControl", ""], ["", "minlength", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function MinLengthValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("minlength", ctx._enabled ? ctx.minlength : null);
      }
    },
    inputs: {
      minlength: "minlength"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([MIN_LENGTH_VALIDATOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MinLengthValidator, [{
    type: Directive,
    args: [{
      selector: "[minlength][formControlName],[minlength][formControl],[minlength][ngModel]",
      providers: [MIN_LENGTH_VALIDATOR],
      host: {
        "[attr.minlength]": "_enabled ? minlength : null"
      },
      standalone: false
    }]
  }], null, {
    minlength: [{
      type: Input
    }]
  });
})();
var MAX_LENGTH_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MaxLengthValidator),
  multi: true
};
var MaxLengthValidator = class _MaxLengthValidator extends AbstractValidatorDirective {
  /**
   * @description
   * Tracks changes to the maximum length bound to this directive.
   */
  maxlength;
  /** @internal */
  inputName = "maxlength";
  /** @internal */
  normalizeInput = (input) => toInteger(input);
  /** @internal */
  createValidator = (maxlength) => maxLengthValidator(maxlength);
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵMaxLengthValidator_BaseFactory;
    return function MaxLengthValidator_Factory(__ngFactoryType__) {
      return (ɵMaxLengthValidator_BaseFactory || (ɵMaxLengthValidator_BaseFactory = ɵɵgetInheritedFactory(_MaxLengthValidator)))(__ngFactoryType__ || _MaxLengthValidator);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _MaxLengthValidator,
    selectors: [["", "maxlength", "", "formControlName", ""], ["", "maxlength", "", "formControl", ""], ["", "maxlength", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function MaxLengthValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("maxlength", ctx._enabled ? ctx.maxlength : null);
      }
    },
    inputs: {
      maxlength: "maxlength"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([MAX_LENGTH_VALIDATOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MaxLengthValidator, [{
    type: Directive,
    args: [{
      selector: "[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]",
      providers: [MAX_LENGTH_VALIDATOR],
      host: {
        "[attr.maxlength]": "_enabled ? maxlength : null"
      },
      standalone: false
    }]
  }], null, {
    maxlength: [{
      type: Input
    }]
  });
})();
var PATTERN_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => PatternValidator),
  multi: true
};
var PatternValidator = class _PatternValidator extends AbstractValidatorDirective {
  /**
   * @description
   * Tracks changes to the pattern bound to this directive.
   */
  pattern;
  // This input is always defined, since the name matches selector.
  /** @internal */
  inputName = "pattern";
  /** @internal */
  normalizeInput = (input) => input;
  /** @internal */
  createValidator = (input) => patternValidator(input);
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPatternValidator_BaseFactory;
    return function PatternValidator_Factory(__ngFactoryType__) {
      return (ɵPatternValidator_BaseFactory || (ɵPatternValidator_BaseFactory = ɵɵgetInheritedFactory(_PatternValidator)))(__ngFactoryType__ || _PatternValidator);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _PatternValidator,
    selectors: [["", "pattern", "", "formControlName", ""], ["", "pattern", "", "formControl", ""], ["", "pattern", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function PatternValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("pattern", ctx._enabled ? ctx.pattern : null);
      }
    },
    inputs: {
      pattern: "pattern"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([PATTERN_VALIDATOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PatternValidator, [{
    type: Directive,
    args: [{
      selector: "[pattern][formControlName],[pattern][formControl],[pattern][ngModel]",
      providers: [PATTERN_VALIDATOR],
      host: {
        "[attr.pattern]": "_enabled ? pattern : null"
      },
      standalone: false
    }]
  }], null, {
    pattern: [{
      type: Input
    }]
  });
})();
var SHARED_FORM_DIRECTIVES = [ɵNgNoValidate, NgSelectOption, ɵNgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, RangeValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator, CheckboxRequiredValidator, EmailValidator, MinValidator, MaxValidator];
var TEMPLATE_DRIVEN_DIRECTIVES = [NgModel, NgModelGroup, NgForm];
var REACTIVE_DRIVEN_DIRECTIVES = [FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName];
var ɵInternalFormsSharedModule = class _ɵInternalFormsSharedModule {
  static ɵfac = function ɵInternalFormsSharedModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ɵInternalFormsSharedModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _ɵInternalFormsSharedModule,
    declarations: [ɵNgNoValidate, NgSelectOption, ɵNgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, RangeValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator, CheckboxRequiredValidator, EmailValidator, MinValidator, MaxValidator],
    exports: [ɵNgNoValidate, NgSelectOption, ɵNgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, RangeValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator, CheckboxRequiredValidator, EmailValidator, MinValidator, MaxValidator]
  });
  static ɵinj = ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ɵInternalFormsSharedModule, [{
    type: NgModule,
    args: [{
      declarations: SHARED_FORM_DIRECTIVES,
      exports: SHARED_FORM_DIRECTIVES
    }]
  }], null, null);
})();
var FormArray = class extends AbstractControl {
  /**
   * Creates a new `FormArray` instance.
   *
   * @param controls An array of child controls. Each child control is given an index
   * where it is registered.
   *
   * @param validatorOrOpts A synchronous validator function, or an array of
   * such functions, or an `AbstractControlOptions` object that contains validation functions
   * and a validation trigger.
   *
   * @param asyncValidator A single async validator or array of async validator functions
   *
   */
  constructor(controls, validatorOrOpts, asyncValidator) {
    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
    this.controls = controls;
    this._initObservables();
    this._setUpdateStrategy(validatorOrOpts);
    this._setUpControls();
    this.updateValueAndValidity({
      onlySelf: true,
      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
      // `VALID` or `INVALID`.
      // The status should be broadcasted via the `statusChanges` observable, so we set `emitEvent`
      // to `true` to allow that during the control creation process.
      emitEvent: !!this.asyncValidator
    });
  }
  controls;
  /**
   * Get the `AbstractControl` at the given `index` in the array.
   *
   * @param index Index in the array to retrieve the control. If `index` is negative, it will wrap
   *     around from the back, and if index is greatly negative (less than `-length`), the result is
   * undefined. This behavior is the same as `Array.at(index)`.
   */
  at(index) {
    return this.controls[this._adjustIndex(index)];
  }
  /**
   * Insert a new `AbstractControl` at the end of the array.
   *
   * @param control Form control to be inserted
   * @param options Specifies whether this FormArray instance should emit events after a new
   *     control is added.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * inserted. When false, no events are emitted.
   */
  push(control, options = {}) {
    this.controls.push(control);
    this._registerControl(control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  /**
   * Insert a new `AbstractControl` at the given `index` in the array.
   *
   * @param index Index in the array to insert the control. If `index` is negative, wraps around
   *     from the back. If `index` is greatly negative (less than `-length`), prepends to the array.
   * This behavior is the same as `Array.splice(index, 0, control)`.
   * @param control Form control to be inserted
   * @param options Specifies whether this FormArray instance should emit events after a new
   *     control is inserted.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * inserted. When false, no events are emitted.
   */
  insert(index, control, options = {}) {
    this.controls.splice(index, 0, control);
    this._registerControl(control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
  }
  /**
   * Remove the control at the given `index` in the array.
   *
   * @param index Index in the array to remove the control.  If `index` is negative, wraps around
   *     from the back. If `index` is greatly negative (less than `-length`), removes the first
   *     element. This behavior is the same as `Array.splice(index, 1)`.
   * @param options Specifies whether this FormArray instance should emit events after a
   *     control is removed.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * removed. When false, no events are emitted.
   */
  removeAt(index, options = {}) {
    let adjustedIndex = this._adjustIndex(index);
    if (adjustedIndex < 0) adjustedIndex = 0;
    if (this.controls[adjustedIndex]) this.controls[adjustedIndex]._registerOnCollectionChange(() => {
    });
    this.controls.splice(adjustedIndex, 1);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
  }
  /**
   * Replace an existing control.
   *
   * @param index Index in the array to replace the control. If `index` is negative, wraps around
   *     from the back. If `index` is greatly negative (less than `-length`), replaces the first
   *     element. This behavior is the same as `Array.splice(index, 1, control)`.
   * @param control The `AbstractControl` control to replace the existing control
   * @param options Specifies whether this FormArray instance should emit events after an
   *     existing control is replaced with a new one.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * replaced with a new one. When false, no events are emitted.
   */
  setControl(index, control, options = {}) {
    let adjustedIndex = this._adjustIndex(index);
    if (adjustedIndex < 0) adjustedIndex = 0;
    if (this.controls[adjustedIndex]) this.controls[adjustedIndex]._registerOnCollectionChange(() => {
    });
    this.controls.splice(adjustedIndex, 1);
    if (control) {
      this.controls.splice(adjustedIndex, 0, control);
      this._registerControl(control);
    }
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  /**
   * Length of the control array.
   */
  get length() {
    return this.controls.length;
  }
  /**
   * Sets the value of the `FormArray`. It accepts an array that matches
   * the structure of the control.
   *
   * This method performs strict checks, and throws an error if you try
   * to set the value of a control that doesn't exist or if you exclude the
   * value of a control.
   *
   * @usageNotes
   * ### Set the values for the controls in the form array
   *
   * ```ts
   * const arr = new FormArray([
   *   new FormControl(),
   *   new FormControl()
   * ]);
   * console.log(arr.value);   // [null, null]
   *
   * arr.setValue(['Nancy', 'Drew']);
   * console.log(arr.value);   // ['Nancy', 'Drew']
   * ```
   *
   * @param value Array of values for the controls
   * @param options Configure options that determine how the control propagates changes and
   * emits events after the value changes
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
   * is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control value is updated.
   * When false, no events are emitted.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   */
  setValue(value, options = {}) {
    assertAllValuesPresent(this, false, value);
    value.forEach((newValue, index) => {
      assertControlPresent(this, false, index);
      this.at(index).setValue(newValue, {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Patches the value of the `FormArray`. It accepts an array that matches the
   * structure of the control, and does its best to match the values to the correct
   * controls in the group.
   *
   * It accepts both super-sets and sub-sets of the array without throwing an error.
   *
   * @usageNotes
   * ### Patch the values for controls in a form array
   *
   * ```ts
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   * console.log(arr.value);   // [null, null]
   *
   * arr.patchValue(['Nancy']);
   * console.log(arr.value);   // ['Nancy', null]
   * ```
   *
   * @param value Array of latest values for the controls
   * @param options Configure options that determine how the control propagates changes and
   * emits events after the value changes
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
   * is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control
   * value is updated. When false, no events are emitted. The configuration options are passed to
   * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.
   */
  patchValue(value, options = {}) {
    if (value == null) return;
    value.forEach((newValue, index) => {
      if (this.at(index)) {
        this.at(index).patchValue(newValue, {
          onlySelf: true,
          emitEvent: options.emitEvent
        });
      }
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Resets the `FormArray` and all descendants are marked `pristine` and `untouched`, and the
   * value of all descendants to null or null maps.
   *
   * You reset to a specific form state by passing in an array of states
   * that matches the structure of the control. The state is a standalone value
   * or a form state object with both a value and a disabled status.
   *
   * @usageNotes
   * ### Reset the values in a form array
   *
   * ```ts
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   * arr.reset(['name', 'last name']);
   *
   * console.log(arr.value);  // ['name', 'last name']
   * ```
   *
   * ### Reset the values in a form array and the disabled status for the first control
   *
   * ```ts
   * arr.reset([
   *   {value: 'name', disabled: true},
   *   'last'
   * ]);
   *
   * console.log(arr.value);  // ['last']
   * console.log(arr.at(0).status);  // 'DISABLED'
   * ```
   *
   * @param value Array of values for the controls
   * @param options Configure options that determine how the control propagates changes and
   * emits events after the value changes
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
   * is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control is reset.
   * When false, no events are emitted.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   */
  reset(value = [], options = {}) {
    this._forEachChild((control, index) => {
      control.reset(value[index], {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this._updatePristine(options, this);
    this._updateTouched(options, this);
    this.updateValueAndValidity(options);
  }
  /**
   * The aggregate value of the array, including any disabled controls.
   *
   * Reports all values regardless of disabled status.
   */
  getRawValue() {
    return this.controls.map((control) => control.getRawValue());
  }
  /**
   * Remove all controls in the `FormArray`.
   *
   * @param options Specifies whether this FormArray instance should emit events after all
   *     controls are removed.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when all controls
   * in this FormArray instance are removed. When false, no events are emitted.
   *
   * @usageNotes
   * ### Remove all elements from a FormArray
   *
   * ```ts
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   * console.log(arr.length);  // 2
   *
   * arr.clear();
   * console.log(arr.length);  // 0
   * ```
   *
   * It's a simpler and more efficient alternative to removing all elements one by one:
   *
   * ```ts
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   *
   * while (arr.length) {
   *    arr.removeAt(0);
   * }
   * ```
   */
  clear(options = {}) {
    if (this.controls.length < 1) return;
    this._forEachChild((control) => control._registerOnCollectionChange(() => {
    }));
    this.controls.splice(0);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
  }
  /**
   * Adjusts a negative index by summing it with the length of the array. For very negative
   * indices, the result may remain negative.
   * @internal
   */
  _adjustIndex(index) {
    return index < 0 ? index + this.length : index;
  }
  /** @internal */
  _syncPendingControls() {
    let subtreeUpdated = this.controls.reduce((updated, child) => {
      return child._syncPendingControls() ? true : updated;
    }, false);
    if (subtreeUpdated) this.updateValueAndValidity({
      onlySelf: true
    });
    return subtreeUpdated;
  }
  /** @internal */
  _forEachChild(cb) {
    this.controls.forEach((control, index) => {
      cb(control, index);
    });
  }
  /** @internal */
  _updateValue() {
    this.value = this.controls.filter((control) => control.enabled || this.disabled).map((control) => control.value);
  }
  /** @internal */
  _anyControls(condition) {
    return this.controls.some((control) => control.enabled && condition(control));
  }
  /** @internal */
  _setUpControls() {
    this._forEachChild((control) => this._registerControl(control));
  }
  /** @internal */
  _allControlsDisabled() {
    for (const control of this.controls) {
      if (control.enabled) return false;
    }
    return this.controls.length > 0 || this.disabled;
  }
  _registerControl(control) {
    control.setParent(this);
    control._registerOnCollectionChange(this._onCollectionChange);
  }
  /** @internal */
  _find(name) {
    return this.at(name) ?? null;
  }
};
function isAbstractControlOptions(options) {
  return !!options && (options.asyncValidators !== void 0 || options.validators !== void 0 || options.updateOn !== void 0);
}
var FormBuilder = class _FormBuilder {
  useNonNullable = false;
  /**
   * @description
   * Returns a FormBuilder in which automatically constructed `FormControl` elements
   * have `{nonNullable: true}` and are non-nullable.
   *
   * **Constructing non-nullable controls**
   *
   * When constructing a control, it will be non-nullable, and will reset to its initial value.
   *
   * ```ts
   * let nnfb = new FormBuilder().nonNullable;
   * let name = nnfb.control('Alex'); // FormControl<string>
   * name.reset();
   * console.log(name); // 'Alex'
   * ```
   *
   * **Constructing non-nullable groups or arrays**
   *
   * When constructing a group or array, all automatically created inner controls will be
   * non-nullable, and will reset to their initial values.
   *
   * ```ts
   * let nnfb = new FormBuilder().nonNullable;
   * let name = nnfb.group({who: 'Alex'}); // FormGroup<{who: FormControl<string>}>
   * name.reset();
   * console.log(name); // {who: 'Alex'}
   * ```
   * **Constructing *nullable* fields on groups or arrays**
   *
   * It is still possible to have a nullable field. In particular, any `FormControl` which is
   * *already* constructed will not be altered. For example:
   *
   * ```ts
   * let nnfb = new FormBuilder().nonNullable;
   * // FormGroup<{who: FormControl<string|null>}>
   * let name = nnfb.group({who: new FormControl('Alex')});
   * name.reset(); console.log(name); // {who: null}
   * ```
   *
   * Because the inner control is constructed explicitly by the caller, the builder has
   * no control over how it is created, and cannot exclude the `null`.
   */
  get nonNullable() {
    const nnfb = new _FormBuilder();
    nnfb.useNonNullable = true;
    return nnfb;
  }
  group(controls, options = null) {
    const reducedControls = this._reduceControls(controls);
    let newOptions = {};
    if (isAbstractControlOptions(options)) {
      newOptions = options;
    } else if (options !== null) {
      newOptions.validators = options.validator;
      newOptions.asyncValidators = options.asyncValidator;
    }
    return new FormGroup(reducedControls, newOptions);
  }
  /**
   * @description
   * Constructs a new `FormRecord` instance. Accepts a single generic argument, which is an object
   * containing all the keys and corresponding inner control types.
   *
   * @param controls A collection of child controls. The key for each child is the name
   * under which it is registered.
   *
   * @param options Configuration options object for the `FormRecord`. The object should have the
   * `AbstractControlOptions` type and might contain the following fields:
   * * `validators`: A synchronous validator function, or an array of validator functions.
   * * `asyncValidators`: A single async validator or array of async validator functions.
   * * `updateOn`: The event upon which the control should be updated (options: 'change' | 'blur'
   * | submit').
   */
  record(controls, options = null) {
    const reducedControls = this._reduceControls(controls);
    return new FormRecord(reducedControls, options);
  }
  /**
   * @description
   * Constructs a new `FormControl` with the given state, validators and options. Sets
   * `{nonNullable: true}` in the options to get a non-nullable control. Otherwise, the
   * control will be nullable. Accepts a single generic argument, which is the type  of the
   * control's value.
   *
   * @param formState Initializes the control with an initial state value, or
   * with an object that contains both a value and a disabled status.
   *
   * @param validatorOrOpts A synchronous validator function, or an array of
   * such functions, or a `FormControlOptions` object that contains
   * validation functions and a validation trigger.
   *
   * @param asyncValidator A single async validator or array of async validator
   * functions.
   *
   * @usageNotes
   *
   * ### Initialize a control as disabled
   *
   * The following example returns a control with an initial value in a disabled state.
   *
   * {@example forms/ts/formBuilder/form_builder_example.ts region='disabled-control'}
   */
  control(formState, validatorOrOpts, asyncValidator) {
    let newOptions = {};
    if (!this.useNonNullable) {
      return new FormControl(formState, validatorOrOpts, asyncValidator);
    }
    if (isAbstractControlOptions(validatorOrOpts)) {
      newOptions = validatorOrOpts;
    } else {
      newOptions.validators = validatorOrOpts;
      newOptions.asyncValidators = asyncValidator;
    }
    return new FormControl(formState, __spreadProps(__spreadValues({}, newOptions), {
      nonNullable: true
    }));
  }
  /**
   * Constructs a new `FormArray` from the given array of configurations,
   * validators and options. Accepts a single generic argument, which is the type of each control
   * inside the array.
   *
   * @param controls An array of child controls or control configs. Each child control is given an
   *     index when it is registered.
   *
   * @param validatorOrOpts A synchronous validator function, or an array of such functions, or an
   *     `AbstractControlOptions` object that contains
   * validation functions and a validation trigger.
   *
   * @param asyncValidator A single async validator or array of async validator functions.
   */
  array(controls, validatorOrOpts, asyncValidator) {
    const createdControls = controls.map((c) => this._createControl(c));
    return new FormArray(createdControls, validatorOrOpts, asyncValidator);
  }
  /** @internal */
  _reduceControls(controls) {
    const createdControls = {};
    Object.keys(controls).forEach((controlName) => {
      createdControls[controlName] = this._createControl(controls[controlName]);
    });
    return createdControls;
  }
  /** @internal */
  _createControl(controls) {
    if (controls instanceof FormControl) {
      return controls;
    } else if (controls instanceof AbstractControl) {
      return controls;
    } else if (Array.isArray(controls)) {
      const value = controls[0];
      const validator = controls.length > 1 ? controls[1] : null;
      const asyncValidator = controls.length > 2 ? controls[2] : null;
      return this.control(value, validator, asyncValidator);
    } else {
      return this.control(controls);
    }
  }
  static ɵfac = function FormBuilder_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormBuilder)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _FormBuilder,
    factory: _FormBuilder.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var NonNullableFormBuilder = class _NonNullableFormBuilder {
  static ɵfac = function NonNullableFormBuilder_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NonNullableFormBuilder)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _NonNullableFormBuilder,
    factory: () => (() => inject(FormBuilder).nonNullable)(),
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NonNullableFormBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: () => inject(FormBuilder).nonNullable
    }]
  }], null, null);
})();
var UntypedFormBuilder = class _UntypedFormBuilder extends FormBuilder {
  group(controlsConfig, options = null) {
    return super.group(controlsConfig, options);
  }
  /**
   * Like `FormBuilder#control`, except the resulting control is untyped.
   */
  control(formState, validatorOrOpts, asyncValidator) {
    return super.control(formState, validatorOrOpts, asyncValidator);
  }
  /**
   * Like `FormBuilder#array`, except the resulting array is untyped.
   */
  array(controlsConfig, validatorOrOpts, asyncValidator) {
    return super.array(controlsConfig, validatorOrOpts, asyncValidator);
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵUntypedFormBuilder_BaseFactory;
    return function UntypedFormBuilder_Factory(__ngFactoryType__) {
      return (ɵUntypedFormBuilder_BaseFactory || (ɵUntypedFormBuilder_BaseFactory = ɵɵgetInheritedFactory(_UntypedFormBuilder)))(__ngFactoryType__ || _UntypedFormBuilder);
    };
  })();
  static ɵprov = ɵɵdefineInjectable({
    token: _UntypedFormBuilder,
    factory: _UntypedFormBuilder.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UntypedFormBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var VERSION = new Version("19.2.13");
var FormsModule = class _FormsModule {
  /**
   * @description
   * Provides options for configuring the forms module.
   *
   * @param opts An object of configuration options
   * * `callSetDisabledState` Configures whether to `always` call `setDisabledState`, which is more
   * correct, or to only call it `whenDisabled`, which is the legacy behavior.
   */
  static withConfig(opts) {
    return {
      ngModule: _FormsModule,
      providers: [{
        provide: CALL_SET_DISABLED_STATE,
        useValue: opts.callSetDisabledState ?? setDisabledStateDefault
      }]
    };
  }
  static ɵfac = function FormsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormsModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _FormsModule,
    declarations: [NgModel, NgModelGroup, NgForm],
    exports: [ɵInternalFormsSharedModule, NgModel, NgModelGroup, NgForm]
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [ɵInternalFormsSharedModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormsModule, [{
    type: NgModule,
    args: [{
      declarations: TEMPLATE_DRIVEN_DIRECTIVES,
      exports: [ɵInternalFormsSharedModule, TEMPLATE_DRIVEN_DIRECTIVES]
    }]
  }], null, null);
})();
var ReactiveFormsModule = class _ReactiveFormsModule {
  /**
   * @description
   * Provides options for configuring the reactive forms module.
   *
   * @param opts An object of configuration options
   * * `warnOnNgModelWithFormControl` Configures when to emit a warning when an `ngModel`
   * binding is used with reactive form directives.
   * * `callSetDisabledState` Configures whether to `always` call `setDisabledState`, which is more
   * correct, or to only call it `whenDisabled`, which is the legacy behavior.
   */
  static withConfig(opts) {
    return {
      ngModule: _ReactiveFormsModule,
      providers: [{
        provide: NG_MODEL_WITH_FORM_CONTROL_WARNING,
        useValue: opts.warnOnNgModelWithFormControl ?? "always"
      }, {
        provide: CALL_SET_DISABLED_STATE,
        useValue: opts.callSetDisabledState ?? setDisabledStateDefault
      }]
    };
  }
  static ɵfac = function ReactiveFormsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ReactiveFormsModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _ReactiveFormsModule,
    declarations: [FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName],
    exports: [ɵInternalFormsSharedModule, FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName]
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [ɵInternalFormsSharedModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ReactiveFormsModule, [{
    type: NgModule,
    args: [{
      declarations: [REACTIVE_DRIVEN_DIRECTIVES],
      exports: [ɵInternalFormsSharedModule, REACTIVE_DRIVEN_DIRECTIVES]
    }]
  }], null, null);
})();

// node_modules/@astrouxds/astro-web-components/dist/esm/loader.js
var patchEsm = () => {
  return promiseResolve();
};
var defineCustomElements = (win, options) => {
  if (typeof window === "undefined") return Promise.resolve();
  return patchEsm().then(() => {
    return bootstrapLazy(JSON.parse('[["rux-dialog",[[17,"rux-dialog",{"open":[1540],"message":[1],"header":[1],"confirmText":[1,"confirm-text"],"denyText":[1,"deny-text"],"clickToClose":[4,"click-to-close"],"hasFooter":[32],"hasHeader":[32],"hasMessage":[32],"toggle":[64],"show":[64],"hide":[64]},[[8,"keydown","handleKeyDown"],[8,"click","handleClick"]]]]],["rux-global-status-bar",[[1,"rux-global-status-bar",{"includeIcon":[4,"include-icon"],"appState":[1,"app-state"],"appStateColor":[1,"app-state-color"],"username":[1],"appDomain":[1,"app-domain"],"appName":[1,"app-name"],"appVersion":[1,"app-version"],"menuIcon":[513,"menu-icon"]}]]],["rux-accordion",[[1,"rux-accordion",{"disabled":[516],"disallowMultiple":[516,"disallow-multiple"]},[[0,"ruxexpanded","updatedExpanded"]]]]],["rux-accordion-item",[[1,"rux-accordion-item",{"expanded":[1540],"disabled":[516],"hasPrefix":[32]}]]],["rux-breadcrumb",[[1,"rux-breadcrumb"]]],["rux-breadcrumb-item",[[1,"rux-breadcrumb-item",{"href":[513]}]]],["rux-button-group",[[1,"rux-button-group",{"hAlign":[1,"h-align"]}]]],["rux-card",[[1,"rux-card",{"activeSlots":[32]}]]],["rux-checkbox",[[1,"rux-checkbox",{"helpText":[1,"help-text"],"name":[1],"value":[1537],"label":[1],"checked":[1540],"indeterminate":[1540],"disabled":[516],"hasLabelSlot":[32],"hasHelpSlot":[32],"isFocused":[32]}]]],["rux-checkbox-group",[[1,"rux-checkbox-group",{"label":[1],"helpText":[1,"help-text"],"errorText":[1,"error-text"],"invalid":[4],"required":[4],"hasLabelSlot":[32],"hasHelpSlot":[32],"hasErrorSlot":[32]}]]],["rux-classification-marking",[[1,"rux-classification-marking",{"classification":[513],"label":[1],"tag":[516],"isWrapper":[32]},[[0,"slotchange","_handleSlotChange"]]]]],["rux-clock",[[1,"rux-clock",{"aos":[1],"static":[4],"los":[1],"timezone":[1],"hideTimezone":[4,"hide-timezone"],"hideDate":[4,"hide-date"],"hideLabels":[4,"hide-labels"],"dateIn":[1,"date-in"],"small":[516],"_time":[32],"_rawTime":[32]}]]],["rux-container",[[1,"rux-container",{"activeSlots":[32]}]]],["rux-icon-360",[[0,"rux-icon-360",{"size":[1]}]]],["rux-icon-3d-rotation",[[0,"rux-icon-3d-rotation",{"size":[1]}]]],["rux-icon-4k",[[0,"rux-icon-4k",{"size":[1]}]]],["rux-icon-ac-unit",[[0,"rux-icon-ac-unit",{"size":[1]}]]],["rux-icon-access-alarms",[[0,"rux-icon-access-alarms",{"size":[1]}]]],["rux-icon-access-time",[[0,"rux-icon-access-time",{"size":[1]}]]],["rux-icon-accessibility",[[0,"rux-icon-accessibility",{"size":[1]}]]],["rux-icon-accessibility-new",[[0,"rux-icon-accessibility-new",{"size":[1]}]]],["rux-icon-accessible",[[0,"rux-icon-accessible",{"size":[1]}]]],["rux-icon-accessible-forward",[[0,"rux-icon-accessible-forward",{"size":[1]}]]],["rux-icon-account-balance",[[0,"rux-icon-account-balance",{"size":[1]}]]],["rux-icon-account-balance-wallet",[[0,"rux-icon-account-balance-wallet",{"size":[1]}]]],["rux-icon-account-box",[[0,"rux-icon-account-box",{"size":[1]}]]],["rux-icon-account-circle",[[0,"rux-icon-account-circle",{"size":[1]}]]],["rux-icon-adb",[[0,"rux-icon-adb",{"size":[1]}]]],["rux-icon-add",[[0,"rux-icon-add",{"size":[1]}]]],["rux-icon-add-a-photo",[[0,"rux-icon-add-a-photo",{"size":[1]}]]],["rux-icon-add-alarm",[[0,"rux-icon-add-alarm",{"size":[1]}]]],["rux-icon-add-alert",[[0,"rux-icon-add-alert",{"size":[1]}]]],["rux-icon-add-box",[[0,"rux-icon-add-box",{"size":[1]}]]],["rux-icon-add-circle",[[0,"rux-icon-add-circle",{"size":[1]}]]],["rux-icon-add-circle-outline",[[0,"rux-icon-add-circle-outline",{"size":[1]}]]],["rux-icon-add-comment",[[0,"rux-icon-add-comment",{"size":[1]}]]],["rux-icon-add-location",[[0,"rux-icon-add-location",{"size":[1]}]]],["rux-icon-add-photo-alternate",[[0,"rux-icon-add-photo-alternate",{"size":[1]}]]],["rux-icon-add-shopping-cart",[[0,"rux-icon-add-shopping-cart",{"size":[1]}]]],["rux-icon-add-to-home-screen",[[0,"rux-icon-add-to-home-screen",{"size":[1]}]]],["rux-icon-add-to-photos",[[0,"rux-icon-add-to-photos",{"size":[1]}]]],["rux-icon-add-to-queue",[[0,"rux-icon-add-to-queue",{"size":[1]}]]],["rux-icon-adjust",[[0,"rux-icon-adjust",{"size":[1]}]]],["rux-icon-airline-seat-flat",[[0,"rux-icon-airline-seat-flat",{"size":[1]}]]],["rux-icon-airline-seat-flat-angled",[[0,"rux-icon-airline-seat-flat-angled",{"size":[1]}]]],["rux-icon-airline-seat-individual-suite",[[0,"rux-icon-airline-seat-individual-suite",{"size":[1]}]]],["rux-icon-airline-seat-legroom-extra",[[0,"rux-icon-airline-seat-legroom-extra",{"size":[1]}]]],["rux-icon-airline-seat-legroom-normal",[[0,"rux-icon-airline-seat-legroom-normal",{"size":[1]}]]],["rux-icon-airline-seat-legroom-reduced",[[0,"rux-icon-airline-seat-legroom-reduced",{"size":[1]}]]],["rux-icon-airline-seat-recline-extra",[[0,"rux-icon-airline-seat-recline-extra",{"size":[1]}]]],["rux-icon-airline-seat-recline-normal",[[0,"rux-icon-airline-seat-recline-normal",{"size":[1]}]]],["rux-icon-airplanemode-active",[[0,"rux-icon-airplanemode-active",{"size":[1]}]]],["rux-icon-airplanemode-inactive",[[0,"rux-icon-airplanemode-inactive",{"size":[1]}]]],["rux-icon-airplay",[[0,"rux-icon-airplay",{"size":[1]}]]],["rux-icon-airport-shuttle",[[0,"rux-icon-airport-shuttle",{"size":[1]}]]],["rux-icon-alarm",[[0,"rux-icon-alarm",{"size":[1]}]]],["rux-icon-alarm-add",[[0,"rux-icon-alarm-add",{"size":[1]}]]],["rux-icon-alarm-off",[[0,"rux-icon-alarm-off",{"size":[1]}]]],["rux-icon-alarm-on",[[0,"rux-icon-alarm-on",{"size":[1]}]]],["rux-icon-album",[[0,"rux-icon-album",{"size":[1]}]]],["rux-icon-all-inbox",[[0,"rux-icon-all-inbox",{"size":[1]}]]],["rux-icon-all-inclusive",[[0,"rux-icon-all-inclusive",{"size":[1]}]]],["rux-icon-all-out",[[0,"rux-icon-all-out",{"size":[1]}]]],["rux-icon-alternate-email",[[0,"rux-icon-alternate-email",{"size":[1]}]]],["rux-icon-altitude",[[0,"rux-icon-altitude",{"size":[1]}]]],["rux-icon-android",[[0,"rux-icon-android",{"size":[1]}]]],["rux-icon-announcement",[[0,"rux-icon-announcement",{"size":[1]}]]],["rux-icon-antenna",[[0,"rux-icon-antenna",{"size":[1]}]]],["rux-icon-antenna-off",[[0,"rux-icon-antenna-off",{"size":[1]}]]],["rux-icon-antenna-receive",[[0,"rux-icon-antenna-receive",{"size":[1]}]]],["rux-icon-antenna-transmit",[[0,"rux-icon-antenna-transmit",{"size":[1]}]]],["rux-icon-apps",[[0,"rux-icon-apps",{"size":[1]}]]],["rux-icon-archive",[[0,"rux-icon-archive",{"size":[1]}]]],["rux-icon-arrow-back",[[0,"rux-icon-arrow-back",{"size":[1]}]]],["rux-icon-arrow-back-ios",[[0,"rux-icon-arrow-back-ios",{"size":[1]}]]],["rux-icon-arrow-downward",[[0,"rux-icon-arrow-downward",{"size":[1]}]]],["rux-icon-arrow-drop-down",[[0,"rux-icon-arrow-drop-down",{"size":[1]}]]],["rux-icon-arrow-drop-down-circle",[[0,"rux-icon-arrow-drop-down-circle",{"size":[1]}]]],["rux-icon-arrow-drop-up",[[0,"rux-icon-arrow-drop-up",{"size":[1]}]]],["rux-icon-arrow-forward",[[0,"rux-icon-arrow-forward",{"size":[1]}]]],["rux-icon-arrow-forward-ios",[[0,"rux-icon-arrow-forward-ios",{"size":[1]}]]],["rux-icon-arrow-left",[[0,"rux-icon-arrow-left",{"size":[1]}]]],["rux-icon-arrow-right",[[0,"rux-icon-arrow-right",{"size":[1]}]]],["rux-icon-arrow-right-alt",[[0,"rux-icon-arrow-right-alt",{"size":[1]}]]],["rux-icon-arrow-upward",[[0,"rux-icon-arrow-upward",{"size":[1]}]]],["rux-icon-art-track",[[0,"rux-icon-art-track",{"size":[1]}]]],["rux-icon-aspect-ratio",[[0,"rux-icon-aspect-ratio",{"size":[1]}]]],["rux-icon-assessment",[[0,"rux-icon-assessment",{"size":[1]}]]],["rux-icon-assignment",[[0,"rux-icon-assignment",{"size":[1]}]]],["rux-icon-assignment-find",[[0,"rux-icon-assignment-find",{"size":[1]}]]],["rux-icon-assignment-late",[[0,"rux-icon-assignment-late",{"size":[1]}]]],["rux-icon-assignment-return",[[0,"rux-icon-assignment-return",{"size":[1]}]]],["rux-icon-assignment-returned",[[0,"rux-icon-assignment-returned",{"size":[1]}]]],["rux-icon-assignment-turned-in",[[0,"rux-icon-assignment-turned-in",{"size":[1]}]]],["rux-icon-assistant",[[0,"rux-icon-assistant",{"size":[1]}]]],["rux-icon-assistant-photo",[[0,"rux-icon-assistant-photo",{"size":[1]}]]],["rux-icon-attach-file",[[0,"rux-icon-attach-file",{"size":[1]}]]],["rux-icon-attach-money",[[0,"rux-icon-attach-money",{"size":[1]}]]],["rux-icon-attachment",[[0,"rux-icon-attachment",{"size":[1]}]]],["rux-icon-audiotrack",[[0,"rux-icon-audiotrack",{"size":[1]}]]],["rux-icon-autorenew",[[0,"rux-icon-autorenew",{"size":[1]}]]],["rux-icon-av-timer",[[0,"rux-icon-av-timer",{"size":[1]}]]],["rux-icon-backspace",[[0,"rux-icon-backspace",{"size":[1]}]]],["rux-icon-backup",[[0,"rux-icon-backup",{"size":[1]}]]],["rux-icon-ballot",[[0,"rux-icon-ballot",{"size":[1]}]]],["rux-icon-bar-chart",[[0,"rux-icon-bar-chart",{"size":[1]}]]],["rux-icon-battery-20",[[0,"rux-icon-battery-20",{"size":[1]}]]],["rux-icon-battery-30",[[0,"rux-icon-battery-30",{"size":[1]}]]],["rux-icon-battery-50",[[0,"rux-icon-battery-50",{"size":[1]}]]],["rux-icon-battery-60",[[0,"rux-icon-battery-60",{"size":[1]}]]],["rux-icon-battery-80",[[0,"rux-icon-battery-80",{"size":[1]}]]],["rux-icon-battery-90",[[0,"rux-icon-battery-90",{"size":[1]}]]],["rux-icon-battery-alert",[[0,"rux-icon-battery-alert",{"size":[1]}]]],["rux-icon-battery-charging-20",[[0,"rux-icon-battery-charging-20",{"size":[1]}]]],["rux-icon-battery-charging-30",[[0,"rux-icon-battery-charging-30",{"size":[1]}]]],["rux-icon-battery-charging-50",[[0,"rux-icon-battery-charging-50",{"size":[1]}]]],["rux-icon-battery-charging-60",[[0,"rux-icon-battery-charging-60",{"size":[1]}]]],["rux-icon-battery-charging-80",[[0,"rux-icon-battery-charging-80",{"size":[1]}]]],["rux-icon-battery-charging-90",[[0,"rux-icon-battery-charging-90",{"size":[1]}]]],["rux-icon-battery-charging-full",[[0,"rux-icon-battery-charging-full",{"size":[1]}]]],["rux-icon-battery-full",[[0,"rux-icon-battery-full",{"size":[1]}]]],["rux-icon-battery-std",[[0,"rux-icon-battery-std",{"size":[1]}]]],["rux-icon-battery-unknown",[[0,"rux-icon-battery-unknown",{"size":[1]}]]],["rux-icon-beach-access",[[0,"rux-icon-beach-access",{"size":[1]}]]],["rux-icon-beenhere",[[0,"rux-icon-beenhere",{"size":[1]}]]],["rux-icon-block",[[0,"rux-icon-block",{"size":[1]}]]],["rux-icon-bluetooth",[[0,"rux-icon-bluetooth",{"size":[1]}]]],["rux-icon-bluetooth-audio",[[0,"rux-icon-bluetooth-audio",{"size":[1]}]]],["rux-icon-bluetooth-connected",[[0,"rux-icon-bluetooth-connected",{"size":[1]}]]],["rux-icon-bluetooth-disabled",[[0,"rux-icon-bluetooth-disabled",{"size":[1]}]]],["rux-icon-bluetooth-searching",[[0,"rux-icon-bluetooth-searching",{"size":[1]}]]],["rux-icon-blur-circular",[[0,"rux-icon-blur-circular",{"size":[1]}]]],["rux-icon-blur-linear",[[0,"rux-icon-blur-linear",{"size":[1]}]]],["rux-icon-blur-off",[[0,"rux-icon-blur-off",{"size":[1]}]]],["rux-icon-blur-on",[[0,"rux-icon-blur-on",{"size":[1]}]]],["rux-icon-book",[[0,"rux-icon-book",{"size":[1]}]]],["rux-icon-bookmark",[[0,"rux-icon-bookmark",{"size":[1]}]]],["rux-icon-bookmark-border",[[0,"rux-icon-bookmark-border",{"size":[1]}]]],["rux-icon-bookmarks",[[0,"rux-icon-bookmarks",{"size":[1]}]]],["rux-icon-border-all",[[0,"rux-icon-border-all",{"size":[1]}]]],["rux-icon-border-bottom",[[0,"rux-icon-border-bottom",{"size":[1]}]]],["rux-icon-border-clear",[[0,"rux-icon-border-clear",{"size":[1]}]]],["rux-icon-border-color",[[0,"rux-icon-border-color",{"size":[1]}]]],["rux-icon-border-horizontal",[[0,"rux-icon-border-horizontal",{"size":[1]}]]],["rux-icon-border-inner",[[0,"rux-icon-border-inner",{"size":[1]}]]],["rux-icon-border-left",[[0,"rux-icon-border-left",{"size":[1]}]]],["rux-icon-border-outer",[[0,"rux-icon-border-outer",{"size":[1]}]]],["rux-icon-border-right",[[0,"rux-icon-border-right",{"size":[1]}]]],["rux-icon-border-style",[[0,"rux-icon-border-style",{"size":[1]}]]],["rux-icon-border-top",[[0,"rux-icon-border-top",{"size":[1]}]]],["rux-icon-border-vertical",[[0,"rux-icon-border-vertical",{"size":[1]}]]],["rux-icon-branding-watermark",[[0,"rux-icon-branding-watermark",{"size":[1]}]]],["rux-icon-brightness-1",[[0,"rux-icon-brightness-1",{"size":[1]}]]],["rux-icon-brightness-2",[[0,"rux-icon-brightness-2",{"size":[1]}]]],["rux-icon-brightness-3",[[0,"rux-icon-brightness-3",{"size":[1]}]]],["rux-icon-brightness-4",[[0,"rux-icon-brightness-4",{"size":[1]}]]],["rux-icon-brightness-5",[[0,"rux-icon-brightness-5",{"size":[1]}]]],["rux-icon-brightness-6",[[0,"rux-icon-brightness-6",{"size":[1]}]]],["rux-icon-brightness-7",[[0,"rux-icon-brightness-7",{"size":[1]}]]],["rux-icon-brightness-auto",[[0,"rux-icon-brightness-auto",{"size":[1]}]]],["rux-icon-brightness-high",[[0,"rux-icon-brightness-high",{"size":[1]}]]],["rux-icon-brightness-low",[[0,"rux-icon-brightness-low",{"size":[1]}]]],["rux-icon-brightness-medium",[[0,"rux-icon-brightness-medium",{"size":[1]}]]],["rux-icon-broken-image",[[0,"rux-icon-broken-image",{"size":[1]}]]],["rux-icon-brush",[[0,"rux-icon-brush",{"size":[1]}]]],["rux-icon-bubble-chart",[[0,"rux-icon-bubble-chart",{"size":[1]}]]],["rux-icon-bug-report",[[0,"rux-icon-bug-report",{"size":[1]}]]],["rux-icon-build",[[0,"rux-icon-build",{"size":[1]}]]],["rux-icon-burst-mode",[[0,"rux-icon-burst-mode",{"size":[1]}]]],["rux-icon-business",[[0,"rux-icon-business",{"size":[1]}]]],["rux-icon-business-center",[[0,"rux-icon-business-center",{"size":[1]}]]],["rux-icon-cached",[[0,"rux-icon-cached",{"size":[1]}]]],["rux-icon-cake",[[0,"rux-icon-cake",{"size":[1]}]]],["rux-icon-calendar-today",[[0,"rux-icon-calendar-today",{"size":[1]}]]],["rux-icon-calendar-view-day",[[0,"rux-icon-calendar-view-day",{"size":[1]}]]],["rux-icon-call",[[0,"rux-icon-call",{"size":[1]}]]],["rux-icon-call-end",[[0,"rux-icon-call-end",{"size":[1]}]]],["rux-icon-call-made",[[0,"rux-icon-call-made",{"size":[1]}]]],["rux-icon-call-merge",[[0,"rux-icon-call-merge",{"size":[1]}]]],["rux-icon-call-missed",[[0,"rux-icon-call-missed",{"size":[1]}]]],["rux-icon-call-missed-outgoing",[[0,"rux-icon-call-missed-outgoing",{"size":[1]}]]],["rux-icon-call-received",[[0,"rux-icon-call-received",{"size":[1]}]]],["rux-icon-call-split",[[0,"rux-icon-call-split",{"size":[1]}]]],["rux-icon-call-to-action",[[0,"rux-icon-call-to-action",{"size":[1]}]]],["rux-icon-camera",[[0,"rux-icon-camera",{"size":[1]}]]],["rux-icon-camera-alt",[[0,"rux-icon-camera-alt",{"size":[1]}]]],["rux-icon-camera-enhance",[[0,"rux-icon-camera-enhance",{"size":[1]}]]],["rux-icon-camera-front",[[0,"rux-icon-camera-front",{"size":[1]}]]],["rux-icon-camera-rear",[[0,"rux-icon-camera-rear",{"size":[1]}]]],["rux-icon-camera-roll",[[0,"rux-icon-camera-roll",{"size":[1]}]]],["rux-icon-cancel",[[0,"rux-icon-cancel",{"size":[1]}]]],["rux-icon-cancel-presentation",[[0,"rux-icon-cancel-presentation",{"size":[1]}]]],["rux-icon-card-giftcard",[[0,"rux-icon-card-giftcard",{"size":[1]}]]],["rux-icon-card-membership",[[0,"rux-icon-card-membership",{"size":[1]}]]],["rux-icon-card-travel",[[0,"rux-icon-card-travel",{"size":[1]}]]],["rux-icon-casino",[[0,"rux-icon-casino",{"size":[1]}]]],["rux-icon-cast",[[0,"rux-icon-cast",{"size":[1]}]]],["rux-icon-cast-connected",[[0,"rux-icon-cast-connected",{"size":[1]}]]],["rux-icon-cast-for-education",[[0,"rux-icon-cast-for-education",{"size":[1]}]]],["rux-icon-category",[[0,"rux-icon-category",{"size":[1]}]]],["rux-icon-cell-wifi",[[0,"rux-icon-cell-wifi",{"size":[1]}]]],["rux-icon-center-focus-strong",[[0,"rux-icon-center-focus-strong",{"size":[1]}]]],["rux-icon-center-focus-weak",[[0,"rux-icon-center-focus-weak",{"size":[1]}]]],["rux-icon-change-history",[[0,"rux-icon-change-history",{"size":[1]}]]],["rux-icon-chat",[[0,"rux-icon-chat",{"size":[1]}]]],["rux-icon-chat-bubble",[[0,"rux-icon-chat-bubble",{"size":[1]}]]],["rux-icon-chat-bubble-outline",[[0,"rux-icon-chat-bubble-outline",{"size":[1]}]]],["rux-icon-check",[[0,"rux-icon-check",{"size":[1]}]]],["rux-icon-check-box",[[0,"rux-icon-check-box",{"size":[1]}]]],["rux-icon-check-box-outline-blank",[[0,"rux-icon-check-box-outline-blank",{"size":[1]}]]],["rux-icon-check-circle",[[0,"rux-icon-check-circle",{"size":[1]}]]],["rux-icon-check-circle-outline",[[0,"rux-icon-check-circle-outline",{"size":[1]}]]],["rux-icon-chevron-left",[[0,"rux-icon-chevron-left",{"size":[1]}]]],["rux-icon-chevron-right",[[0,"rux-icon-chevron-right",{"size":[1]}]]],["rux-icon-child-care",[[0,"rux-icon-child-care",{"size":[1]}]]],["rux-icon-child-friendly",[[0,"rux-icon-child-friendly",{"size":[1]}]]],["rux-icon-chrome-reader-mode",[[0,"rux-icon-chrome-reader-mode",{"size":[1]}]]],["rux-icon-class",[[0,"rux-icon-class",{"size":[1]}]]],["rux-icon-clear",[[0,"rux-icon-clear",{"size":[1]}]]],["rux-icon-clear-all",[[0,"rux-icon-clear-all",{"size":[1]}]]],["rux-icon-close",[[0,"rux-icon-close",{"size":[1]}]]],["rux-icon-closed-caption",[[0,"rux-icon-closed-caption",{"size":[1]}]]],["rux-icon-cloud",[[0,"rux-icon-cloud",{"size":[1]}]]],["rux-icon-cloud-circle",[[0,"rux-icon-cloud-circle",{"size":[1]}]]],["rux-icon-cloud-done",[[0,"rux-icon-cloud-done",{"size":[1]}]]],["rux-icon-cloud-download",[[0,"rux-icon-cloud-download",{"size":[1]}]]],["rux-icon-cloud-off",[[0,"rux-icon-cloud-off",{"size":[1]}]]],["rux-icon-cloud-queue",[[0,"rux-icon-cloud-queue",{"size":[1]}]]],["rux-icon-cloud-upload",[[0,"rux-icon-cloud-upload",{"size":[1]}]]],["rux-icon-code",[[0,"rux-icon-code",{"size":[1]}]]],["rux-icon-collections",[[0,"rux-icon-collections",{"size":[1]}]]],["rux-icon-collections-bookmark",[[0,"rux-icon-collections-bookmark",{"size":[1]}]]],["rux-icon-color-lens",[[0,"rux-icon-color-lens",{"size":[1]}]]],["rux-icon-colorize",[[0,"rux-icon-colorize",{"size":[1]}]]],["rux-icon-comment",[[0,"rux-icon-comment",{"size":[1]}]]],["rux-icon-commute",[[0,"rux-icon-commute",{"size":[1]}]]],["rux-icon-compare",[[0,"rux-icon-compare",{"size":[1]}]]],["rux-icon-compare-arrows",[[0,"rux-icon-compare-arrows",{"size":[1]}]]],["rux-icon-compass-calibration",[[0,"rux-icon-compass-calibration",{"size":[1]}]]],["rux-icon-computer",[[0,"rux-icon-computer",{"size":[1]}]]],["rux-icon-confirmation-number",[[0,"rux-icon-confirmation-number",{"size":[1]}]]],["rux-icon-contact-mail",[[0,"rux-icon-contact-mail",{"size":[1]}]]],["rux-icon-contact-phone",[[0,"rux-icon-contact-phone",{"size":[1]}]]],["rux-icon-contact-support",[[0,"rux-icon-contact-support",{"size":[1]}]]],["rux-icon-contacts",[[0,"rux-icon-contacts",{"size":[1]}]]],["rux-icon-control-camera",[[0,"rux-icon-control-camera",{"size":[1]}]]],["rux-icon-control-point",[[0,"rux-icon-control-point",{"size":[1]}]]],["rux-icon-control-point-duplicate",[[0,"rux-icon-control-point-duplicate",{"size":[1]}]]],["rux-icon-copyright",[[0,"rux-icon-copyright",{"size":[1]}]]],["rux-icon-create",[[0,"rux-icon-create",{"size":[1]}]]],["rux-icon-create-new-folder",[[0,"rux-icon-create-new-folder",{"size":[1]}]]],["rux-icon-credit-card",[[0,"rux-icon-credit-card",{"size":[1]}]]],["rux-icon-crop",[[0,"rux-icon-crop",{"size":[1]}]]],["rux-icon-crop-16-9",[[0,"rux-icon-crop-16-9",{"size":[1]}]]],["rux-icon-crop-3-2",[[0,"rux-icon-crop-3-2",{"size":[1]}]]],["rux-icon-crop-5-4",[[0,"rux-icon-crop-5-4",{"size":[1]}]]],["rux-icon-crop-7-5",[[0,"rux-icon-crop-7-5",{"size":[1]}]]],["rux-icon-crop-din",[[0,"rux-icon-crop-din",{"size":[1]}]]],["rux-icon-crop-free",[[0,"rux-icon-crop-free",{"size":[1]}]]],["rux-icon-crop-landscape",[[0,"rux-icon-crop-landscape",{"size":[1]}]]],["rux-icon-crop-original",[[0,"rux-icon-crop-original",{"size":[1]}]]],["rux-icon-crop-portrait",[[0,"rux-icon-crop-portrait",{"size":[1]}]]],["rux-icon-crop-rotate",[[0,"rux-icon-crop-rotate",{"size":[1]}]]],["rux-icon-crop-square",[[0,"rux-icon-crop-square",{"size":[1]}]]],["rux-icon-dashboard",[[0,"rux-icon-dashboard",{"size":[1]}]]],["rux-icon-data-usage",[[0,"rux-icon-data-usage",{"size":[1]}]]],["rux-icon-date-range",[[0,"rux-icon-date-range",{"size":[1]}]]],["rux-icon-dehaze",[[0,"rux-icon-dehaze",{"size":[1]}]]],["rux-icon-delete",[[0,"rux-icon-delete",{"size":[1]}]]],["rux-icon-delete-forever",[[0,"rux-icon-delete-forever",{"size":[1]}]]],["rux-icon-delete-outline",[[0,"rux-icon-delete-outline",{"size":[1]}]]],["rux-icon-delete-sweep",[[0,"rux-icon-delete-sweep",{"size":[1]}]]],["rux-icon-departure-board",[[0,"rux-icon-departure-board",{"size":[1]}]]],["rux-icon-description",[[0,"rux-icon-description",{"size":[1]}]]],["rux-icon-desktop-access-disabled",[[0,"rux-icon-desktop-access-disabled",{"size":[1]}]]],["rux-icon-desktop-mac",[[0,"rux-icon-desktop-mac",{"size":[1]}]]],["rux-icon-desktop-windows",[[0,"rux-icon-desktop-windows",{"size":[1]}]]],["rux-icon-details",[[0,"rux-icon-details",{"size":[1]}]]],["rux-icon-developer-board",[[0,"rux-icon-developer-board",{"size":[1]}]]],["rux-icon-developer-mode",[[0,"rux-icon-developer-mode",{"size":[1]}]]],["rux-icon-device-hub",[[0,"rux-icon-device-hub",{"size":[1]}]]],["rux-icon-device-unknown",[[0,"rux-icon-device-unknown",{"size":[1]}]]],["rux-icon-devices",[[0,"rux-icon-devices",{"size":[1]}]]],["rux-icon-devices-other",[[0,"rux-icon-devices-other",{"size":[1]}]]],["rux-icon-dialer-sip",[[0,"rux-icon-dialer-sip",{"size":[1]}]]],["rux-icon-dialpad",[[0,"rux-icon-dialpad",{"size":[1]}]]],["rux-icon-directions",[[0,"rux-icon-directions",{"size":[1]}]]],["rux-icon-directions-bike",[[0,"rux-icon-directions-bike",{"size":[1]}]]],["rux-icon-directions-boat",[[0,"rux-icon-directions-boat",{"size":[1]}]]],["rux-icon-directions-bus",[[0,"rux-icon-directions-bus",{"size":[1]}]]],["rux-icon-directions-car",[[0,"rux-icon-directions-car",{"size":[1]}]]],["rux-icon-directions-railway",[[0,"rux-icon-directions-railway",{"size":[1]}]]],["rux-icon-directions-run",[[0,"rux-icon-directions-run",{"size":[1]}]]],["rux-icon-directions-subway",[[0,"rux-icon-directions-subway",{"size":[1]}]]],["rux-icon-directions-transit",[[0,"rux-icon-directions-transit",{"size":[1]}]]],["rux-icon-directions-walk",[[0,"rux-icon-directions-walk",{"size":[1]}]]],["rux-icon-disc-full",[[0,"rux-icon-disc-full",{"size":[1]}]]],["rux-icon-dns",[[0,"rux-icon-dns",{"size":[1]}]]],["rux-icon-dock",[[0,"rux-icon-dock",{"size":[1]}]]],["rux-icon-domain",[[0,"rux-icon-domain",{"size":[1]}]]],["rux-icon-domain-disabled",[[0,"rux-icon-domain-disabled",{"size":[1]}]]],["rux-icon-done",[[0,"rux-icon-done",{"size":[1]}]]],["rux-icon-done-all",[[0,"rux-icon-done-all",{"size":[1]}]]],["rux-icon-done-outline",[[0,"rux-icon-done-outline",{"size":[1]}]]],["rux-icon-donut-large",[[0,"rux-icon-donut-large",{"size":[1]}]]],["rux-icon-donut-small",[[0,"rux-icon-donut-small",{"size":[1]}]]],["rux-icon-drafts",[[0,"rux-icon-drafts",{"size":[1]}]]],["rux-icon-drag-handle",[[0,"rux-icon-drag-handle",{"size":[1]}]]],["rux-icon-drag-indicator",[[0,"rux-icon-drag-indicator",{"size":[1]}]]],["rux-icon-drive-eta",[[0,"rux-icon-drive-eta",{"size":[1]}]]],["rux-icon-duo",[[0,"rux-icon-duo",{"size":[1]}]]],["rux-icon-dvr",[[0,"rux-icon-dvr",{"size":[1]}]]],["rux-icon-edit",[[0,"rux-icon-edit",{"size":[1]}]]],["rux-icon-edit-attributes",[[0,"rux-icon-edit-attributes",{"size":[1]}]]],["rux-icon-edit-location",[[0,"rux-icon-edit-location",{"size":[1]}]]],["rux-icon-eject",[[0,"rux-icon-eject",{"size":[1]}]]],["rux-icon-email",[[0,"rux-icon-email",{"size":[1]}]]],["rux-icon-enhanced-encryption",[[0,"rux-icon-enhanced-encryption",{"size":[1]}]]],["rux-icon-equalizer",[[0,"rux-icon-equalizer",{"size":[1]}]]],["rux-icon-equipment",[[0,"rux-icon-equipment",{"size":[1]}]]],["rux-icon-error",[[0,"rux-icon-error",{"size":[1]}]]],["rux-icon-error-outline",[[0,"rux-icon-error-outline",{"size":[1]}]]],["rux-icon-euro-symbol",[[0,"rux-icon-euro-symbol",{"size":[1]}]]],["rux-icon-ev-station",[[0,"rux-icon-ev-station",{"size":[1]}]]],["rux-icon-event",[[0,"rux-icon-event",{"size":[1]}]]],["rux-icon-event-available",[[0,"rux-icon-event-available",{"size":[1]}]]],["rux-icon-event-busy",[[0,"rux-icon-event-busy",{"size":[1]}]]],["rux-icon-event-note",[[0,"rux-icon-event-note",{"size":[1]}]]],["rux-icon-exit-to-app",[[0,"rux-icon-exit-to-app",{"size":[1]}]]],["rux-icon-expand-less",[[0,"rux-icon-expand-less",{"size":[1]}]]],["rux-icon-expand-more",[[0,"rux-icon-expand-more",{"size":[1]}]]],["rux-icon-explicit",[[0,"rux-icon-explicit",{"size":[1]}]]],["rux-icon-explore",[[0,"rux-icon-explore",{"size":[1]}]]],["rux-icon-explore-off",[[0,"rux-icon-explore-off",{"size":[1]}]]],["rux-icon-exposure",[[0,"rux-icon-exposure",{"size":[1]}]]],["rux-icon-exposure-neg-1",[[0,"rux-icon-exposure-neg-1",{"size":[1]}]]],["rux-icon-exposure-neg-2",[[0,"rux-icon-exposure-neg-2",{"size":[1]}]]],["rux-icon-exposure-plus-1",[[0,"rux-icon-exposure-plus-1",{"size":[1]}]]],["rux-icon-exposure-plus-2",[[0,"rux-icon-exposure-plus-2",{"size":[1]}]]],["rux-icon-exposure-zero",[[0,"rux-icon-exposure-zero",{"size":[1]}]]],["rux-icon-extension",[[0,"rux-icon-extension",{"size":[1]}]]],["rux-icon-face",[[0,"rux-icon-face",{"size":[1]}]]],["rux-icon-fast-forward",[[0,"rux-icon-fast-forward",{"size":[1]}]]],["rux-icon-fast-rewind",[[0,"rux-icon-fast-rewind",{"size":[1]}]]],["rux-icon-fastfood",[[0,"rux-icon-fastfood",{"size":[1]}]]],["rux-icon-favorite",[[0,"rux-icon-favorite",{"size":[1]}]]],["rux-icon-favorite-border",[[0,"rux-icon-favorite-border",{"size":[1]}]]],["rux-icon-featured-play-list",[[0,"rux-icon-featured-play-list",{"size":[1]}]]],["rux-icon-featured-video",[[0,"rux-icon-featured-video",{"size":[1]}]]],["rux-icon-feedback",[[0,"rux-icon-feedback",{"size":[1]}]]],["rux-icon-fiber-dvr",[[0,"rux-icon-fiber-dvr",{"size":[1]}]]],["rux-icon-fiber-manual-record",[[0,"rux-icon-fiber-manual-record",{"size":[1]}]]],["rux-icon-fiber-new",[[0,"rux-icon-fiber-new",{"size":[1]}]]],["rux-icon-fiber-pin",[[0,"rux-icon-fiber-pin",{"size":[1]}]]],["rux-icon-fiber-smart-record",[[0,"rux-icon-fiber-smart-record",{"size":[1]}]]],["rux-icon-file-copy",[[0,"rux-icon-file-copy",{"size":[1]}]]],["rux-icon-filter",[[0,"rux-icon-filter",{"size":[1]}]]],["rux-icon-filter-1",[[0,"rux-icon-filter-1",{"size":[1]}]]],["rux-icon-filter-2",[[0,"rux-icon-filter-2",{"size":[1]}]]],["rux-icon-filter-3",[[0,"rux-icon-filter-3",{"size":[1]}]]],["rux-icon-filter-4",[[0,"rux-icon-filter-4",{"size":[1]}]]],["rux-icon-filter-5",[[0,"rux-icon-filter-5",{"size":[1]}]]],["rux-icon-filter-6",[[0,"rux-icon-filter-6",{"size":[1]}]]],["rux-icon-filter-7",[[0,"rux-icon-filter-7",{"size":[1]}]]],["rux-icon-filter-8",[[0,"rux-icon-filter-8",{"size":[1]}]]],["rux-icon-filter-9",[[0,"rux-icon-filter-9",{"size":[1]}]]],["rux-icon-filter-9-plus",[[0,"rux-icon-filter-9-plus",{"size":[1]}]]],["rux-icon-filter-b-and-w",[[0,"rux-icon-filter-b-and-w",{"size":[1]}]]],["rux-icon-filter-center-focus",[[0,"rux-icon-filter-center-focus",{"size":[1]}]]],["rux-icon-filter-drama",[[0,"rux-icon-filter-drama",{"size":[1]}]]],["rux-icon-filter-frames",[[0,"rux-icon-filter-frames",{"size":[1]}]]],["rux-icon-filter-hdr",[[0,"rux-icon-filter-hdr",{"size":[1]}]]],["rux-icon-filter-list",[[0,"rux-icon-filter-list",{"size":[1]}]]],["rux-icon-filter-none",[[0,"rux-icon-filter-none",{"size":[1]}]]],["rux-icon-filter-tilt-shift",[[0,"rux-icon-filter-tilt-shift",{"size":[1]}]]],["rux-icon-filter-vintage",[[0,"rux-icon-filter-vintage",{"size":[1]}]]],["rux-icon-find-in-page",[[0,"rux-icon-find-in-page",{"size":[1]}]]],["rux-icon-find-replace",[[0,"rux-icon-find-replace",{"size":[1]}]]],["rux-icon-fingerprint",[[0,"rux-icon-fingerprint",{"size":[1]}]]],["rux-icon-first-page",[[0,"rux-icon-first-page",{"size":[1]}]]],["rux-icon-fitness-center",[[0,"rux-icon-fitness-center",{"size":[1]}]]],["rux-icon-flag",[[0,"rux-icon-flag",{"size":[1]}]]],["rux-icon-flare",[[0,"rux-icon-flare",{"size":[1]}]]],["rux-icon-flash-auto",[[0,"rux-icon-flash-auto",{"size":[1]}]]],["rux-icon-flash-off",[[0,"rux-icon-flash-off",{"size":[1]}]]],["rux-icon-flash-on",[[0,"rux-icon-flash-on",{"size":[1]}]]],["rux-icon-flight",[[0,"rux-icon-flight",{"size":[1]}]]],["rux-icon-flight-land",[[0,"rux-icon-flight-land",{"size":[1]}]]],["rux-icon-flight-takeoff",[[0,"rux-icon-flight-takeoff",{"size":[1]}]]],["rux-icon-flip",[[0,"rux-icon-flip",{"size":[1]}]]],["rux-icon-flip-to-back",[[0,"rux-icon-flip-to-back",{"size":[1]}]]],["rux-icon-flip-to-front",[[0,"rux-icon-flip-to-front",{"size":[1]}]]],["rux-icon-folder",[[0,"rux-icon-folder",{"size":[1]}]]],["rux-icon-folder-open",[[0,"rux-icon-folder-open",{"size":[1]}]]],["rux-icon-folder-shared",[[0,"rux-icon-folder-shared",{"size":[1]}]]],["rux-icon-folder-special",[[0,"rux-icon-folder-special",{"size":[1]}]]],["rux-icon-font-download",[[0,"rux-icon-font-download",{"size":[1]}]]],["rux-icon-format-align-center",[[0,"rux-icon-format-align-center",{"size":[1]}]]],["rux-icon-format-align-justify",[[0,"rux-icon-format-align-justify",{"size":[1]}]]],["rux-icon-format-align-left",[[0,"rux-icon-format-align-left",{"size":[1]}]]],["rux-icon-format-align-right",[[0,"rux-icon-format-align-right",{"size":[1]}]]],["rux-icon-format-bold",[[0,"rux-icon-format-bold",{"size":[1]}]]],["rux-icon-format-clear",[[0,"rux-icon-format-clear",{"size":[1]}]]],["rux-icon-format-color-fill",[[0,"rux-icon-format-color-fill",{"size":[1]}]]],["rux-icon-format-color-reset",[[0,"rux-icon-format-color-reset",{"size":[1]}]]],["rux-icon-format-color-text",[[0,"rux-icon-format-color-text",{"size":[1]}]]],["rux-icon-format-indent-decrease",[[0,"rux-icon-format-indent-decrease",{"size":[1]}]]],["rux-icon-format-indent-increase",[[0,"rux-icon-format-indent-increase",{"size":[1]}]]],["rux-icon-format-italic",[[0,"rux-icon-format-italic",{"size":[1]}]]],["rux-icon-format-line-spacing",[[0,"rux-icon-format-line-spacing",{"size":[1]}]]],["rux-icon-format-list-bulleted",[[0,"rux-icon-format-list-bulleted",{"size":[1]}]]],["rux-icon-format-list-numbered",[[0,"rux-icon-format-list-numbered",{"size":[1]}]]],["rux-icon-format-list-numbered-rtl",[[0,"rux-icon-format-list-numbered-rtl",{"size":[1]}]]],["rux-icon-format-paint",[[0,"rux-icon-format-paint",{"size":[1]}]]],["rux-icon-format-quote",[[0,"rux-icon-format-quote",{"size":[1]}]]],["rux-icon-format-shapes",[[0,"rux-icon-format-shapes",{"size":[1]}]]],["rux-icon-format-size",[[0,"rux-icon-format-size",{"size":[1]}]]],["rux-icon-format-strikethrough",[[0,"rux-icon-format-strikethrough",{"size":[1]}]]],["rux-icon-format-textdirection-l-to-r",[[0,"rux-icon-format-textdirection-l-to-r",{"size":[1]}]]],["rux-icon-format-textdirection-r-to-l",[[0,"rux-icon-format-textdirection-r-to-l",{"size":[1]}]]],["rux-icon-format-underlined",[[0,"rux-icon-format-underlined",{"size":[1]}]]],["rux-icon-forum",[[0,"rux-icon-forum",{"size":[1]}]]],["rux-icon-forward",[[0,"rux-icon-forward",{"size":[1]}]]],["rux-icon-forward-10",[[0,"rux-icon-forward-10",{"size":[1]}]]],["rux-icon-forward-30",[[0,"rux-icon-forward-30",{"size":[1]}]]],["rux-icon-forward-5",[[0,"rux-icon-forward-5",{"size":[1]}]]],["rux-icon-free-breakfast",[[0,"rux-icon-free-breakfast",{"size":[1]}]]],["rux-icon-fullscreen",[[0,"rux-icon-fullscreen",{"size":[1]}]]],["rux-icon-fullscreen-exit",[[0,"rux-icon-fullscreen-exit",{"size":[1]}]]],["rux-icon-functions",[[0,"rux-icon-functions",{"size":[1]}]]],["rux-icon-g-translate",[[0,"rux-icon-g-translate",{"size":[1]}]]],["rux-icon-gamepad",[[0,"rux-icon-gamepad",{"size":[1]}]]],["rux-icon-games",[[0,"rux-icon-games",{"size":[1]}]]],["rux-icon-gavel",[[0,"rux-icon-gavel",{"size":[1]}]]],["rux-icon-gesture",[[0,"rux-icon-gesture",{"size":[1]}]]],["rux-icon-get-app",[[0,"rux-icon-get-app",{"size":[1]}]]],["rux-icon-gif",[[0,"rux-icon-gif",{"size":[1]}]]],["rux-icon-golf-course",[[0,"rux-icon-golf-course",{"size":[1]}]]],["rux-icon-gps-fixed",[[0,"rux-icon-gps-fixed",{"size":[1]}]]],["rux-icon-gps-not-fixed",[[0,"rux-icon-gps-not-fixed",{"size":[1]}]]],["rux-icon-gps-off",[[0,"rux-icon-gps-off",{"size":[1]}]]],["rux-icon-grade",[[0,"rux-icon-grade",{"size":[1]}]]],["rux-icon-gradient",[[0,"rux-icon-gradient",{"size":[1]}]]],["rux-icon-grain",[[0,"rux-icon-grain",{"size":[1]}]]],["rux-icon-graphic-eq",[[0,"rux-icon-graphic-eq",{"size":[1]}]]],["rux-icon-grid-off",[[0,"rux-icon-grid-off",{"size":[1]}]]],["rux-icon-grid-on",[[0,"rux-icon-grid-on",{"size":[1]}]]],["rux-icon-group",[[0,"rux-icon-group",{"size":[1]}]]],["rux-icon-group-add",[[0,"rux-icon-group-add",{"size":[1]}]]],["rux-icon-group-work",[[0,"rux-icon-group-work",{"size":[1]}]]],["rux-icon-hardware",[[0,"rux-icon-hardware",{"size":[1]}]]],["rux-icon-hd",[[0,"rux-icon-hd",{"size":[1]}]]],["rux-icon-hdr-off",[[0,"rux-icon-hdr-off",{"size":[1]}]]],["rux-icon-hdr-on",[[0,"rux-icon-hdr-on",{"size":[1]}]]],["rux-icon-hdr-strong",[[0,"rux-icon-hdr-strong",{"size":[1]}]]],["rux-icon-hdr-weak",[[0,"rux-icon-hdr-weak",{"size":[1]}]]],["rux-icon-headset",[[0,"rux-icon-headset",{"size":[1]}]]],["rux-icon-headset-mic",[[0,"rux-icon-headset-mic",{"size":[1]}]]],["rux-icon-healing",[[0,"rux-icon-healing",{"size":[1]}]]],["rux-icon-hearing",[[0,"rux-icon-hearing",{"size":[1]}]]],["rux-icon-help",[[0,"rux-icon-help",{"size":[1]}]]],["rux-icon-help-outline",[[0,"rux-icon-help-outline",{"size":[1]}]]],["rux-icon-high-quality",[[0,"rux-icon-high-quality",{"size":[1]}]]],["rux-icon-highlight",[[0,"rux-icon-highlight",{"size":[1]}]]],["rux-icon-highlight-off",[[0,"rux-icon-highlight-off",{"size":[1]}]]],["rux-icon-history",[[0,"rux-icon-history",{"size":[1]}]]],["rux-icon-home",[[0,"rux-icon-home",{"size":[1]}]]],["rux-icon-horizontal-split",[[0,"rux-icon-horizontal-split",{"size":[1]}]]],["rux-icon-hot-tub",[[0,"rux-icon-hot-tub",{"size":[1]}]]],["rux-icon-hotel",[[0,"rux-icon-hotel",{"size":[1]}]]],["rux-icon-hourglass-empty",[[0,"rux-icon-hourglass-empty",{"size":[1]}]]],["rux-icon-hourglass-full",[[0,"rux-icon-hourglass-full",{"size":[1]}]]],["rux-icon-how-to-reg",[[0,"rux-icon-how-to-reg",{"size":[1]}]]],["rux-icon-how-to-vote",[[0,"rux-icon-how-to-vote",{"size":[1]}]]],["rux-icon-http",[[0,"rux-icon-http",{"size":[1]}]]],["rux-icon-https",[[0,"rux-icon-https",{"size":[1]}]]],["rux-icon-image",[[0,"rux-icon-image",{"size":[1]}]]],["rux-icon-image-aspect-ratio",[[0,"rux-icon-image-aspect-ratio",{"size":[1]}]]],["rux-icon-image-search",[[0,"rux-icon-image-search",{"size":[1]}]]],["rux-icon-import-contacts",[[0,"rux-icon-import-contacts",{"size":[1]}]]],["rux-icon-import-export",[[0,"rux-icon-import-export",{"size":[1]}]]],["rux-icon-important-devices",[[0,"rux-icon-important-devices",{"size":[1]}]]],["rux-icon-inbox",[[0,"rux-icon-inbox",{"size":[1]}]]],["rux-icon-indeterminate-check-box",[[0,"rux-icon-indeterminate-check-box",{"size":[1]}]]],["rux-icon-info",[[0,"rux-icon-info",{"size":[1]}]]],["rux-icon-input",[[0,"rux-icon-input",{"size":[1]}]]],["rux-icon-insert-chart",[[0,"rux-icon-insert-chart",{"size":[1]}]]],["rux-icon-insert-chart-outlined",[[0,"rux-icon-insert-chart-outlined",{"size":[1]}]]],["rux-icon-insert-comment",[[0,"rux-icon-insert-comment",{"size":[1]}]]],["rux-icon-insert-drive-file",[[0,"rux-icon-insert-drive-file",{"size":[1]}]]],["rux-icon-insert-emoticon",[[0,"rux-icon-insert-emoticon",{"size":[1]}]]],["rux-icon-insert-invitation",[[0,"rux-icon-insert-invitation",{"size":[1]}]]],["rux-icon-insert-link",[[0,"rux-icon-insert-link",{"size":[1]}]]],["rux-icon-insert-photo",[[0,"rux-icon-insert-photo",{"size":[1]}]]],["rux-icon-invert-colors",[[0,"rux-icon-invert-colors",{"size":[1]}]]],["rux-icon-invert-colors-off",[[0,"rux-icon-invert-colors-off",{"size":[1]}]]],["rux-icon-iso",[[0,"rux-icon-iso",{"size":[1]}]]],["rux-icon-keyboard",[[0,"rux-icon-keyboard",{"size":[1]}]]],["rux-icon-keyboard-arrow-down",[[0,"rux-icon-keyboard-arrow-down",{"size":[1]}]]],["rux-icon-keyboard-arrow-left",[[0,"rux-icon-keyboard-arrow-left",{"size":[1]}]]],["rux-icon-keyboard-arrow-right",[[0,"rux-icon-keyboard-arrow-right",{"size":[1]}]]],["rux-icon-keyboard-arrow-up",[[0,"rux-icon-keyboard-arrow-up",{"size":[1]}]]],["rux-icon-keyboard-backspace",[[0,"rux-icon-keyboard-backspace",{"size":[1]}]]],["rux-icon-keyboard-capslock",[[0,"rux-icon-keyboard-capslock",{"size":[1]}]]],["rux-icon-keyboard-hide",[[0,"rux-icon-keyboard-hide",{"size":[1]}]]],["rux-icon-keyboard-return",[[0,"rux-icon-keyboard-return",{"size":[1]}]]],["rux-icon-keyboard-tab",[[0,"rux-icon-keyboard-tab",{"size":[1]}]]],["rux-icon-keyboard-voice",[[0,"rux-icon-keyboard-voice",{"size":[1]}]]],["rux-icon-kitchen",[[0,"rux-icon-kitchen",{"size":[1]}]]],["rux-icon-label",[[0,"rux-icon-label",{"size":[1]}]]],["rux-icon-label-important",[[0,"rux-icon-label-important",{"size":[1]}]]],["rux-icon-label-off",[[0,"rux-icon-label-off",{"size":[1]}]]],["rux-icon-landscape",[[0,"rux-icon-landscape",{"size":[1]}]]],["rux-icon-language",[[0,"rux-icon-language",{"size":[1]}]]],["rux-icon-laptop",[[0,"rux-icon-laptop",{"size":[1]}]]],["rux-icon-laptop-chromebook",[[0,"rux-icon-laptop-chromebook",{"size":[1]}]]],["rux-icon-laptop-mac",[[0,"rux-icon-laptop-mac",{"size":[1]}]]],["rux-icon-laptop-windows",[[0,"rux-icon-laptop-windows",{"size":[1]}]]],["rux-icon-last-page",[[0,"rux-icon-last-page",{"size":[1]}]]],["rux-icon-launch",[[0,"rux-icon-launch",{"size":[1]}]]],["rux-icon-layers",[[0,"rux-icon-layers",{"size":[1]}]]],["rux-icon-layers-clear",[[0,"rux-icon-layers-clear",{"size":[1]}]]],["rux-icon-leak-add",[[0,"rux-icon-leak-add",{"size":[1]}]]],["rux-icon-leak-remove",[[0,"rux-icon-leak-remove",{"size":[1]}]]],["rux-icon-lens",[[0,"rux-icon-lens",{"size":[1]}]]],["rux-icon-library-add",[[0,"rux-icon-library-add",{"size":[1]}]]],["rux-icon-library-books",[[0,"rux-icon-library-books",{"size":[1]}]]],["rux-icon-library-music",[[0,"rux-icon-library-music",{"size":[1]}]]],["rux-icon-line-style",[[0,"rux-icon-line-style",{"size":[1]}]]],["rux-icon-line-weight",[[0,"rux-icon-line-weight",{"size":[1]}]]],["rux-icon-linear-scale",[[0,"rux-icon-linear-scale",{"size":[1]}]]],["rux-icon-link",[[0,"rux-icon-link",{"size":[1]}]]],["rux-icon-link-off",[[0,"rux-icon-link-off",{"size":[1]}]]],["rux-icon-linked-camera",[[0,"rux-icon-linked-camera",{"size":[1]}]]],["rux-icon-list",[[0,"rux-icon-list",{"size":[1]}]]],["rux-icon-list-alt",[[0,"rux-icon-list-alt",{"size":[1]}]]],["rux-icon-live-help",[[0,"rux-icon-live-help",{"size":[1]}]]],["rux-icon-live-tv",[[0,"rux-icon-live-tv",{"size":[1]}]]],["rux-icon-local-activity",[[0,"rux-icon-local-activity",{"size":[1]}]]],["rux-icon-local-airport",[[0,"rux-icon-local-airport",{"size":[1]}]]],["rux-icon-local-atm",[[0,"rux-icon-local-atm",{"size":[1]}]]],["rux-icon-local-bar",[[0,"rux-icon-local-bar",{"size":[1]}]]],["rux-icon-local-cafe",[[0,"rux-icon-local-cafe",{"size":[1]}]]],["rux-icon-local-car-wash",[[0,"rux-icon-local-car-wash",{"size":[1]}]]],["rux-icon-local-convenience-store",[[0,"rux-icon-local-convenience-store",{"size":[1]}]]],["rux-icon-local-dining",[[0,"rux-icon-local-dining",{"size":[1]}]]],["rux-icon-local-drink",[[0,"rux-icon-local-drink",{"size":[1]}]]],["rux-icon-local-gas-station",[[0,"rux-icon-local-gas-station",{"size":[1]}]]],["rux-icon-local-grocery-store",[[0,"rux-icon-local-grocery-store",{"size":[1]}]]],["rux-icon-local-hospital",[[0,"rux-icon-local-hospital",{"size":[1]}]]],["rux-icon-local-hotel",[[0,"rux-icon-local-hotel",{"size":[1]}]]],["rux-icon-local-laundry-service",[[0,"rux-icon-local-laundry-service",{"size":[1]}]]],["rux-icon-local-library",[[0,"rux-icon-local-library",{"size":[1]}]]],["rux-icon-local-mall",[[0,"rux-icon-local-mall",{"size":[1]}]]],["rux-icon-local-movies",[[0,"rux-icon-local-movies",{"size":[1]}]]],["rux-icon-local-offer",[[0,"rux-icon-local-offer",{"size":[1]}]]],["rux-icon-local-parking",[[0,"rux-icon-local-parking",{"size":[1]}]]],["rux-icon-local-pharmacy",[[0,"rux-icon-local-pharmacy",{"size":[1]}]]],["rux-icon-local-phone",[[0,"rux-icon-local-phone",{"size":[1]}]]],["rux-icon-local-play",[[0,"rux-icon-local-play",{"size":[1]}]]],["rux-icon-local-post-office",[[0,"rux-icon-local-post-office",{"size":[1]}]]],["rux-icon-local-printshop",[[0,"rux-icon-local-printshop",{"size":[1]}]]],["rux-icon-local-see",[[0,"rux-icon-local-see",{"size":[1]}]]],["rux-icon-local-shipping",[[0,"rux-icon-local-shipping",{"size":[1]}]]],["rux-icon-local-taxi",[[0,"rux-icon-local-taxi",{"size":[1]}]]],["rux-icon-location-city",[[0,"rux-icon-location-city",{"size":[1]}]]],["rux-icon-location-disabled",[[0,"rux-icon-location-disabled",{"size":[1]}]]],["rux-icon-location-off",[[0,"rux-icon-location-off",{"size":[1]}]]],["rux-icon-location-on",[[0,"rux-icon-location-on",{"size":[1]}]]],["rux-icon-location-searching",[[0,"rux-icon-location-searching",{"size":[1]}]]],["rux-icon-lock",[[0,"rux-icon-lock",{"size":[1]}]]],["rux-icon-lock-open",[[0,"rux-icon-lock-open",{"size":[1]}]]],["rux-icon-looks",[[0,"rux-icon-looks",{"size":[1]}]]],["rux-icon-looks-1",[[0,"rux-icon-looks-1",{"size":[1]}]]],["rux-icon-looks-2",[[0,"rux-icon-looks-2",{"size":[1]}]]],["rux-icon-looks-3",[[0,"rux-icon-looks-3",{"size":[1]}]]],["rux-icon-looks-4",[[0,"rux-icon-looks-4",{"size":[1]}]]],["rux-icon-looks-5",[[0,"rux-icon-looks-5",{"size":[1]}]]],["rux-icon-looks-6",[[0,"rux-icon-looks-6",{"size":[1]}]]],["rux-icon-loop",[[0,"rux-icon-loop",{"size":[1]}]]],["rux-icon-loupe",[[0,"rux-icon-loupe",{"size":[1]}]]],["rux-icon-low-priority",[[0,"rux-icon-low-priority",{"size":[1]}]]],["rux-icon-loyalty",[[0,"rux-icon-loyalty",{"size":[1]}]]],["rux-icon-mail",[[0,"rux-icon-mail",{"size":[1]}]]],["rux-icon-mail-outline",[[0,"rux-icon-mail-outline",{"size":[1]}]]],["rux-icon-map",[[0,"rux-icon-map",{"size":[1]}]]],["rux-icon-markunread",[[0,"rux-icon-markunread",{"size":[1]}]]],["rux-icon-markunread-mailbox",[[0,"rux-icon-markunread-mailbox",{"size":[1]}]]],["rux-icon-maximize",[[0,"rux-icon-maximize",{"size":[1]}]]],["rux-icon-meeting-room",[[0,"rux-icon-meeting-room",{"size":[1]}]]],["rux-icon-memory",[[0,"rux-icon-memory",{"size":[1]}]]],["rux-icon-menu",[[0,"rux-icon-menu",{"size":[1]}]]],["rux-icon-merge-type",[[0,"rux-icon-merge-type",{"size":[1]}]]],["rux-icon-message",[[0,"rux-icon-message",{"size":[1]}]]],["rux-icon-mic",[[0,"rux-icon-mic",{"size":[1]}]]],["rux-icon-mic-none",[[0,"rux-icon-mic-none",{"size":[1]}]]],["rux-icon-mic-off",[[0,"rux-icon-mic-off",{"size":[1]}]]],["rux-icon-minimize",[[0,"rux-icon-minimize",{"size":[1]}]]],["rux-icon-missed-video-call",[[0,"rux-icon-missed-video-call",{"size":[1]}]]],["rux-icon-mission",[[0,"rux-icon-mission",{"size":[1]}]]],["rux-icon-mms",[[0,"rux-icon-mms",{"size":[1]}]]],["rux-icon-mobile-friendly",[[0,"rux-icon-mobile-friendly",{"size":[1]}]]],["rux-icon-mobile-off",[[0,"rux-icon-mobile-off",{"size":[1]}]]],["rux-icon-mobile-screen-share",[[0,"rux-icon-mobile-screen-share",{"size":[1]}]]],["rux-icon-mode-comment",[[0,"rux-icon-mode-comment",{"size":[1]}]]],["rux-icon-monetization-on",[[0,"rux-icon-monetization-on",{"size":[1]}]]],["rux-icon-money",[[0,"rux-icon-money",{"size":[1]}]]],["rux-icon-money-off",[[0,"rux-icon-money-off",{"size":[1]}]]],["rux-icon-monochrome-photos",[[0,"rux-icon-monochrome-photos",{"size":[1]}]]],["rux-icon-mood",[[0,"rux-icon-mood",{"size":[1]}]]],["rux-icon-mood-bad",[[0,"rux-icon-mood-bad",{"size":[1]}]]],["rux-icon-more",[[0,"rux-icon-more",{"size":[1]}]]],["rux-icon-more-horiz",[[0,"rux-icon-more-horiz",{"size":[1]}]]],["rux-icon-more-vert",[[0,"rux-icon-more-vert",{"size":[1]}]]],["rux-icon-motorcycle",[[0,"rux-icon-motorcycle",{"size":[1]}]]],["rux-icon-mouse",[[0,"rux-icon-mouse",{"size":[1]}]]],["rux-icon-move-to-inbox",[[0,"rux-icon-move-to-inbox",{"size":[1]}]]],["rux-icon-movie",[[0,"rux-icon-movie",{"size":[1]}]]],["rux-icon-movie-creation",[[0,"rux-icon-movie-creation",{"size":[1]}]]],["rux-icon-movie-filter",[[0,"rux-icon-movie-filter",{"size":[1]}]]],["rux-icon-multiline-chart",[[0,"rux-icon-multiline-chart",{"size":[1]}]]],["rux-icon-music-note",[[0,"rux-icon-music-note",{"size":[1]}]]],["rux-icon-music-off",[[0,"rux-icon-music-off",{"size":[1]}]]],["rux-icon-music-video",[[0,"rux-icon-music-video",{"size":[1]}]]],["rux-icon-my-location",[[0,"rux-icon-my-location",{"size":[1]}]]],["rux-icon-nature",[[0,"rux-icon-nature",{"size":[1]}]]],["rux-icon-nature-people",[[0,"rux-icon-nature-people",{"size":[1]}]]],["rux-icon-navigate-before",[[0,"rux-icon-navigate-before",{"size":[1]}]]],["rux-icon-navigate-next",[[0,"rux-icon-navigate-next",{"size":[1]}]]],["rux-icon-navigation",[[0,"rux-icon-navigation",{"size":[1]}]]],["rux-icon-near-me",[[0,"rux-icon-near-me",{"size":[1]}]]],["rux-icon-netcom",[[0,"rux-icon-netcom",{"size":[1]}]]],["rux-icon-network-cell",[[0,"rux-icon-network-cell",{"size":[1]}]]],["rux-icon-network-check",[[0,"rux-icon-network-check",{"size":[1]}]]],["rux-icon-network-locked",[[0,"rux-icon-network-locked",{"size":[1]}]]],["rux-icon-network-wifi",[[0,"rux-icon-network-wifi",{"size":[1]}]]],["rux-icon-new-releases",[[0,"rux-icon-new-releases",{"size":[1]}]]],["rux-icon-next-week",[[0,"rux-icon-next-week",{"size":[1]}]]],["rux-icon-nfc",[[0,"rux-icon-nfc",{"size":[1]}]]],["rux-icon-no-encryption",[[0,"rux-icon-no-encryption",{"size":[1]}]]],["rux-icon-no-meeting-room",[[0,"rux-icon-no-meeting-room",{"size":[1]}]]],["rux-icon-no-sim",[[0,"rux-icon-no-sim",{"size":[1]}]]],["rux-icon-not-interested",[[0,"rux-icon-not-interested",{"size":[1]}]]],["rux-icon-not-listed-location",[[0,"rux-icon-not-listed-location",{"size":[1]}]]],["rux-icon-note",[[0,"rux-icon-note",{"size":[1]}]]],["rux-icon-note-add",[[0,"rux-icon-note-add",{"size":[1]}]]],["rux-icon-notes",[[0,"rux-icon-notes",{"size":[1]}]]],["rux-icon-notification-important",[[0,"rux-icon-notification-important",{"size":[1]}]]],["rux-icon-notifications",[[0,"rux-icon-notifications",{"size":[1]}]]],["rux-icon-notifications-active",[[0,"rux-icon-notifications-active",{"size":[1]}]]],["rux-icon-notifications-none",[[0,"rux-icon-notifications-none",{"size":[1]}]]],["rux-icon-notifications-off",[[0,"rux-icon-notifications-off",{"size":[1]}]]],["rux-icon-notifications-paused",[[0,"rux-icon-notifications-paused",{"size":[1]}]]],["rux-icon-offline-bolt",[[0,"rux-icon-offline-bolt",{"size":[1]}]]],["rux-icon-offline-pin",[[0,"rux-icon-offline-pin",{"size":[1]}]]],["rux-icon-ondemand-video",[[0,"rux-icon-ondemand-video",{"size":[1]}]]],["rux-icon-opacity",[[0,"rux-icon-opacity",{"size":[1]}]]],["rux-icon-open-in-browser",[[0,"rux-icon-open-in-browser",{"size":[1]}]]],["rux-icon-open-in-new",[[0,"rux-icon-open-in-new",{"size":[1]}]]],["rux-icon-open-with",[[0,"rux-icon-open-with",{"size":[1]}]]],["rux-icon-outlined-flag",[[0,"rux-icon-outlined-flag",{"size":[1]}]]],["rux-icon-pages",[[0,"rux-icon-pages",{"size":[1]}]]],["rux-icon-pageview",[[0,"rux-icon-pageview",{"size":[1]}]]],["rux-icon-palette",[[0,"rux-icon-palette",{"size":[1]}]]],["rux-icon-pan-tool",[[0,"rux-icon-pan-tool",{"size":[1]}]]],["rux-icon-panorama",[[0,"rux-icon-panorama",{"size":[1]}]]],["rux-icon-panorama-fish-eye",[[0,"rux-icon-panorama-fish-eye",{"size":[1]}]]],["rux-icon-panorama-horizontal",[[0,"rux-icon-panorama-horizontal",{"size":[1]}]]],["rux-icon-panorama-vertical",[[0,"rux-icon-panorama-vertical",{"size":[1]}]]],["rux-icon-panorama-wide-angle",[[0,"rux-icon-panorama-wide-angle",{"size":[1]}]]],["rux-icon-party-mode",[[0,"rux-icon-party-mode",{"size":[1]}]]],["rux-icon-pause",[[0,"rux-icon-pause",{"size":[1]}]]],["rux-icon-pause-circle-filled",[[0,"rux-icon-pause-circle-filled",{"size":[1]}]]],["rux-icon-pause-circle-outline",[[0,"rux-icon-pause-circle-outline",{"size":[1]}]]],["rux-icon-pause-presentation",[[0,"rux-icon-pause-presentation",{"size":[1]}]]],["rux-icon-payload",[[0,"rux-icon-payload",{"size":[1]}]]],["rux-icon-payment",[[0,"rux-icon-payment",{"size":[1]}]]],["rux-icon-people-outline",[[0,"rux-icon-people-outline",{"size":[1]}]]],["rux-icon-perm-camera-mic",[[0,"rux-icon-perm-camera-mic",{"size":[1]}]]],["rux-icon-perm-contact-calendar",[[0,"rux-icon-perm-contact-calendar",{"size":[1]}]]],["rux-icon-perm-data-setting",[[0,"rux-icon-perm-data-setting",{"size":[1]}]]],["rux-icon-perm-device-information",[[0,"rux-icon-perm-device-information",{"size":[1]}]]],["rux-icon-perm-identity",[[0,"rux-icon-perm-identity",{"size":[1]}]]],["rux-icon-perm-media",[[0,"rux-icon-perm-media",{"size":[1]}]]],["rux-icon-perm-phone-msg",[[0,"rux-icon-perm-phone-msg",{"size":[1]}]]],["rux-icon-perm-scan-wifi",[[0,"rux-icon-perm-scan-wifi",{"size":[1]}]]],["rux-icon-person",[[0,"rux-icon-person",{"size":[1]}]]],["rux-icon-person-add",[[0,"rux-icon-person-add",{"size":[1]}]]],["rux-icon-person-add-disabled",[[0,"rux-icon-person-add-disabled",{"size":[1]}]]],["rux-icon-person-outline",[[0,"rux-icon-person-outline",{"size":[1]}]]],["rux-icon-person-pin",[[0,"rux-icon-person-pin",{"size":[1]}]]],["rux-icon-person-pin-circle",[[0,"rux-icon-person-pin-circle",{"size":[1]}]]],["rux-icon-personal-video",[[0,"rux-icon-personal-video",{"size":[1]}]]],["rux-icon-pets",[[0,"rux-icon-pets",{"size":[1]}]]],["rux-icon-phone",[[0,"rux-icon-phone",{"size":[1]}]]],["rux-icon-phone-android",[[0,"rux-icon-phone-android",{"size":[1]}]]],["rux-icon-phone-bluetooth-speaker",[[0,"rux-icon-phone-bluetooth-speaker",{"size":[1]}]]],["rux-icon-phone-callback",[[0,"rux-icon-phone-callback",{"size":[1]}]]],["rux-icon-phone-forwarded",[[0,"rux-icon-phone-forwarded",{"size":[1]}]]],["rux-icon-phone-in-talk",[[0,"rux-icon-phone-in-talk",{"size":[1]}]]],["rux-icon-phone-iphone",[[0,"rux-icon-phone-iphone",{"size":[1]}]]],["rux-icon-phone-locked",[[0,"rux-icon-phone-locked",{"size":[1]}]]],["rux-icon-phone-missed",[[0,"rux-icon-phone-missed",{"size":[1]}]]],["rux-icon-phone-paused",[[0,"rux-icon-phone-paused",{"size":[1]}]]],["rux-icon-phonelink",[[0,"rux-icon-phonelink",{"size":[1]}]]],["rux-icon-phonelink-erase",[[0,"rux-icon-phonelink-erase",{"size":[1]}]]],["rux-icon-phonelink-lock",[[0,"rux-icon-phonelink-lock",{"size":[1]}]]],["rux-icon-phonelink-off",[[0,"rux-icon-phonelink-off",{"size":[1]}]]],["rux-icon-phonelink-ring",[[0,"rux-icon-phonelink-ring",{"size":[1]}]]],["rux-icon-phonelink-setup",[[0,"rux-icon-phonelink-setup",{"size":[1]}]]],["rux-icon-photo",[[0,"rux-icon-photo",{"size":[1]}]]],["rux-icon-photo-album",[[0,"rux-icon-photo-album",{"size":[1]}]]],["rux-icon-photo-camera",[[0,"rux-icon-photo-camera",{"size":[1]}]]],["rux-icon-photo-filter",[[0,"rux-icon-photo-filter",{"size":[1]}]]],["rux-icon-photo-library",[[0,"rux-icon-photo-library",{"size":[1]}]]],["rux-icon-photo-size-select-actual",[[0,"rux-icon-photo-size-select-actual",{"size":[1]}]]],["rux-icon-photo-size-select-large",[[0,"rux-icon-photo-size-select-large",{"size":[1]}]]],["rux-icon-photo-size-select-small",[[0,"rux-icon-photo-size-select-small",{"size":[1]}]]],["rux-icon-picture-as-pdf",[[0,"rux-icon-picture-as-pdf",{"size":[1]}]]],["rux-icon-picture-in-picture",[[0,"rux-icon-picture-in-picture",{"size":[1]}]]],["rux-icon-picture-in-picture-alt",[[0,"rux-icon-picture-in-picture-alt",{"size":[1]}]]],["rux-icon-pie-chart",[[0,"rux-icon-pie-chart",{"size":[1]}]]],["rux-icon-pin-drop",[[0,"rux-icon-pin-drop",{"size":[1]}]]],["rux-icon-place",[[0,"rux-icon-place",{"size":[1]}]]],["rux-icon-play-arrow",[[0,"rux-icon-play-arrow",{"size":[1]}]]],["rux-icon-play-circle-filled",[[0,"rux-icon-play-circle-filled",{"size":[1]}]]],["rux-icon-play-circle-filled-white",[[0,"rux-icon-play-circle-filled-white",{"size":[1]}]]],["rux-icon-play-circle-outline",[[0,"rux-icon-play-circle-outline",{"size":[1]}]]],["rux-icon-play-for-work",[[0,"rux-icon-play-for-work",{"size":[1]}]]],["rux-icon-playlist-add",[[0,"rux-icon-playlist-add",{"size":[1]}]]],["rux-icon-playlist-add-check",[[0,"rux-icon-playlist-add-check",{"size":[1]}]]],["rux-icon-playlist-play",[[0,"rux-icon-playlist-play",{"size":[1]}]]],["rux-icon-plus-one",[[0,"rux-icon-plus-one",{"size":[1]}]]],["rux-icon-poll",[[0,"rux-icon-poll",{"size":[1]}]]],["rux-icon-pool",[[0,"rux-icon-pool",{"size":[1]}]]],["rux-icon-portable-wifi-off",[[0,"rux-icon-portable-wifi-off",{"size":[1]}]]],["rux-icon-portrait",[[0,"rux-icon-portrait",{"size":[1]}]]],["rux-icon-power",[[0,"rux-icon-power",{"size":[1]}]]],["rux-icon-power-input",[[0,"rux-icon-power-input",{"size":[1]}]]],["rux-icon-power-off",[[0,"rux-icon-power-off",{"size":[1]}]]],["rux-icon-power-settings-new",[[0,"rux-icon-power-settings-new",{"size":[1]}]]],["rux-icon-pregnant-woman",[[0,"rux-icon-pregnant-woman",{"size":[1]}]]],["rux-icon-present-to-all",[[0,"rux-icon-present-to-all",{"size":[1]}]]],["rux-icon-print",[[0,"rux-icon-print",{"size":[1]}]]],["rux-icon-print-disabled",[[0,"rux-icon-print-disabled",{"size":[1]}]]],["rux-icon-priority-high",[[0,"rux-icon-priority-high",{"size":[1]}]]],["rux-icon-processor",[[0,"rux-icon-processor",{"size":[1]}]]],["rux-icon-processor-alt",[[0,"rux-icon-processor-alt",{"size":[1]}]]],["rux-icon-propulsion-power",[[0,"rux-icon-propulsion-power",{"size":[1]}]]],["rux-icon-public",[[0,"rux-icon-public",{"size":[1]}]]],["rux-icon-publish",[[0,"rux-icon-publish",{"size":[1]}]]],["rux-icon-query-builder",[[0,"rux-icon-query-builder",{"size":[1]}]]],["rux-icon-question-answer",[[0,"rux-icon-question-answer",{"size":[1]}]]],["rux-icon-queue",[[0,"rux-icon-queue",{"size":[1]}]]],["rux-icon-queue-music",[[0,"rux-icon-queue-music",{"size":[1]}]]],["rux-icon-queue-play-next",[[0,"rux-icon-queue-play-next",{"size":[1]}]]],["rux-icon-radio",[[0,"rux-icon-radio",{"size":[1]}]]],["rux-icon-radio-button-checked",[[0,"rux-icon-radio-button-checked",{"size":[1]}]]],["rux-icon-radio-button-unchecked",[[0,"rux-icon-radio-button-unchecked",{"size":[1]}]]],["rux-icon-rate-review",[[0,"rux-icon-rate-review",{"size":[1]}]]],["rux-icon-receipt",[[0,"rux-icon-receipt",{"size":[1]}]]],["rux-icon-recent-actors",[[0,"rux-icon-recent-actors",{"size":[1]}]]],["rux-icon-record-voice-over",[[0,"rux-icon-record-voice-over",{"size":[1]}]]],["rux-icon-redeem",[[0,"rux-icon-redeem",{"size":[1]}]]],["rux-icon-redo",[[0,"rux-icon-redo",{"size":[1]}]]],["rux-icon-refresh",[[0,"rux-icon-refresh",{"size":[1]}]]],["rux-icon-release",[[0,"rux-icon-release",{"size":[1]}]]],["rux-icon-remove",[[0,"rux-icon-remove",{"size":[1]}]]],["rux-icon-remove-circle",[[0,"rux-icon-remove-circle",{"size":[1]}]]],["rux-icon-remove-circle-outline",[[0,"rux-icon-remove-circle-outline",{"size":[1]}]]],["rux-icon-remove-from-queue",[[0,"rux-icon-remove-from-queue",{"size":[1]}]]],["rux-icon-remove-red-eye",[[0,"rux-icon-remove-red-eye",{"size":[1]}]]],["rux-icon-remove-shopping-cart",[[0,"rux-icon-remove-shopping-cart",{"size":[1]}]]],["rux-icon-reorder",[[0,"rux-icon-reorder",{"size":[1]}]]],["rux-icon-repeat",[[0,"rux-icon-repeat",{"size":[1]}]]],["rux-icon-repeat-one",[[0,"rux-icon-repeat-one",{"size":[1]}]]],["rux-icon-replay",[[0,"rux-icon-replay",{"size":[1]}]]],["rux-icon-replay-10",[[0,"rux-icon-replay-10",{"size":[1]}]]],["rux-icon-replay-30",[[0,"rux-icon-replay-30",{"size":[1]}]]],["rux-icon-replay-5",[[0,"rux-icon-replay-5",{"size":[1]}]]],["rux-icon-reply",[[0,"rux-icon-reply",{"size":[1]}]]],["rux-icon-reply-all",[[0,"rux-icon-reply-all",{"size":[1]}]]],["rux-icon-report",[[0,"rux-icon-report",{"size":[1]}]]],["rux-icon-report-off",[[0,"rux-icon-report-off",{"size":[1]}]]],["rux-icon-report-problem",[[0,"rux-icon-report-problem",{"size":[1]}]]],["rux-icon-restaurant",[[0,"rux-icon-restaurant",{"size":[1]}]]],["rux-icon-restaurant-menu",[[0,"rux-icon-restaurant-menu",{"size":[1]}]]],["rux-icon-restore",[[0,"rux-icon-restore",{"size":[1]}]]],["rux-icon-restore-from-trash",[[0,"rux-icon-restore-from-trash",{"size":[1]}]]],["rux-icon-restore-page",[[0,"rux-icon-restore-page",{"size":[1]}]]],["rux-icon-ring-volume",[[0,"rux-icon-ring-volume",{"size":[1]}]]],["rux-icon-room",[[0,"rux-icon-room",{"size":[1]}]]],["rux-icon-room-service",[[0,"rux-icon-room-service",{"size":[1]}]]],["rux-icon-rotate-90-degrees-cc",[[0,"rux-icon-rotate-90-degrees-cc",{"size":[1]}]]],["rux-icon-rotate-left",[[0,"rux-icon-rotate-left",{"size":[1]}]]],["rux-icon-rotate-right",[[0,"rux-icon-rotate-right",{"size":[1]}]]],["rux-icon-rounded-corner",[[0,"rux-icon-rounded-corner",{"size":[1]}]]],["rux-icon-router",[[0,"rux-icon-router",{"size":[1]}]]],["rux-icon-rowing",[[0,"rux-icon-rowing",{"size":[1]}]]],["rux-icon-rss-feed",[[0,"rux-icon-rss-feed",{"size":[1]}]]],["rux-icon-rv-hookup",[[0,"rux-icon-rv-hookup",{"size":[1]}]]],["rux-icon-satellite",[[0,"rux-icon-satellite",{"size":[1]}]]],["rux-icon-satellite-off",[[0,"rux-icon-satellite-off",{"size":[1]}]]],["rux-icon-satellite-receive",[[0,"rux-icon-satellite-receive",{"size":[1]}]]],["rux-icon-satellite-transmit",[[0,"rux-icon-satellite-transmit",{"size":[1]}]]],["rux-icon-save",[[0,"rux-icon-save",{"size":[1]}]]],["rux-icon-save-alt",[[0,"rux-icon-save-alt",{"size":[1]}]]],["rux-icon-scanner",[[0,"rux-icon-scanner",{"size":[1]}]]],["rux-icon-scatter-plot",[[0,"rux-icon-scatter-plot",{"size":[1]}]]],["rux-icon-schedule",[[0,"rux-icon-schedule",{"size":[1]}]]],["rux-icon-school",[[0,"rux-icon-school",{"size":[1]}]]],["rux-icon-score",[[0,"rux-icon-score",{"size":[1]}]]],["rux-icon-screen-lock-landscape",[[0,"rux-icon-screen-lock-landscape",{"size":[1]}]]],["rux-icon-screen-lock-portrait",[[0,"rux-icon-screen-lock-portrait",{"size":[1]}]]],["rux-icon-screen-lock-rotation",[[0,"rux-icon-screen-lock-rotation",{"size":[1]}]]],["rux-icon-screen-rotation",[[0,"rux-icon-screen-rotation",{"size":[1]}]]],["rux-icon-screen-share",[[0,"rux-icon-screen-share",{"size":[1]}]]],["rux-icon-sd-card",[[0,"rux-icon-sd-card",{"size":[1]}]]],["rux-icon-sd-storage",[[0,"rux-icon-sd-storage",{"size":[1]}]]],["rux-icon-search",[[0,"rux-icon-search",{"size":[1]}]]],["rux-icon-seat",[[0,"rux-icon-seat",{"size":[1]}]]],["rux-icon-security",[[0,"rux-icon-security",{"size":[1]}]]],["rux-icon-select-all",[[0,"rux-icon-select-all",{"size":[1]}]]],["rux-icon-send",[[0,"rux-icon-send",{"size":[1]}]]],["rux-icon-sentiment-dissatisfied",[[0,"rux-icon-sentiment-dissatisfied",{"size":[1]}]]],["rux-icon-sentiment-satisfied",[[0,"rux-icon-sentiment-satisfied",{"size":[1]}]]],["rux-icon-sentiment-satisfied-alt",[[0,"rux-icon-sentiment-satisfied-alt",{"size":[1]}]]],["rux-icon-sentiment-very-dissatisfied",[[0,"rux-icon-sentiment-very-dissatisfied",{"size":[1]}]]],["rux-icon-sentiment-very-satisfied",[[0,"rux-icon-sentiment-very-satisfied",{"size":[1]}]]],["rux-icon-set-power",[[0,"rux-icon-set-power",{"size":[1]}]]],["rux-icon-settings",[[0,"rux-icon-settings",{"size":[1]}]]],["rux-icon-settings-applications",[[0,"rux-icon-settings-applications",{"size":[1]}]]],["rux-icon-settings-backup-restore",[[0,"rux-icon-settings-backup-restore",{"size":[1]}]]],["rux-icon-settings-bluetooth",[[0,"rux-icon-settings-bluetooth",{"size":[1]}]]],["rux-icon-settings-brightness",[[0,"rux-icon-settings-brightness",{"size":[1]}]]],["rux-icon-settings-cell",[[0,"rux-icon-settings-cell",{"size":[1]}]]],["rux-icon-settings-ethernet",[[0,"rux-icon-settings-ethernet",{"size":[1]}]]],["rux-icon-settings-input-antenna",[[0,"rux-icon-settings-input-antenna",{"size":[1]}]]],["rux-icon-settings-input-component",[[0,"rux-icon-settings-input-component",{"size":[1]}]]],["rux-icon-settings-input-composite",[[0,"rux-icon-settings-input-composite",{"size":[1]}]]],["rux-icon-settings-input-hdmi",[[0,"rux-icon-settings-input-hdmi",{"size":[1]}]]],["rux-icon-settings-input-svideo",[[0,"rux-icon-settings-input-svideo",{"size":[1]}]]],["rux-icon-settings-overscan",[[0,"rux-icon-settings-overscan",{"size":[1]}]]],["rux-icon-settings-phone",[[0,"rux-icon-settings-phone",{"size":[1]}]]],["rux-icon-settings-power",[[0,"rux-icon-settings-power",{"size":[1]}]]],["rux-icon-settings-remote",[[0,"rux-icon-settings-remote",{"size":[1]}]]],["rux-icon-settings-system-daydream",[[0,"rux-icon-settings-system-daydream",{"size":[1]}]]],["rux-icon-settings-voice",[[0,"rux-icon-settings-voice",{"size":[1]}]]],["rux-icon-share",[[0,"rux-icon-share",{"size":[1]}]]],["rux-icon-shop",[[0,"rux-icon-shop",{"size":[1]}]]],["rux-icon-shop-two",[[0,"rux-icon-shop-two",{"size":[1]}]]],["rux-icon-shopping-basket",[[0,"rux-icon-shopping-basket",{"size":[1]}]]],["rux-icon-shopping-cart",[[0,"rux-icon-shopping-cart",{"size":[1]}]]],["rux-icon-short-text",[[0,"rux-icon-short-text",{"size":[1]}]]],["rux-icon-show-chart",[[0,"rux-icon-show-chart",{"size":[1]}]]],["rux-icon-shuffle",[[0,"rux-icon-shuffle",{"size":[1]}]]],["rux-icon-shutter-speed",[[0,"rux-icon-shutter-speed",{"size":[1]}]]],["rux-icon-signal-cellular-0-bar",[[0,"rux-icon-signal-cellular-0-bar",{"size":[1]}]]],["rux-icon-signal-cellular-1-bar",[[0,"rux-icon-signal-cellular-1-bar",{"size":[1]}]]],["rux-icon-signal-cellular-2-bar",[[0,"rux-icon-signal-cellular-2-bar",{"size":[1]}]]],["rux-icon-signal-cellular-3-bar",[[0,"rux-icon-signal-cellular-3-bar",{"size":[1]}]]],["rux-icon-signal-cellular-4-bar",[[0,"rux-icon-signal-cellular-4-bar",{"size":[1]}]]],["rux-icon-signal-cellular-alt",[[0,"rux-icon-signal-cellular-alt",{"size":[1]}]]],["rux-icon-signal-cellular-connected-no-internet-0-bar",[[0,"rux-icon-signal-cellular-connected-no-internet-0-bar",{"size":[1]}]]],["rux-icon-signal-cellular-connected-no-internet-1-bar",[[0,"rux-icon-signal-cellular-connected-no-internet-1-bar",{"size":[1]}]]],["rux-icon-signal-cellular-connected-no-internet-2-bar",[[0,"rux-icon-signal-cellular-connected-no-internet-2-bar",{"size":[1]}]]],["rux-icon-signal-cellular-connected-no-internet-3-bar",[[0,"rux-icon-signal-cellular-connected-no-internet-3-bar",{"size":[1]}]]],["rux-icon-signal-cellular-connected-no-internet-4-bar",[[0,"rux-icon-signal-cellular-connected-no-internet-4-bar",{"size":[1]}]]],["rux-icon-signal-cellular-no-sim",[[0,"rux-icon-signal-cellular-no-sim",{"size":[1]}]]],["rux-icon-signal-cellular-null",[[0,"rux-icon-signal-cellular-null",{"size":[1]}]]],["rux-icon-signal-cellular-off",[[0,"rux-icon-signal-cellular-off",{"size":[1]}]]],["rux-icon-signal-wifi-0-bar",[[0,"rux-icon-signal-wifi-0-bar",{"size":[1]}]]],["rux-icon-signal-wifi-1-bar",[[0,"rux-icon-signal-wifi-1-bar",{"size":[1]}]]],["rux-icon-signal-wifi-1-bar-lock",[[0,"rux-icon-signal-wifi-1-bar-lock",{"size":[1]}]]],["rux-icon-signal-wifi-2-bar",[[0,"rux-icon-signal-wifi-2-bar",{"size":[1]}]]],["rux-icon-signal-wifi-2-bar-lock",[[0,"rux-icon-signal-wifi-2-bar-lock",{"size":[1]}]]],["rux-icon-signal-wifi-3-bar",[[0,"rux-icon-signal-wifi-3-bar",{"size":[1]}]]],["rux-icon-signal-wifi-3-bar-lock",[[0,"rux-icon-signal-wifi-3-bar-lock",{"size":[1]}]]],["rux-icon-signal-wifi-4-bar",[[0,"rux-icon-signal-wifi-4-bar",{"size":[1]}]]],["rux-icon-signal-wifi-4-bar-lock",[[0,"rux-icon-signal-wifi-4-bar-lock",{"size":[1]}]]],["rux-icon-signal-wifi-off",[[0,"rux-icon-signal-wifi-off",{"size":[1]}]]],["rux-icon-sim-card",[[0,"rux-icon-sim-card",{"size":[1]}]]],["rux-icon-skip-next",[[0,"rux-icon-skip-next",{"size":[1]}]]],["rux-icon-skip-previous",[[0,"rux-icon-skip-previous",{"size":[1]}]]],["rux-icon-slideshow",[[0,"rux-icon-slideshow",{"size":[1]}]]],["rux-icon-slow-motion-video",[[0,"rux-icon-slow-motion-video",{"size":[1]}]]],["rux-icon-smartphone",[[0,"rux-icon-smartphone",{"size":[1]}]]],["rux-icon-smoke-free",[[0,"rux-icon-smoke-free",{"size":[1]}]]],["rux-icon-smoking-rooms",[[0,"rux-icon-smoking-rooms",{"size":[1]}]]],["rux-icon-sms",[[0,"rux-icon-sms",{"size":[1]}]]],["rux-icon-sms-failed",[[0,"rux-icon-sms-failed",{"size":[1]}]]],["rux-icon-snooze",[[0,"rux-icon-snooze",{"size":[1]}]]],["rux-icon-solar",[[0,"rux-icon-solar",{"size":[1]}]]],["rux-icon-sort",[[0,"rux-icon-sort",{"size":[1]}]]],["rux-icon-sort-by-alpha",[[0,"rux-icon-sort-by-alpha",{"size":[1]}]]],["rux-icon-spa",[[0,"rux-icon-spa",{"size":[1]}]]],["rux-icon-space-bar",[[0,"rux-icon-space-bar",{"size":[1]}]]],["rux-icon-speaker",[[0,"rux-icon-speaker",{"size":[1]}]]],["rux-icon-speaker-group",[[0,"rux-icon-speaker-group",{"size":[1]}]]],["rux-icon-speaker-notes",[[0,"rux-icon-speaker-notes",{"size":[1]}]]],["rux-icon-speaker-notes-off",[[0,"rux-icon-speaker-notes-off",{"size":[1]}]]],["rux-icon-speaker-phone",[[0,"rux-icon-speaker-phone",{"size":[1]}]]],["rux-icon-spellcheck",[[0,"rux-icon-spellcheck",{"size":[1]}]]],["rux-icon-star",[[0,"rux-icon-star",{"size":[1]}]]],["rux-icon-star-border",[[0,"rux-icon-star-border",{"size":[1]}]]],["rux-icon-star-half",[[0,"rux-icon-star-half",{"size":[1]}]]],["rux-icon-star-rate",[[0,"rux-icon-star-rate",{"size":[1]}]]],["rux-icon-stars",[[0,"rux-icon-stars",{"size":[1]}]]],["rux-icon-stay-current-landscape",[[0,"rux-icon-stay-current-landscape",{"size":[1]}]]],["rux-icon-stay-current-portrait",[[0,"rux-icon-stay-current-portrait",{"size":[1]}]]],["rux-icon-stay-primary-landscape",[[0,"rux-icon-stay-primary-landscape",{"size":[1]}]]],["rux-icon-stay-primary-portrait",[[0,"rux-icon-stay-primary-portrait",{"size":[1]}]]],["rux-icon-stop",[[0,"rux-icon-stop",{"size":[1]}]]],["rux-icon-stop-screen-share",[[0,"rux-icon-stop-screen-share",{"size":[1]}]]],["rux-icon-storage",[[0,"rux-icon-storage",{"size":[1]}]]],["rux-icon-store",[[0,"rux-icon-store",{"size":[1]}]]],["rux-icon-store-mall-directory",[[0,"rux-icon-store-mall-directory",{"size":[1]}]]],["rux-icon-straighten",[[0,"rux-icon-straighten",{"size":[1]}]]],["rux-icon-streetview",[[0,"rux-icon-streetview",{"size":[1]}]]],["rux-icon-strikethrough-s",[[0,"rux-icon-strikethrough-s",{"size":[1]}]]],["rux-icon-style",[[0,"rux-icon-style",{"size":[1]}]]],["rux-icon-subdirectory-arrow-left",[[0,"rux-icon-subdirectory-arrow-left",{"size":[1]}]]],["rux-icon-subdirectory-arrow-right",[[0,"rux-icon-subdirectory-arrow-right",{"size":[1]}]]],["rux-icon-subject",[[0,"rux-icon-subject",{"size":[1]}]]],["rux-icon-subscriptions",[[0,"rux-icon-subscriptions",{"size":[1]}]]],["rux-icon-subtitles",[[0,"rux-icon-subtitles",{"size":[1]}]]],["rux-icon-subway",[[0,"rux-icon-subway",{"size":[1]}]]],["rux-icon-supervised-user-circle",[[0,"rux-icon-supervised-user-circle",{"size":[1]}]]],["rux-icon-supervisor-account",[[0,"rux-icon-supervisor-account",{"size":[1]}]]],["rux-icon-surround-sound",[[0,"rux-icon-surround-sound",{"size":[1]}]]],["rux-icon-swap-calls",[[0,"rux-icon-swap-calls",{"size":[1]}]]],["rux-icon-swap-horiz",[[0,"rux-icon-swap-horiz",{"size":[1]}]]],["rux-icon-swap-horizontal-circle",[[0,"rux-icon-swap-horizontal-circle",{"size":[1]}]]],["rux-icon-swap-vert",[[0,"rux-icon-swap-vert",{"size":[1]}]]],["rux-icon-swap-vertical-circle",[[0,"rux-icon-swap-vertical-circle",{"size":[1]}]]],["rux-icon-switch-camera",[[0,"rux-icon-switch-camera",{"size":[1]}]]],["rux-icon-switch-video",[[0,"rux-icon-switch-video",{"size":[1]}]]],["rux-icon-sync",[[0,"rux-icon-sync",{"size":[1]}]]],["rux-icon-sync-disabled",[[0,"rux-icon-sync-disabled",{"size":[1]}]]],["rux-icon-sync-problem",[[0,"rux-icon-sync-problem",{"size":[1]}]]],["rux-icon-system-update",[[0,"rux-icon-system-update",{"size":[1]}]]],["rux-icon-tab",[[0,"rux-icon-tab",{"size":[1]}]]],["rux-icon-tab-unselected",[[0,"rux-icon-tab-unselected",{"size":[1]}]]],["rux-icon-table-chart",[[0,"rux-icon-table-chart",{"size":[1]}]]],["rux-icon-tablet",[[0,"rux-icon-tablet",{"size":[1]}]]],["rux-icon-tablet-android",[[0,"rux-icon-tablet-android",{"size":[1]}]]],["rux-icon-tablet-mac",[[0,"rux-icon-tablet-mac",{"size":[1]}]]],["rux-icon-tag-faces",[[0,"rux-icon-tag-faces",{"size":[1]}]]],["rux-icon-tap-and-play",[[0,"rux-icon-tap-and-play",{"size":[1]}]]],["rux-icon-terrain",[[0,"rux-icon-terrain",{"size":[1]}]]],["rux-icon-text-fields",[[0,"rux-icon-text-fields",{"size":[1]}]]],["rux-icon-text-format",[[0,"rux-icon-text-format",{"size":[1]}]]],["rux-icon-text-rotate-up",[[0,"rux-icon-text-rotate-up",{"size":[1]}]]],["rux-icon-text-rotate-vertical",[[0,"rux-icon-text-rotate-vertical",{"size":[1]}]]],["rux-icon-text-rotation-none",[[0,"rux-icon-text-rotation-none",{"size":[1]}]]],["rux-icon-textsms",[[0,"rux-icon-textsms",{"size":[1]}]]],["rux-icon-texture",[[0,"rux-icon-texture",{"size":[1]}]]],["rux-icon-theaters",[[0,"rux-icon-theaters",{"size":[1]}]]],["rux-icon-thermal",[[0,"rux-icon-thermal",{"size":[1]}]]],["rux-icon-thumb-down",[[0,"rux-icon-thumb-down",{"size":[1]}]]],["rux-icon-thumb-down-alt",[[0,"rux-icon-thumb-down-alt",{"size":[1]}]]],["rux-icon-thumb-up",[[0,"rux-icon-thumb-up",{"size":[1]}]]],["rux-icon-thumb-up-alt",[[0,"rux-icon-thumb-up-alt",{"size":[1]}]]],["rux-icon-thumbs-up-down",[[0,"rux-icon-thumbs-up-down",{"size":[1]}]]],["rux-icon-time-to-leave",[[0,"rux-icon-time-to-leave",{"size":[1]}]]],["rux-icon-timelapse",[[0,"rux-icon-timelapse",{"size":[1]}]]],["rux-icon-timeline",[[0,"rux-icon-timeline",{"size":[1]}]]],["rux-icon-timer",[[0,"rux-icon-timer",{"size":[1]}]]],["rux-icon-timer-10",[[0,"rux-icon-timer-10",{"size":[1]}]]],["rux-icon-timer-3",[[0,"rux-icon-timer-3",{"size":[1]}]]],["rux-icon-timer-off",[[0,"rux-icon-timer-off",{"size":[1]}]]],["rux-icon-title",[[0,"rux-icon-title",{"size":[1]}]]],["rux-icon-toc",[[0,"rux-icon-toc",{"size":[1]}]]],["rux-icon-today",[[0,"rux-icon-today",{"size":[1]}]]],["rux-icon-toggle-off",[[0,"rux-icon-toggle-off",{"size":[1]}]]],["rux-icon-toggle-on",[[0,"rux-icon-toggle-on",{"size":[1]}]]],["rux-icon-toll",[[0,"rux-icon-toll",{"size":[1]}]]],["rux-icon-tonality",[[0,"rux-icon-tonality",{"size":[1]}]]],["rux-icon-touch-app",[[0,"rux-icon-touch-app",{"size":[1]}]]],["rux-icon-toys",[[0,"rux-icon-toys",{"size":[1]}]]],["rux-icon-track-changes",[[0,"rux-icon-track-changes",{"size":[1]}]]],["rux-icon-traffic",[[0,"rux-icon-traffic",{"size":[1]}]]],["rux-icon-train",[[0,"rux-icon-train",{"size":[1]}]]],["rux-icon-tram",[[0,"rux-icon-tram",{"size":[1]}]]],["rux-icon-transfer-within-a-station",[[0,"rux-icon-transfer-within-a-station",{"size":[1]}]]],["rux-icon-transform",[[0,"rux-icon-transform",{"size":[1]}]]],["rux-icon-transit-enterexit",[[0,"rux-icon-transit-enterexit",{"size":[1]}]]],["rux-icon-translate",[[0,"rux-icon-translate",{"size":[1]}]]],["rux-icon-trending-down",[[0,"rux-icon-trending-down",{"size":[1]}]]],["rux-icon-trending-flat",[[0,"rux-icon-trending-flat",{"size":[1]}]]],["rux-icon-trending-up",[[0,"rux-icon-trending-up",{"size":[1]}]]],["rux-icon-trip-origin",[[0,"rux-icon-trip-origin",{"size":[1]}]]],["rux-icon-tune",[[0,"rux-icon-tune",{"size":[1]}]]],["rux-icon-turned-in",[[0,"rux-icon-turned-in",{"size":[1]}]]],["rux-icon-turned-in-not",[[0,"rux-icon-turned-in-not",{"size":[1]}]]],["rux-icon-tv",[[0,"rux-icon-tv",{"size":[1]}]]],["rux-icon-tv-off",[[0,"rux-icon-tv-off",{"size":[1]}]]],["rux-icon-unarchive",[[0,"rux-icon-unarchive",{"size":[1]}]]],["rux-icon-undo",[[0,"rux-icon-undo",{"size":[1]}]]],["rux-icon-unfold-less",[[0,"rux-icon-unfold-less",{"size":[1]}]]],["rux-icon-unfold-more",[[0,"rux-icon-unfold-more",{"size":[1]}]]],["rux-icon-unsubscribe",[[0,"rux-icon-unsubscribe",{"size":[1]}]]],["rux-icon-update",[[0,"rux-icon-update",{"size":[1]}]]],["rux-icon-usb",[[0,"rux-icon-usb",{"size":[1]}]]],["rux-icon-verified-user",[[0,"rux-icon-verified-user",{"size":[1]}]]],["rux-icon-vertical-align-bottom",[[0,"rux-icon-vertical-align-bottom",{"size":[1]}]]],["rux-icon-vertical-align-center",[[0,"rux-icon-vertical-align-center",{"size":[1]}]]],["rux-icon-vertical-align-top",[[0,"rux-icon-vertical-align-top",{"size":[1]}]]],["rux-icon-vertical-split",[[0,"rux-icon-vertical-split",{"size":[1]}]]],["rux-icon-vibration",[[0,"rux-icon-vibration",{"size":[1]}]]],["rux-icon-video-call",[[0,"rux-icon-video-call",{"size":[1]}]]],["rux-icon-video-label",[[0,"rux-icon-video-label",{"size":[1]}]]],["rux-icon-video-library",[[0,"rux-icon-video-library",{"size":[1]}]]],["rux-icon-videocam",[[0,"rux-icon-videocam",{"size":[1]}]]],["rux-icon-videocam-off",[[0,"rux-icon-videocam-off",{"size":[1]}]]],["rux-icon-videogame-asset",[[0,"rux-icon-videogame-asset",{"size":[1]}]]],["rux-icon-view-agenda",[[0,"rux-icon-view-agenda",{"size":[1]}]]],["rux-icon-view-array",[[0,"rux-icon-view-array",{"size":[1]}]]],["rux-icon-view-carousel",[[0,"rux-icon-view-carousel",{"size":[1]}]]],["rux-icon-view-column",[[0,"rux-icon-view-column",{"size":[1]}]]],["rux-icon-view-comfy",[[0,"rux-icon-view-comfy",{"size":[1]}]]],["rux-icon-view-compact",[[0,"rux-icon-view-compact",{"size":[1]}]]],["rux-icon-view-day",[[0,"rux-icon-view-day",{"size":[1]}]]],["rux-icon-view-headline",[[0,"rux-icon-view-headline",{"size":[1]}]]],["rux-icon-view-list",[[0,"rux-icon-view-list",{"size":[1]}]]],["rux-icon-view-module",[[0,"rux-icon-view-module",{"size":[1]}]]],["rux-icon-view-quilt",[[0,"rux-icon-view-quilt",{"size":[1]}]]],["rux-icon-view-stream",[[0,"rux-icon-view-stream",{"size":[1]}]]],["rux-icon-view-week",[[0,"rux-icon-view-week",{"size":[1]}]]],["rux-icon-vignette",[[0,"rux-icon-vignette",{"size":[1]}]]],["rux-icon-visibility",[[0,"rux-icon-visibility",{"size":[1]}]]],["rux-icon-visibility-off",[[0,"rux-icon-visibility-off",{"size":[1]}]]],["rux-icon-voice-chat",[[0,"rux-icon-voice-chat",{"size":[1]}]]],["rux-icon-voice-over-off",[[0,"rux-icon-voice-over-off",{"size":[1]}]]],["rux-icon-voicemail",[[0,"rux-icon-voicemail",{"size":[1]}]]],["rux-icon-volume-down",[[0,"rux-icon-volume-down",{"size":[1]}]]],["rux-icon-volume-mute",[[0,"rux-icon-volume-mute",{"size":[1]}]]],["rux-icon-volume-off",[[0,"rux-icon-volume-off",{"size":[1]}]]],["rux-icon-volume-up",[[0,"rux-icon-volume-up",{"size":[1]}]]],["rux-icon-vpn-key",[[0,"rux-icon-vpn-key",{"size":[1]}]]],["rux-icon-vpn-lock",[[0,"rux-icon-vpn-lock",{"size":[1]}]]],["rux-icon-wallpaper",[[0,"rux-icon-wallpaper",{"size":[1]}]]],["rux-icon-warning",[[0,"rux-icon-warning",{"size":[1]}]]],["rux-icon-watch",[[0,"rux-icon-watch",{"size":[1]}]]],["rux-icon-watch-later",[[0,"rux-icon-watch-later",{"size":[1]}]]],["rux-icon-waves",[[0,"rux-icon-waves",{"size":[1]}]]],["rux-icon-wb-auto",[[0,"rux-icon-wb-auto",{"size":[1]}]]],["rux-icon-wb-cloudy",[[0,"rux-icon-wb-cloudy",{"size":[1]}]]],["rux-icon-wb-incandescent",[[0,"rux-icon-wb-incandescent",{"size":[1]}]]],["rux-icon-wb-iridescent",[[0,"rux-icon-wb-iridescent",{"size":[1]}]]],["rux-icon-wb-sunny",[[0,"rux-icon-wb-sunny",{"size":[1]}]]],["rux-icon-wc",[[0,"rux-icon-wc",{"size":[1]}]]],["rux-icon-web",[[0,"rux-icon-web",{"size":[1]}]]],["rux-icon-web-asset",[[0,"rux-icon-web-asset",{"size":[1]}]]],["rux-icon-weekend",[[0,"rux-icon-weekend",{"size":[1]}]]],["rux-icon-whatshot",[[0,"rux-icon-whatshot",{"size":[1]}]]],["rux-icon-where-to-vote",[[0,"rux-icon-where-to-vote",{"size":[1]}]]],["rux-icon-widgets",[[0,"rux-icon-widgets",{"size":[1]}]]],["rux-icon-wifi",[[0,"rux-icon-wifi",{"size":[1]}]]],["rux-icon-wifi-lock",[[0,"rux-icon-wifi-lock",{"size":[1]}]]],["rux-icon-wifi-off",[[0,"rux-icon-wifi-off",{"size":[1]}]]],["rux-icon-wifi-tethering",[[0,"rux-icon-wifi-tethering",{"size":[1]}]]],["rux-icon-work",[[0,"rux-icon-work",{"size":[1]}]]],["rux-icon-work-off",[[0,"rux-icon-work-off",{"size":[1]}]]],["rux-icon-work-outline",[[0,"rux-icon-work-outline",{"size":[1]}]]],["rux-icon-wrap-text",[[0,"rux-icon-wrap-text",{"size":[1]}]]],["rux-icon-youtube-searched-for",[[0,"rux-icon-youtube-searched-for",{"size":[1]}]]],["rux-icon-zoom-in",[[0,"rux-icon-zoom-in",{"size":[1]}]]],["rux-icon-zoom-in-map",[[0,"rux-icon-zoom-in-map",{"size":[1]}]]],["rux-icon-zoom-out",[[0,"rux-icon-zoom-out",{"size":[1]}]]],["rux-icon-zoom-out-map",[[0,"rux-icon-zoom-out-map",{"size":[1]}]]],["rux-indeterminate-progress",[[1,"rux-indeterminate-progress"]]],["rux-status",[[1,"rux-status",{"status":[513]}]]],["rux-log",[[1,"rux-log",{"data":[16],"timezone":[1],"filter":[1537]}]]],["rux-monitoring-icon",[[1,"rux-monitoring-icon",{"status":[513],"label":[1],"sublabel":[1],"icon":[1],"size":[1],"notifications":[2]}]]],["rux-notification",[[1,"rux-notification",{"open":[1540],"message":[1],"status":[513],"closeAfter":[1026,"close-after"],"small":[4],"hideClose":[4,"hide-close"],"hasPrefixSlot":[32],"hasMessageSlot":[32]}]]],["rux-toast-stack",[[1,"rux-toast-stack",{"position":[513],"addToast":[64]}]]],["rux-monitoring-progress-icon",[[1,"rux-monitoring-progress-icon",{"label":[1],"sublabel":[1],"range":[1040],"notifications":[2],"min":[2],"max":[2],"progress":[514],"_status":[32],"_graphProgress":[32]}]]],["rux-push-button",[[1,"rux-push-button",{"icon":[513],"iconOnly":[516,"icon-only"],"disabled":[516],"checked":[1540],"label":[1],"name":[1],"value":[513],"size":[513]}]]],["rux-time-region",[[1,"rux-time-region",{"start":[513],"end":[513],"hideTimestamp":[4,"hide-timestamp"],"status":[1],"partial":[1],"selected":[4],"timezone":[1]}]]],["rux-menu",[[1,"rux-menu"]]],["rux-menu-item",[[1,"rux-menu-item",{"selected":[516],"disabled":[516],"value":[1025],"href":[1],"target":[1],"rel":[1],"download":[1]}]]],["rux-menu-item-divider",[[1,"rux-menu-item-divider"]]],["rux-option",[[1,"rux-option",{"value":[513],"label":[513],"disabled":[4]}]]],["rux-option-group",[[1,"rux-option-group",{"label":[1]}]]],["rux-pop-up",[[1,"rux-pop-up",{"open":[1540],"placement":[1],"disableAutoUpdate":[516,"disable-auto-update"],"enableAnimationFrame":[516,"enable-animation-frame"],"strategy":[1],"closeOnSelect":[4,"close-on-select"],"arrowPosition":[32],"show":[64],"hide":[64]},[[0,"ruxmenuselected","handleSelection"]]]]],["rux-progress",[[1,"rux-progress",{"value":[1026],"max":[2],"hideLabel":[4,"hide-label"]}]]],["rux-radio",[[1,"rux-radio",{"name":[1],"value":[1],"checked":[1540],"disabled":[516],"label":[1],"hasLabelSlot":[32],"buttonTabindex":[32],"setFocus":[64],"setButtonTabindex":[64]}]]],["rux-radio-group",[[1,"rux-radio-group",{"label":[1],"invalid":[4],"required":[4],"name":[1],"value":[1544],"helpText":[1,"help-text"],"errorText":[1,"error-text"],"hasLabelSlot":[32],"hasHelpSlot":[32],"hasErrorSlot":[32]},[[4,"keydown","onKeydown"]]]]],["rux-ruler",[[1,"rux-ruler",{"interval":[8],"start":[1],"end":[1],"timezone":[513],"showStartOfDay":[4,"show-start-of-day"]}]]],["rux-segmented-button",[[1,"rux-segmented-button",{"data":[16],"selected":[1537],"size":[513],"disabled":[516]}]]],["rux-select",[[1,"rux-select",{"disabled":[516],"required":[516],"label":[1],"inputId":[1,"input-id"],"labelId":[1,"label-id"],"invalid":[516],"multiple":[516],"name":[513],"value":[1025],"helpText":[1,"help-text"],"errorText":[1,"error-text"],"size":[513],"inline":[516],"hasLabelSlot":[32],"hasHelpSlot":[32],"hasErrorSlot":[32],"setFocus":[64]},[[0,"rux-option-group-changed","handleGroupChange"],[0,"rux-option-changed","handleOptionChange"]]]]],["rux-slider",[[1,"rux-slider",{"min":[2],"max":[2],"step":[2],"value":[1538],"axisLabels":[16],"ticksOnly":[4,"ticks-only"],"disabled":[516],"name":[1],"label":[1],"helpText":[1,"help-text"],"errorText":[1,"error-text"],"minVal":[1538,"min-val"],"strict":[516],"hasLabelSlot":[32],"hasHelpSlot":[32],"hasErrorSlot":[32]}]]],["rux-switch",[[1,"rux-switch",{"name":[1],"value":[1537],"checked":[1540],"disabled":[516],"label":[1],"hasLabelSlot":[32]}]]],["rux-tab",[[1,"rux-tab",{"selected":[516],"disabled":[516],"small":[4]}]]],["rux-tab-panel",[[1,"rux-tab-panel"]]],["rux-tab-panels",[[1,"rux-tab-panels"]]],["rux-tabs",[[1,"rux-tabs",{"small":[4],"_panels":[32],"_tabs":[32]},[[8,"ruxtabselected","handleTabselected"],[8,"ruxregisterpanels","handleListen"],[0,"keydown","onKeydown"]]]]],["rux-tag",[[1,"rux-tag",{"status":[513],"hasSlot":[32]}]]],["rux-textarea",[[1,"rux-textarea",{"label":[1],"placeholder":[1],"helpText":[1,"help-text"],"errorText":[1,"error-text"],"invalid":[4],"value":[1537],"name":[1],"minLength":[1,"min-length"],"maxLength":[1,"max-length"],"rows":[2],"disabled":[516],"required":[4],"readonly":[4],"size":[513],"hasLabelSlot":[32],"hasHelpSlot":[32],"hasErrorSlot":[32],"setFocus":[64]}]]],["rux-timeline",[[1,"rux-timeline",{"start":[1],"end":[1],"zoom":[514],"playhead":[1537],"hasPlayedIndicator":[516,"has-played-indicator"],"interval":[1],"timezone":[1],"playheadPositionInPixels":[32],"columnWidth":[32],"playheadHeight":[32],"showPlayhead":[32]}]]],["rux-tooltip",[[1,"rux-tooltip",{"message":[513],"open":[1540],"delay":[514],"offset":[2],"placement":[513],"disableAutoUpdate":[516,"disable-auto-update"],"strategy":[1],"currentSlotted":[32],"hasTriggerSlot":[32],"delegatedFocus":[32],"show":[64],"hide":[64]},[[4,"keydown","handleKeypress"]]]]],["rux-track",[[1,"rux-track",{"width":[514],"columns":[514],"interval":[520],"start":[513],"end":[513],"timezone":[513],"playhead":[520],"hasRuler":[32]},[[0,"ruxtimeregionchange","handleTimeRegionChange"]]]]],["rux-tree",[[1,"rux-tree"]]],["rux-tree-node",[[1,"rux-tree-node",{"expanded":[1540],"selected":[1540],"children":[32],"hasPrefix":[32],"hasSuffix":[32],"setExpanded":[64],"setSelected":[64]},[[0,"keydown","handleKeyDown"]]]]],["rux-icon",[[1,"rux-icon",{"size":[513],"icon":[1]}]]],["rux-button",[[17,"rux-button",{"icon":[513],"iconOnly":[516,"icon-only"],"secondary":[4],"disabled":[516],"borderless":[4],"size":[513],"type":[1]}]]],["rux-toast",[[1,"rux-toast",{"message":[513],"closeAfter":[1538,"close-after"],"hideClose":[516,"hide-close"],"hasMessageSlot":[32]}]]],["rux-datetime_9",[[1,"rux-input",{"label":[1],"placeholder":[1],"helpText":[1,"help-text"],"errorText":[1,"error-text"],"invalid":[4],"value":[1537],"name":[1],"type":[1],"min":[1],"max":[1],"disabled":[516],"required":[4],"size":[1],"step":[1],"spellcheck":[4],"readonly":[4],"autocomplete":[1],"hasLabelSlot":[32],"hasHelpSlot":[32],"hasErrorSlot":[32],"togglePassword":[32],"isPasswordVisible":[32],"hasFocus":[32],"setFocus":[64],"getInput":[64]}],[1,"rux-datetime",{"date":[1],"locale":[1],"weekday":[1],"era":[1],"year":[1],"month":[1],"day":[1],"hour":[1],"minute":[1],"second":[1],"timeZoneName":[1,"time-zone-name"],"timeZone":[1,"time-zone"],"hour12":[4,"hour-12"]}],[1,"rux-table"],[1,"rux-table-body"],[1,"rux-table-cell"],[1,"rux-table-header"],[1,"rux-table-header-cell"],[1,"rux-table-header-row"],[1,"rux-table-row",{"selected":[4]}]]]]'), options);
  });
};

// node_modules/@astrouxds/astro-web-components/loader/index.js
(function() {
  if ("undefined" !== typeof window && void 0 !== window.Reflect && void 0 !== window.customElements) {
    var a = HTMLElement;
    window.HTMLElement = function() {
      return Reflect.construct(a, [], this.constructor);
    };
    HTMLElement.prototype = a.prototype;
    HTMLElement.prototype.constructor = HTMLElement;
    Object.setPrototypeOf(HTMLElement, a);
  }
})();

// node_modules/@astrouxds/angular/fesm2020/astrouxds-angular.mjs
var _c0 = ["*"];
var proxyInputs = (Cmp, inputs) => {
  const Prototype = Cmp.prototype;
  inputs.forEach((item) => {
    Object.defineProperty(Prototype, item, {
      get() {
        return this.el[item];
      },
      set(val) {
        this.z.runOutsideAngular(() => this.el[item] = val);
      }
    });
  });
};
var proxyMethods = (Cmp, methods) => {
  const Prototype = Cmp.prototype;
  methods.forEach((methodName) => {
    Prototype[methodName] = function() {
      const args = arguments;
      return this.z.runOutsideAngular(() => this.el[methodName].apply(this.el, args));
    };
  });
};
var proxyOutputs = (instance, el, events) => {
  events.forEach((eventName) => instance[eventName] = fromEvent(el, eventName));
};
function ProxyCmp(opts) {
  const decorator = function(cls) {
    const {
      defineCustomElementFn,
      inputs,
      methods
    } = opts;
    if (defineCustomElementFn !== void 0) {
      defineCustomElementFn();
    }
    if (inputs) {
      proxyInputs(cls, inputs);
    }
    if (methods) {
      proxyMethods(cls, methods);
    }
    return cls;
  };
  return decorator;
}
var AngularLibService = class {
  constructor() {
  }
};
AngularLibService.ɵfac = function AngularLibService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || AngularLibService)();
};
AngularLibService.ɵprov = ɵɵdefineInjectable({
  token: AngularLibService,
  factory: AngularLibService.ɵfac,
  providedIn: "root"
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AngularLibService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], function() {
    return [];
  }, null);
})();
var AngularLibComponent = class {
  constructor() {
  }
  ngOnInit() {
  }
};
AngularLibComponent.ɵfac = function AngularLibComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || AngularLibComponent)();
};
AngularLibComponent.ɵcmp = ɵɵdefineComponent({
  type: AngularLibComponent,
  selectors: [["lib-angular-lib"]],
  standalone: false,
  decls: 2,
  vars: 0,
  template: function AngularLibComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "p");
      ɵɵtext(1, "angular-lib works!");
      ɵɵelementEnd();
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AngularLibComponent, [{
    type: Component,
    args: [{
      selector: "lib-angular-lib",
      template: ` <p>angular-lib works!</p> `,
      styles: []
    }]
  }], function() {
    return [];
  }, null);
})();
var RuxAccordion = class RuxAccordion2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxAccordion.ɵfac = function RuxAccordion_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxAccordion)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxAccordion.ɵcmp = ɵɵdefineComponent({
  type: RuxAccordion,
  selectors: [["rux-accordion"]],
  inputs: {
    disabled: "disabled",
    disallowMultiple: "disallowMultiple"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxAccordion_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxAccordion = __decorate([ProxyCmp({
  inputs: ["disabled", "disallowMultiple"]
})], RuxAccordion);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxAccordion, [{
    type: Component,
    args: [{
      selector: "rux-accordion",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["disabled", "disallowMultiple"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxAccordionItem = class RuxAccordionItem2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
    proxyOutputs(this, this.el, ["ruxexpanded", "ruxcollapsed"]);
  }
};
RuxAccordionItem.ɵfac = function RuxAccordionItem_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxAccordionItem)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxAccordionItem.ɵcmp = ɵɵdefineComponent({
  type: RuxAccordionItem,
  selectors: [["rux-accordion-item"]],
  inputs: {
    disabled: "disabled",
    expanded: "expanded"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxAccordionItem_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxAccordionItem = __decorate([ProxyCmp({
  inputs: ["disabled", "expanded"]
})], RuxAccordionItem);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxAccordionItem, [{
    type: Component,
    args: [{
      selector: "rux-accordion-item",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["disabled", "expanded"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxBreadcrumb = class RuxBreadcrumb2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxBreadcrumb.ɵfac = function RuxBreadcrumb_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxBreadcrumb)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxBreadcrumb.ɵcmp = ɵɵdefineComponent({
  type: RuxBreadcrumb,
  selectors: [["rux-breadcrumb"]],
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxBreadcrumb_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxBreadcrumb = __decorate([ProxyCmp({})], RuxBreadcrumb);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxBreadcrumb, [{
    type: Component,
    args: [{
      selector: "rux-breadcrumb",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: []
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxBreadcrumbItem = class RuxBreadcrumbItem2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxBreadcrumbItem.ɵfac = function RuxBreadcrumbItem_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxBreadcrumbItem)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxBreadcrumbItem.ɵcmp = ɵɵdefineComponent({
  type: RuxBreadcrumbItem,
  selectors: [["rux-breadcrumb-item"]],
  inputs: {
    href: "href"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxBreadcrumbItem_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxBreadcrumbItem = __decorate([ProxyCmp({
  inputs: ["href"]
})], RuxBreadcrumbItem);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxBreadcrumbItem, [{
    type: Component,
    args: [{
      selector: "rux-breadcrumb-item",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["href"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxButton = class RuxButton2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxButton.ɵfac = function RuxButton_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxButton)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxButton.ɵcmp = ɵɵdefineComponent({
  type: RuxButton,
  selectors: [["rux-button"]],
  inputs: {
    borderless: "borderless",
    disabled: "disabled",
    icon: "icon",
    iconOnly: "iconOnly",
    secondary: "secondary",
    size: "size",
    type: "type"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxButton_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxButton = __decorate([ProxyCmp({
  inputs: ["borderless", "disabled", "icon", "iconOnly", "secondary", "size", "type"]
})], RuxButton);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxButton, [{
    type: Component,
    args: [{
      selector: "rux-button",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["borderless", "disabled", "icon", "iconOnly", "secondary", "size", "type"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxButtonGroup = class RuxButtonGroup2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxButtonGroup.ɵfac = function RuxButtonGroup_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxButtonGroup)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxButtonGroup.ɵcmp = ɵɵdefineComponent({
  type: RuxButtonGroup,
  selectors: [["rux-button-group"]],
  inputs: {
    hAlign: "hAlign"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxButtonGroup_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxButtonGroup = __decorate([ProxyCmp({
  inputs: ["hAlign"]
})], RuxButtonGroup);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxButtonGroup, [{
    type: Component,
    args: [{
      selector: "rux-button-group",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["hAlign"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxCard = class RuxCard2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxCard.ɵfac = function RuxCard_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxCard)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxCard.ɵcmp = ɵɵdefineComponent({
  type: RuxCard,
  selectors: [["rux-card"]],
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxCard_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxCard = __decorate([ProxyCmp({})], RuxCard);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxCard, [{
    type: Component,
    args: [{
      selector: "rux-card",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: []
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxCheckbox = class RuxCheckbox2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
    proxyOutputs(this, this.el, ["ruxchange", "ruxinput", "ruxfocus", "ruxblur"]);
  }
};
RuxCheckbox.ɵfac = function RuxCheckbox_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxCheckbox)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxCheckbox.ɵcmp = ɵɵdefineComponent({
  type: RuxCheckbox,
  selectors: [["rux-checkbox"]],
  inputs: {
    checked: "checked",
    disabled: "disabled",
    helpText: "helpText",
    indeterminate: "indeterminate",
    label: "label",
    name: "name",
    value: "value"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxCheckbox_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxCheckbox = __decorate([ProxyCmp({
  inputs: ["checked", "disabled", "helpText", "indeterminate", "label", "name", "value"]
})], RuxCheckbox);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxCheckbox, [{
    type: Component,
    args: [{
      selector: "rux-checkbox",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["checked", "disabled", "helpText", "indeterminate", "label", "name", "value"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxCheckboxGroup = class RuxCheckboxGroup2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxCheckboxGroup.ɵfac = function RuxCheckboxGroup_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxCheckboxGroup)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxCheckboxGroup.ɵcmp = ɵɵdefineComponent({
  type: RuxCheckboxGroup,
  selectors: [["rux-checkbox-group"]],
  inputs: {
    errorText: "errorText",
    helpText: "helpText",
    invalid: "invalid",
    label: "label",
    required: "required"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxCheckboxGroup_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxCheckboxGroup = __decorate([ProxyCmp({
  inputs: ["errorText", "helpText", "invalid", "label", "required"]
})], RuxCheckboxGroup);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxCheckboxGroup, [{
    type: Component,
    args: [{
      selector: "rux-checkbox-group",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["errorText", "helpText", "invalid", "label", "required"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxClassificationMarking = class RuxClassificationMarking2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxClassificationMarking.ɵfac = function RuxClassificationMarking_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxClassificationMarking)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxClassificationMarking.ɵcmp = ɵɵdefineComponent({
  type: RuxClassificationMarking,
  selectors: [["rux-classification-marking"]],
  inputs: {
    classification: "classification",
    label: "label",
    tag: "tag"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxClassificationMarking_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxClassificationMarking = __decorate([ProxyCmp({
  inputs: ["classification", "label", "tag"]
})], RuxClassificationMarking);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxClassificationMarking, [{
    type: Component,
    args: [{
      selector: "rux-classification-marking",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["classification", "label", "tag"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxClock = class RuxClock2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxClock.ɵfac = function RuxClock_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxClock)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxClock.ɵcmp = ɵɵdefineComponent({
  type: RuxClock,
  selectors: [["rux-clock"]],
  inputs: {
    aos: "aos",
    dateIn: "dateIn",
    hideDate: "hideDate",
    hideLabels: "hideLabels",
    hideTimezone: "hideTimezone",
    los: "los",
    small: "small",
    static: "static",
    timezone: "timezone"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxClock_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxClock = __decorate([ProxyCmp({
  inputs: ["aos", "dateIn", "hideDate", "hideLabels", "hideTimezone", "los", "small", "static", "timezone"]
})], RuxClock);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxClock, [{
    type: Component,
    args: [{
      selector: "rux-clock",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["aos", "dateIn", "hideDate", "hideLabels", "hideTimezone", "los", "small", "static", "timezone"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxContainer = class RuxContainer2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxContainer.ɵfac = function RuxContainer_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxContainer)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxContainer.ɵcmp = ɵɵdefineComponent({
  type: RuxContainer,
  selectors: [["rux-container"]],
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxContainer_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxContainer = __decorate([ProxyCmp({})], RuxContainer);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxContainer, [{
    type: Component,
    args: [{
      selector: "rux-container",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: []
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxDatetime = class RuxDatetime2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxDatetime.ɵfac = function RuxDatetime_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxDatetime)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxDatetime.ɵcmp = ɵɵdefineComponent({
  type: RuxDatetime,
  selectors: [["rux-datetime"]],
  inputs: {
    date: "date",
    day: "day",
    era: "era",
    hour: "hour",
    hour12: "hour12",
    locale: "locale",
    minute: "minute",
    month: "month",
    second: "second",
    timeZone: "timeZone",
    timeZoneName: "timeZoneName",
    weekday: "weekday",
    year: "year"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxDatetime_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxDatetime = __decorate([ProxyCmp({
  inputs: ["date", "day", "era", "hour", "hour12", "locale", "minute", "month", "second", "timeZone", "timeZoneName", "weekday", "year"]
})], RuxDatetime);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxDatetime, [{
    type: Component,
    args: [{
      selector: "rux-datetime",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["date", "day", "era", "hour", "hour12", "locale", "minute", "month", "second", "timeZone", "timeZoneName", "weekday", "year"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxDialog = class RuxDialog2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
    proxyOutputs(this, this.el, ["ruxdialogopened", "ruxdialogclosed"]);
  }
};
RuxDialog.ɵfac = function RuxDialog_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxDialog)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxDialog.ɵcmp = ɵɵdefineComponent({
  type: RuxDialog,
  selectors: [["rux-dialog"]],
  inputs: {
    clickToClose: "clickToClose",
    confirmText: "confirmText",
    denyText: "denyText",
    header: "header",
    message: "message",
    open: "open"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxDialog_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxDialog = __decorate([ProxyCmp({
  inputs: ["clickToClose", "confirmText", "denyText", "header", "message", "open"],
  methods: ["toggle", "show", "hide"]
})], RuxDialog);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxDialog, [{
    type: Component,
    args: [{
      selector: "rux-dialog",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["clickToClose", "confirmText", "denyText", "header", "message", "open"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxGlobalStatusBar = class RuxGlobalStatusBar2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxGlobalStatusBar.ɵfac = function RuxGlobalStatusBar_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxGlobalStatusBar)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxGlobalStatusBar.ɵcmp = ɵɵdefineComponent({
  type: RuxGlobalStatusBar,
  selectors: [["rux-global-status-bar"]],
  inputs: {
    appDomain: "appDomain",
    appName: "appName",
    appState: "appState",
    appStateColor: "appStateColor",
    appVersion: "appVersion",
    includeIcon: "includeIcon",
    menuIcon: "menuIcon",
    username: "username"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxGlobalStatusBar_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxGlobalStatusBar = __decorate([ProxyCmp({
  inputs: ["appDomain", "appName", "appState", "appStateColor", "appVersion", "includeIcon", "menuIcon", "username"]
})], RuxGlobalStatusBar);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxGlobalStatusBar, [{
    type: Component,
    args: [{
      selector: "rux-global-status-bar",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["appDomain", "appName", "appState", "appStateColor", "appVersion", "includeIcon", "menuIcon", "username"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIcon = class RuxIcon2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIcon.ɵfac = function RuxIcon_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIcon)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIcon.ɵcmp = ɵɵdefineComponent({
  type: RuxIcon,
  selectors: [["rux-icon"]],
  inputs: {
    icon: "icon",
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIcon_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIcon = __decorate([ProxyCmp({
  inputs: ["icon", "size"]
})], RuxIcon);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIcon, [{
    type: Component,
    args: [{
      selector: "rux-icon",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["icon", "size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIcon360 = class RuxIcon3602 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIcon360.ɵfac = function RuxIcon360_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIcon360)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIcon360.ɵcmp = ɵɵdefineComponent({
  type: RuxIcon360,
  selectors: [["rux-icon-360"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIcon360_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIcon360 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIcon360);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIcon360, [{
    type: Component,
    args: [{
      selector: "rux-icon-360",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIcon3dRotation = class RuxIcon3dRotation2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIcon3dRotation.ɵfac = function RuxIcon3dRotation_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIcon3dRotation)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIcon3dRotation.ɵcmp = ɵɵdefineComponent({
  type: RuxIcon3dRotation,
  selectors: [["rux-icon-3d-rotation"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIcon3dRotation_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIcon3dRotation = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIcon3dRotation);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIcon3dRotation, [{
    type: Component,
    args: [{
      selector: "rux-icon-3d-rotation",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIcon4k = class RuxIcon4k2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIcon4k.ɵfac = function RuxIcon4k_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIcon4k)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIcon4k.ɵcmp = ɵɵdefineComponent({
  type: RuxIcon4k,
  selectors: [["rux-icon-4k"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIcon4k_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIcon4k = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIcon4k);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIcon4k, [{
    type: Component,
    args: [{
      selector: "rux-icon-4k",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAcUnit = class RuxIconAcUnit2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAcUnit.ɵfac = function RuxIconAcUnit_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAcUnit)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAcUnit.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAcUnit,
  selectors: [["rux-icon-ac-unit"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAcUnit_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAcUnit = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAcUnit);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAcUnit, [{
    type: Component,
    args: [{
      selector: "rux-icon-ac-unit",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAccessAlarms = class RuxIconAccessAlarms2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAccessAlarms.ɵfac = function RuxIconAccessAlarms_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAccessAlarms)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAccessAlarms.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAccessAlarms,
  selectors: [["rux-icon-access-alarms"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAccessAlarms_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAccessAlarms = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAccessAlarms);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAccessAlarms, [{
    type: Component,
    args: [{
      selector: "rux-icon-access-alarms",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAccessTime = class RuxIconAccessTime2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAccessTime.ɵfac = function RuxIconAccessTime_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAccessTime)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAccessTime.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAccessTime,
  selectors: [["rux-icon-access-time"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAccessTime_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAccessTime = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAccessTime);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAccessTime, [{
    type: Component,
    args: [{
      selector: "rux-icon-access-time",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAccessibility = class RuxIconAccessibility2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAccessibility.ɵfac = function RuxIconAccessibility_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAccessibility)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAccessibility.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAccessibility,
  selectors: [["rux-icon-accessibility"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAccessibility_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAccessibility = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAccessibility);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAccessibility, [{
    type: Component,
    args: [{
      selector: "rux-icon-accessibility",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAccessibilityNew = class RuxIconAccessibilityNew2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAccessibilityNew.ɵfac = function RuxIconAccessibilityNew_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAccessibilityNew)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAccessibilityNew.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAccessibilityNew,
  selectors: [["rux-icon-accessibility-new"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAccessibilityNew_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAccessibilityNew = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAccessibilityNew);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAccessibilityNew, [{
    type: Component,
    args: [{
      selector: "rux-icon-accessibility-new",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAccessible = class RuxIconAccessible2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAccessible.ɵfac = function RuxIconAccessible_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAccessible)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAccessible.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAccessible,
  selectors: [["rux-icon-accessible"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAccessible_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAccessible = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAccessible);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAccessible, [{
    type: Component,
    args: [{
      selector: "rux-icon-accessible",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAccessibleForward = class RuxIconAccessibleForward2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAccessibleForward.ɵfac = function RuxIconAccessibleForward_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAccessibleForward)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAccessibleForward.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAccessibleForward,
  selectors: [["rux-icon-accessible-forward"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAccessibleForward_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAccessibleForward = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAccessibleForward);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAccessibleForward, [{
    type: Component,
    args: [{
      selector: "rux-icon-accessible-forward",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAccountBalance = class RuxIconAccountBalance2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAccountBalance.ɵfac = function RuxIconAccountBalance_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAccountBalance)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAccountBalance.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAccountBalance,
  selectors: [["rux-icon-account-balance"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAccountBalance_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAccountBalance = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAccountBalance);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAccountBalance, [{
    type: Component,
    args: [{
      selector: "rux-icon-account-balance",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAccountBalanceWallet = class RuxIconAccountBalanceWallet2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAccountBalanceWallet.ɵfac = function RuxIconAccountBalanceWallet_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAccountBalanceWallet)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAccountBalanceWallet.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAccountBalanceWallet,
  selectors: [["rux-icon-account-balance-wallet"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAccountBalanceWallet_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAccountBalanceWallet = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAccountBalanceWallet);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAccountBalanceWallet, [{
    type: Component,
    args: [{
      selector: "rux-icon-account-balance-wallet",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAccountBox = class RuxIconAccountBox2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAccountBox.ɵfac = function RuxIconAccountBox_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAccountBox)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAccountBox.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAccountBox,
  selectors: [["rux-icon-account-box"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAccountBox_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAccountBox = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAccountBox);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAccountBox, [{
    type: Component,
    args: [{
      selector: "rux-icon-account-box",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAccountCircle = class RuxIconAccountCircle2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAccountCircle.ɵfac = function RuxIconAccountCircle_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAccountCircle)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAccountCircle.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAccountCircle,
  selectors: [["rux-icon-account-circle"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAccountCircle_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAccountCircle = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAccountCircle);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAccountCircle, [{
    type: Component,
    args: [{
      selector: "rux-icon-account-circle",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAdb = class RuxIconAdb2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAdb.ɵfac = function RuxIconAdb_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAdb)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAdb.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAdb,
  selectors: [["rux-icon-adb"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAdb_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAdb = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAdb);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAdb, [{
    type: Component,
    args: [{
      selector: "rux-icon-adb",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAdd = class RuxIconAdd2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAdd.ɵfac = function RuxIconAdd_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAdd)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAdd.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAdd,
  selectors: [["rux-icon-add"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAdd_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAdd = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAdd);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAdd, [{
    type: Component,
    args: [{
      selector: "rux-icon-add",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAddAPhoto = class RuxIconAddAPhoto2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAddAPhoto.ɵfac = function RuxIconAddAPhoto_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAddAPhoto)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAddAPhoto.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAddAPhoto,
  selectors: [["rux-icon-add-a-photo"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAddAPhoto_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAddAPhoto = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAddAPhoto);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAddAPhoto, [{
    type: Component,
    args: [{
      selector: "rux-icon-add-a-photo",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAddAlarm = class RuxIconAddAlarm2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAddAlarm.ɵfac = function RuxIconAddAlarm_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAddAlarm)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAddAlarm.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAddAlarm,
  selectors: [["rux-icon-add-alarm"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAddAlarm_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAddAlarm = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAddAlarm);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAddAlarm, [{
    type: Component,
    args: [{
      selector: "rux-icon-add-alarm",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAddAlert = class RuxIconAddAlert2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAddAlert.ɵfac = function RuxIconAddAlert_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAddAlert)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAddAlert.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAddAlert,
  selectors: [["rux-icon-add-alert"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAddAlert_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAddAlert = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAddAlert);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAddAlert, [{
    type: Component,
    args: [{
      selector: "rux-icon-add-alert",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAddBox = class RuxIconAddBox2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAddBox.ɵfac = function RuxIconAddBox_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAddBox)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAddBox.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAddBox,
  selectors: [["rux-icon-add-box"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAddBox_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAddBox = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAddBox);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAddBox, [{
    type: Component,
    args: [{
      selector: "rux-icon-add-box",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAddCircle = class RuxIconAddCircle2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAddCircle.ɵfac = function RuxIconAddCircle_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAddCircle)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAddCircle.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAddCircle,
  selectors: [["rux-icon-add-circle"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAddCircle_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAddCircle = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAddCircle);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAddCircle, [{
    type: Component,
    args: [{
      selector: "rux-icon-add-circle",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAddCircleOutline = class RuxIconAddCircleOutline2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAddCircleOutline.ɵfac = function RuxIconAddCircleOutline_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAddCircleOutline)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAddCircleOutline.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAddCircleOutline,
  selectors: [["rux-icon-add-circle-outline"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAddCircleOutline_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAddCircleOutline = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAddCircleOutline);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAddCircleOutline, [{
    type: Component,
    args: [{
      selector: "rux-icon-add-circle-outline",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAddComment = class RuxIconAddComment2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAddComment.ɵfac = function RuxIconAddComment_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAddComment)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAddComment.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAddComment,
  selectors: [["rux-icon-add-comment"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAddComment_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAddComment = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAddComment);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAddComment, [{
    type: Component,
    args: [{
      selector: "rux-icon-add-comment",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAddLocation = class RuxIconAddLocation2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAddLocation.ɵfac = function RuxIconAddLocation_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAddLocation)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAddLocation.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAddLocation,
  selectors: [["rux-icon-add-location"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAddLocation_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAddLocation = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAddLocation);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAddLocation, [{
    type: Component,
    args: [{
      selector: "rux-icon-add-location",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAddPhotoAlternate = class RuxIconAddPhotoAlternate2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAddPhotoAlternate.ɵfac = function RuxIconAddPhotoAlternate_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAddPhotoAlternate)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAddPhotoAlternate.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAddPhotoAlternate,
  selectors: [["rux-icon-add-photo-alternate"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAddPhotoAlternate_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAddPhotoAlternate = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAddPhotoAlternate);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAddPhotoAlternate, [{
    type: Component,
    args: [{
      selector: "rux-icon-add-photo-alternate",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAddShoppingCart = class RuxIconAddShoppingCart2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAddShoppingCart.ɵfac = function RuxIconAddShoppingCart_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAddShoppingCart)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAddShoppingCart.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAddShoppingCart,
  selectors: [["rux-icon-add-shopping-cart"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAddShoppingCart_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAddShoppingCart = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAddShoppingCart);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAddShoppingCart, [{
    type: Component,
    args: [{
      selector: "rux-icon-add-shopping-cart",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAddToHomeScreen = class RuxIconAddToHomeScreen2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAddToHomeScreen.ɵfac = function RuxIconAddToHomeScreen_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAddToHomeScreen)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAddToHomeScreen.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAddToHomeScreen,
  selectors: [["rux-icon-add-to-home-screen"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAddToHomeScreen_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAddToHomeScreen = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAddToHomeScreen);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAddToHomeScreen, [{
    type: Component,
    args: [{
      selector: "rux-icon-add-to-home-screen",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAddToPhotos = class RuxIconAddToPhotos2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAddToPhotos.ɵfac = function RuxIconAddToPhotos_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAddToPhotos)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAddToPhotos.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAddToPhotos,
  selectors: [["rux-icon-add-to-photos"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAddToPhotos_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAddToPhotos = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAddToPhotos);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAddToPhotos, [{
    type: Component,
    args: [{
      selector: "rux-icon-add-to-photos",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAddToQueue = class RuxIconAddToQueue2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAddToQueue.ɵfac = function RuxIconAddToQueue_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAddToQueue)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAddToQueue.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAddToQueue,
  selectors: [["rux-icon-add-to-queue"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAddToQueue_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAddToQueue = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAddToQueue);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAddToQueue, [{
    type: Component,
    args: [{
      selector: "rux-icon-add-to-queue",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAdjust = class RuxIconAdjust2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAdjust.ɵfac = function RuxIconAdjust_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAdjust)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAdjust.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAdjust,
  selectors: [["rux-icon-adjust"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAdjust_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAdjust = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAdjust);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAdjust, [{
    type: Component,
    args: [{
      selector: "rux-icon-adjust",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAirlineSeatFlat = class RuxIconAirlineSeatFlat2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAirlineSeatFlat.ɵfac = function RuxIconAirlineSeatFlat_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAirlineSeatFlat)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAirlineSeatFlat.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAirlineSeatFlat,
  selectors: [["rux-icon-airline-seat-flat"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAirlineSeatFlat_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAirlineSeatFlat = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAirlineSeatFlat);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAirlineSeatFlat, [{
    type: Component,
    args: [{
      selector: "rux-icon-airline-seat-flat",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAirlineSeatFlatAngled = class RuxIconAirlineSeatFlatAngled2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAirlineSeatFlatAngled.ɵfac = function RuxIconAirlineSeatFlatAngled_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAirlineSeatFlatAngled)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAirlineSeatFlatAngled.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAirlineSeatFlatAngled,
  selectors: [["rux-icon-airline-seat-flat-angled"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAirlineSeatFlatAngled_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAirlineSeatFlatAngled = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAirlineSeatFlatAngled);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAirlineSeatFlatAngled, [{
    type: Component,
    args: [{
      selector: "rux-icon-airline-seat-flat-angled",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAirlineSeatIndividualSuite = class RuxIconAirlineSeatIndividualSuite2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAirlineSeatIndividualSuite.ɵfac = function RuxIconAirlineSeatIndividualSuite_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAirlineSeatIndividualSuite)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAirlineSeatIndividualSuite.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAirlineSeatIndividualSuite,
  selectors: [["rux-icon-airline-seat-individual-suite"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAirlineSeatIndividualSuite_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAirlineSeatIndividualSuite = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAirlineSeatIndividualSuite);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAirlineSeatIndividualSuite, [{
    type: Component,
    args: [{
      selector: "rux-icon-airline-seat-individual-suite",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAirlineSeatLegroomExtra = class RuxIconAirlineSeatLegroomExtra2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAirlineSeatLegroomExtra.ɵfac = function RuxIconAirlineSeatLegroomExtra_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAirlineSeatLegroomExtra)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAirlineSeatLegroomExtra.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAirlineSeatLegroomExtra,
  selectors: [["rux-icon-airline-seat-legroom-extra"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAirlineSeatLegroomExtra_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAirlineSeatLegroomExtra = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAirlineSeatLegroomExtra);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAirlineSeatLegroomExtra, [{
    type: Component,
    args: [{
      selector: "rux-icon-airline-seat-legroom-extra",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAirlineSeatLegroomNormal = class RuxIconAirlineSeatLegroomNormal2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAirlineSeatLegroomNormal.ɵfac = function RuxIconAirlineSeatLegroomNormal_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAirlineSeatLegroomNormal)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAirlineSeatLegroomNormal.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAirlineSeatLegroomNormal,
  selectors: [["rux-icon-airline-seat-legroom-normal"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAirlineSeatLegroomNormal_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAirlineSeatLegroomNormal = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAirlineSeatLegroomNormal);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAirlineSeatLegroomNormal, [{
    type: Component,
    args: [{
      selector: "rux-icon-airline-seat-legroom-normal",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAirlineSeatLegroomReduced = class RuxIconAirlineSeatLegroomReduced2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAirlineSeatLegroomReduced.ɵfac = function RuxIconAirlineSeatLegroomReduced_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAirlineSeatLegroomReduced)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAirlineSeatLegroomReduced.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAirlineSeatLegroomReduced,
  selectors: [["rux-icon-airline-seat-legroom-reduced"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAirlineSeatLegroomReduced_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAirlineSeatLegroomReduced = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAirlineSeatLegroomReduced);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAirlineSeatLegroomReduced, [{
    type: Component,
    args: [{
      selector: "rux-icon-airline-seat-legroom-reduced",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAirlineSeatReclineExtra = class RuxIconAirlineSeatReclineExtra2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAirlineSeatReclineExtra.ɵfac = function RuxIconAirlineSeatReclineExtra_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAirlineSeatReclineExtra)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAirlineSeatReclineExtra.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAirlineSeatReclineExtra,
  selectors: [["rux-icon-airline-seat-recline-extra"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAirlineSeatReclineExtra_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAirlineSeatReclineExtra = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAirlineSeatReclineExtra);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAirlineSeatReclineExtra, [{
    type: Component,
    args: [{
      selector: "rux-icon-airline-seat-recline-extra",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAirlineSeatReclineNormal = class RuxIconAirlineSeatReclineNormal2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAirlineSeatReclineNormal.ɵfac = function RuxIconAirlineSeatReclineNormal_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAirlineSeatReclineNormal)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAirlineSeatReclineNormal.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAirlineSeatReclineNormal,
  selectors: [["rux-icon-airline-seat-recline-normal"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAirlineSeatReclineNormal_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAirlineSeatReclineNormal = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAirlineSeatReclineNormal);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAirlineSeatReclineNormal, [{
    type: Component,
    args: [{
      selector: "rux-icon-airline-seat-recline-normal",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAirplanemodeActive = class RuxIconAirplanemodeActive2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAirplanemodeActive.ɵfac = function RuxIconAirplanemodeActive_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAirplanemodeActive)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAirplanemodeActive.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAirplanemodeActive,
  selectors: [["rux-icon-airplanemode-active"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAirplanemodeActive_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAirplanemodeActive = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAirplanemodeActive);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAirplanemodeActive, [{
    type: Component,
    args: [{
      selector: "rux-icon-airplanemode-active",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAirplanemodeInactive = class RuxIconAirplanemodeInactive2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAirplanemodeInactive.ɵfac = function RuxIconAirplanemodeInactive_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAirplanemodeInactive)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAirplanemodeInactive.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAirplanemodeInactive,
  selectors: [["rux-icon-airplanemode-inactive"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAirplanemodeInactive_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAirplanemodeInactive = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAirplanemodeInactive);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAirplanemodeInactive, [{
    type: Component,
    args: [{
      selector: "rux-icon-airplanemode-inactive",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAirplay = class RuxIconAirplay2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAirplay.ɵfac = function RuxIconAirplay_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAirplay)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAirplay.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAirplay,
  selectors: [["rux-icon-airplay"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAirplay_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAirplay = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAirplay);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAirplay, [{
    type: Component,
    args: [{
      selector: "rux-icon-airplay",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAirportShuttle = class RuxIconAirportShuttle2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAirportShuttle.ɵfac = function RuxIconAirportShuttle_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAirportShuttle)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAirportShuttle.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAirportShuttle,
  selectors: [["rux-icon-airport-shuttle"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAirportShuttle_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAirportShuttle = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAirportShuttle);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAirportShuttle, [{
    type: Component,
    args: [{
      selector: "rux-icon-airport-shuttle",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAlarm = class RuxIconAlarm2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAlarm.ɵfac = function RuxIconAlarm_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAlarm)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAlarm.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAlarm,
  selectors: [["rux-icon-alarm"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAlarm_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAlarm = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAlarm);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAlarm, [{
    type: Component,
    args: [{
      selector: "rux-icon-alarm",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAlarmAdd = class RuxIconAlarmAdd2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAlarmAdd.ɵfac = function RuxIconAlarmAdd_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAlarmAdd)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAlarmAdd.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAlarmAdd,
  selectors: [["rux-icon-alarm-add"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAlarmAdd_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAlarmAdd = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAlarmAdd);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAlarmAdd, [{
    type: Component,
    args: [{
      selector: "rux-icon-alarm-add",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAlarmOff = class RuxIconAlarmOff2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAlarmOff.ɵfac = function RuxIconAlarmOff_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAlarmOff)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAlarmOff.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAlarmOff,
  selectors: [["rux-icon-alarm-off"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAlarmOff_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAlarmOff = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAlarmOff);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAlarmOff, [{
    type: Component,
    args: [{
      selector: "rux-icon-alarm-off",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAlarmOn = class RuxIconAlarmOn2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAlarmOn.ɵfac = function RuxIconAlarmOn_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAlarmOn)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAlarmOn.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAlarmOn,
  selectors: [["rux-icon-alarm-on"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAlarmOn_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAlarmOn = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAlarmOn);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAlarmOn, [{
    type: Component,
    args: [{
      selector: "rux-icon-alarm-on",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAlbum = class RuxIconAlbum2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAlbum.ɵfac = function RuxIconAlbum_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAlbum)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAlbum.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAlbum,
  selectors: [["rux-icon-album"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAlbum_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAlbum = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAlbum);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAlbum, [{
    type: Component,
    args: [{
      selector: "rux-icon-album",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAllInbox = class RuxIconAllInbox2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAllInbox.ɵfac = function RuxIconAllInbox_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAllInbox)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAllInbox.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAllInbox,
  selectors: [["rux-icon-all-inbox"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAllInbox_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAllInbox = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAllInbox);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAllInbox, [{
    type: Component,
    args: [{
      selector: "rux-icon-all-inbox",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAllInclusive = class RuxIconAllInclusive2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAllInclusive.ɵfac = function RuxIconAllInclusive_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAllInclusive)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAllInclusive.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAllInclusive,
  selectors: [["rux-icon-all-inclusive"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAllInclusive_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAllInclusive = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAllInclusive);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAllInclusive, [{
    type: Component,
    args: [{
      selector: "rux-icon-all-inclusive",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAllOut = class RuxIconAllOut2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAllOut.ɵfac = function RuxIconAllOut_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAllOut)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAllOut.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAllOut,
  selectors: [["rux-icon-all-out"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAllOut_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAllOut = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAllOut);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAllOut, [{
    type: Component,
    args: [{
      selector: "rux-icon-all-out",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAlternateEmail = class RuxIconAlternateEmail2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAlternateEmail.ɵfac = function RuxIconAlternateEmail_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAlternateEmail)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAlternateEmail.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAlternateEmail,
  selectors: [["rux-icon-alternate-email"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAlternateEmail_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAlternateEmail = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAlternateEmail);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAlternateEmail, [{
    type: Component,
    args: [{
      selector: "rux-icon-alternate-email",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAltitude = class RuxIconAltitude2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAltitude.ɵfac = function RuxIconAltitude_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAltitude)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAltitude.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAltitude,
  selectors: [["rux-icon-altitude"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAltitude_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAltitude = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAltitude);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAltitude, [{
    type: Component,
    args: [{
      selector: "rux-icon-altitude",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAndroid = class RuxIconAndroid2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAndroid.ɵfac = function RuxIconAndroid_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAndroid)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAndroid.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAndroid,
  selectors: [["rux-icon-android"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAndroid_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAndroid = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAndroid);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAndroid, [{
    type: Component,
    args: [{
      selector: "rux-icon-android",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAnnouncement = class RuxIconAnnouncement2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAnnouncement.ɵfac = function RuxIconAnnouncement_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAnnouncement)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAnnouncement.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAnnouncement,
  selectors: [["rux-icon-announcement"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAnnouncement_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAnnouncement = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAnnouncement);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAnnouncement, [{
    type: Component,
    args: [{
      selector: "rux-icon-announcement",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAntenna = class RuxIconAntenna2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAntenna.ɵfac = function RuxIconAntenna_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAntenna)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAntenna.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAntenna,
  selectors: [["rux-icon-antenna"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAntenna_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAntenna = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAntenna);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAntenna, [{
    type: Component,
    args: [{
      selector: "rux-icon-antenna",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAntennaOff = class RuxIconAntennaOff2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAntennaOff.ɵfac = function RuxIconAntennaOff_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAntennaOff)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAntennaOff.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAntennaOff,
  selectors: [["rux-icon-antenna-off"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAntennaOff_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAntennaOff = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAntennaOff);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAntennaOff, [{
    type: Component,
    args: [{
      selector: "rux-icon-antenna-off",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAntennaReceive = class RuxIconAntennaReceive2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAntennaReceive.ɵfac = function RuxIconAntennaReceive_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAntennaReceive)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAntennaReceive.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAntennaReceive,
  selectors: [["rux-icon-antenna-receive"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAntennaReceive_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAntennaReceive = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAntennaReceive);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAntennaReceive, [{
    type: Component,
    args: [{
      selector: "rux-icon-antenna-receive",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAntennaTransmit = class RuxIconAntennaTransmit2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAntennaTransmit.ɵfac = function RuxIconAntennaTransmit_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAntennaTransmit)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAntennaTransmit.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAntennaTransmit,
  selectors: [["rux-icon-antenna-transmit"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAntennaTransmit_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAntennaTransmit = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAntennaTransmit);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAntennaTransmit, [{
    type: Component,
    args: [{
      selector: "rux-icon-antenna-transmit",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconApps = class RuxIconApps2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconApps.ɵfac = function RuxIconApps_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconApps)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconApps.ɵcmp = ɵɵdefineComponent({
  type: RuxIconApps,
  selectors: [["rux-icon-apps"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconApps_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconApps = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconApps);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconApps, [{
    type: Component,
    args: [{
      selector: "rux-icon-apps",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconArchive = class RuxIconArchive2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconArchive.ɵfac = function RuxIconArchive_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconArchive)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconArchive.ɵcmp = ɵɵdefineComponent({
  type: RuxIconArchive,
  selectors: [["rux-icon-archive"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconArchive_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconArchive = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconArchive);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconArchive, [{
    type: Component,
    args: [{
      selector: "rux-icon-archive",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconArrowBack = class RuxIconArrowBack2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconArrowBack.ɵfac = function RuxIconArrowBack_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconArrowBack)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconArrowBack.ɵcmp = ɵɵdefineComponent({
  type: RuxIconArrowBack,
  selectors: [["rux-icon-arrow-back"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconArrowBack_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconArrowBack = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconArrowBack);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconArrowBack, [{
    type: Component,
    args: [{
      selector: "rux-icon-arrow-back",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconArrowBackIos = class RuxIconArrowBackIos2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconArrowBackIos.ɵfac = function RuxIconArrowBackIos_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconArrowBackIos)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconArrowBackIos.ɵcmp = ɵɵdefineComponent({
  type: RuxIconArrowBackIos,
  selectors: [["rux-icon-arrow-back-ios"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconArrowBackIos_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconArrowBackIos = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconArrowBackIos);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconArrowBackIos, [{
    type: Component,
    args: [{
      selector: "rux-icon-arrow-back-ios",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconArrowDownward = class RuxIconArrowDownward2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconArrowDownward.ɵfac = function RuxIconArrowDownward_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconArrowDownward)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconArrowDownward.ɵcmp = ɵɵdefineComponent({
  type: RuxIconArrowDownward,
  selectors: [["rux-icon-arrow-downward"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconArrowDownward_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconArrowDownward = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconArrowDownward);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconArrowDownward, [{
    type: Component,
    args: [{
      selector: "rux-icon-arrow-downward",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconArrowDropDown = class RuxIconArrowDropDown2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconArrowDropDown.ɵfac = function RuxIconArrowDropDown_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconArrowDropDown)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconArrowDropDown.ɵcmp = ɵɵdefineComponent({
  type: RuxIconArrowDropDown,
  selectors: [["rux-icon-arrow-drop-down"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconArrowDropDown_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconArrowDropDown = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconArrowDropDown);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconArrowDropDown, [{
    type: Component,
    args: [{
      selector: "rux-icon-arrow-drop-down",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconArrowDropDownCircle = class RuxIconArrowDropDownCircle2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconArrowDropDownCircle.ɵfac = function RuxIconArrowDropDownCircle_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconArrowDropDownCircle)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconArrowDropDownCircle.ɵcmp = ɵɵdefineComponent({
  type: RuxIconArrowDropDownCircle,
  selectors: [["rux-icon-arrow-drop-down-circle"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconArrowDropDownCircle_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconArrowDropDownCircle = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconArrowDropDownCircle);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconArrowDropDownCircle, [{
    type: Component,
    args: [{
      selector: "rux-icon-arrow-drop-down-circle",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconArrowDropUp = class RuxIconArrowDropUp2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconArrowDropUp.ɵfac = function RuxIconArrowDropUp_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconArrowDropUp)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconArrowDropUp.ɵcmp = ɵɵdefineComponent({
  type: RuxIconArrowDropUp,
  selectors: [["rux-icon-arrow-drop-up"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconArrowDropUp_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconArrowDropUp = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconArrowDropUp);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconArrowDropUp, [{
    type: Component,
    args: [{
      selector: "rux-icon-arrow-drop-up",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconArrowForward = class RuxIconArrowForward2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconArrowForward.ɵfac = function RuxIconArrowForward_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconArrowForward)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconArrowForward.ɵcmp = ɵɵdefineComponent({
  type: RuxIconArrowForward,
  selectors: [["rux-icon-arrow-forward"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconArrowForward_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconArrowForward = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconArrowForward);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconArrowForward, [{
    type: Component,
    args: [{
      selector: "rux-icon-arrow-forward",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconArrowForwardIos = class RuxIconArrowForwardIos2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconArrowForwardIos.ɵfac = function RuxIconArrowForwardIos_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconArrowForwardIos)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconArrowForwardIos.ɵcmp = ɵɵdefineComponent({
  type: RuxIconArrowForwardIos,
  selectors: [["rux-icon-arrow-forward-ios"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconArrowForwardIos_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconArrowForwardIos = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconArrowForwardIos);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconArrowForwardIos, [{
    type: Component,
    args: [{
      selector: "rux-icon-arrow-forward-ios",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconArrowLeft = class RuxIconArrowLeft2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconArrowLeft.ɵfac = function RuxIconArrowLeft_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconArrowLeft)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconArrowLeft.ɵcmp = ɵɵdefineComponent({
  type: RuxIconArrowLeft,
  selectors: [["rux-icon-arrow-left"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconArrowLeft_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconArrowLeft = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconArrowLeft);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconArrowLeft, [{
    type: Component,
    args: [{
      selector: "rux-icon-arrow-left",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconArrowRight = class RuxIconArrowRight2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconArrowRight.ɵfac = function RuxIconArrowRight_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconArrowRight)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconArrowRight.ɵcmp = ɵɵdefineComponent({
  type: RuxIconArrowRight,
  selectors: [["rux-icon-arrow-right"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconArrowRight_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconArrowRight = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconArrowRight);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconArrowRight, [{
    type: Component,
    args: [{
      selector: "rux-icon-arrow-right",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconArrowRightAlt = class RuxIconArrowRightAlt2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconArrowRightAlt.ɵfac = function RuxIconArrowRightAlt_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconArrowRightAlt)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconArrowRightAlt.ɵcmp = ɵɵdefineComponent({
  type: RuxIconArrowRightAlt,
  selectors: [["rux-icon-arrow-right-alt"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconArrowRightAlt_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconArrowRightAlt = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconArrowRightAlt);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconArrowRightAlt, [{
    type: Component,
    args: [{
      selector: "rux-icon-arrow-right-alt",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconArrowUpward = class RuxIconArrowUpward2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconArrowUpward.ɵfac = function RuxIconArrowUpward_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconArrowUpward)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconArrowUpward.ɵcmp = ɵɵdefineComponent({
  type: RuxIconArrowUpward,
  selectors: [["rux-icon-arrow-upward"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconArrowUpward_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconArrowUpward = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconArrowUpward);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconArrowUpward, [{
    type: Component,
    args: [{
      selector: "rux-icon-arrow-upward",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconArtTrack = class RuxIconArtTrack2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconArtTrack.ɵfac = function RuxIconArtTrack_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconArtTrack)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconArtTrack.ɵcmp = ɵɵdefineComponent({
  type: RuxIconArtTrack,
  selectors: [["rux-icon-art-track"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconArtTrack_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconArtTrack = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconArtTrack);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconArtTrack, [{
    type: Component,
    args: [{
      selector: "rux-icon-art-track",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAspectRatio = class RuxIconAspectRatio2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAspectRatio.ɵfac = function RuxIconAspectRatio_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAspectRatio)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAspectRatio.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAspectRatio,
  selectors: [["rux-icon-aspect-ratio"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAspectRatio_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAspectRatio = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAspectRatio);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAspectRatio, [{
    type: Component,
    args: [{
      selector: "rux-icon-aspect-ratio",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAssessment = class RuxIconAssessment2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAssessment.ɵfac = function RuxIconAssessment_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAssessment)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAssessment.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAssessment,
  selectors: [["rux-icon-assessment"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAssessment_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAssessment = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAssessment);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAssessment, [{
    type: Component,
    args: [{
      selector: "rux-icon-assessment",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAssignment = class RuxIconAssignment2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAssignment.ɵfac = function RuxIconAssignment_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAssignment)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAssignment.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAssignment,
  selectors: [["rux-icon-assignment"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAssignment_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAssignment = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAssignment);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAssignment, [{
    type: Component,
    args: [{
      selector: "rux-icon-assignment",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAssignmentFind = class RuxIconAssignmentFind2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAssignmentFind.ɵfac = function RuxIconAssignmentFind_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAssignmentFind)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAssignmentFind.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAssignmentFind,
  selectors: [["rux-icon-assignment-find"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAssignmentFind_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAssignmentFind = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAssignmentFind);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAssignmentFind, [{
    type: Component,
    args: [{
      selector: "rux-icon-assignment-find",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAssignmentLate = class RuxIconAssignmentLate2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAssignmentLate.ɵfac = function RuxIconAssignmentLate_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAssignmentLate)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAssignmentLate.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAssignmentLate,
  selectors: [["rux-icon-assignment-late"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAssignmentLate_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAssignmentLate = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAssignmentLate);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAssignmentLate, [{
    type: Component,
    args: [{
      selector: "rux-icon-assignment-late",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAssignmentReturn = class RuxIconAssignmentReturn2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAssignmentReturn.ɵfac = function RuxIconAssignmentReturn_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAssignmentReturn)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAssignmentReturn.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAssignmentReturn,
  selectors: [["rux-icon-assignment-return"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAssignmentReturn_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAssignmentReturn = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAssignmentReturn);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAssignmentReturn, [{
    type: Component,
    args: [{
      selector: "rux-icon-assignment-return",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAssignmentReturned = class RuxIconAssignmentReturned2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAssignmentReturned.ɵfac = function RuxIconAssignmentReturned_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAssignmentReturned)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAssignmentReturned.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAssignmentReturned,
  selectors: [["rux-icon-assignment-returned"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAssignmentReturned_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAssignmentReturned = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAssignmentReturned);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAssignmentReturned, [{
    type: Component,
    args: [{
      selector: "rux-icon-assignment-returned",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAssignmentTurnedIn = class RuxIconAssignmentTurnedIn2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAssignmentTurnedIn.ɵfac = function RuxIconAssignmentTurnedIn_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAssignmentTurnedIn)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAssignmentTurnedIn.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAssignmentTurnedIn,
  selectors: [["rux-icon-assignment-turned-in"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAssignmentTurnedIn_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAssignmentTurnedIn = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAssignmentTurnedIn);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAssignmentTurnedIn, [{
    type: Component,
    args: [{
      selector: "rux-icon-assignment-turned-in",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAssistant = class RuxIconAssistant2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAssistant.ɵfac = function RuxIconAssistant_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAssistant)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAssistant.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAssistant,
  selectors: [["rux-icon-assistant"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAssistant_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAssistant = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAssistant);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAssistant, [{
    type: Component,
    args: [{
      selector: "rux-icon-assistant",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAssistantPhoto = class RuxIconAssistantPhoto2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAssistantPhoto.ɵfac = function RuxIconAssistantPhoto_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAssistantPhoto)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAssistantPhoto.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAssistantPhoto,
  selectors: [["rux-icon-assistant-photo"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAssistantPhoto_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAssistantPhoto = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAssistantPhoto);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAssistantPhoto, [{
    type: Component,
    args: [{
      selector: "rux-icon-assistant-photo",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAttachFile = class RuxIconAttachFile2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAttachFile.ɵfac = function RuxIconAttachFile_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAttachFile)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAttachFile.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAttachFile,
  selectors: [["rux-icon-attach-file"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAttachFile_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAttachFile = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAttachFile);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAttachFile, [{
    type: Component,
    args: [{
      selector: "rux-icon-attach-file",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAttachMoney = class RuxIconAttachMoney2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAttachMoney.ɵfac = function RuxIconAttachMoney_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAttachMoney)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAttachMoney.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAttachMoney,
  selectors: [["rux-icon-attach-money"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAttachMoney_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAttachMoney = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAttachMoney);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAttachMoney, [{
    type: Component,
    args: [{
      selector: "rux-icon-attach-money",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAttachment = class RuxIconAttachment2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAttachment.ɵfac = function RuxIconAttachment_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAttachment)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAttachment.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAttachment,
  selectors: [["rux-icon-attachment"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAttachment_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAttachment = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAttachment);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAttachment, [{
    type: Component,
    args: [{
      selector: "rux-icon-attachment",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAudiotrack = class RuxIconAudiotrack2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAudiotrack.ɵfac = function RuxIconAudiotrack_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAudiotrack)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAudiotrack.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAudiotrack,
  selectors: [["rux-icon-audiotrack"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAudiotrack_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAudiotrack = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAudiotrack);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAudiotrack, [{
    type: Component,
    args: [{
      selector: "rux-icon-audiotrack",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAutorenew = class RuxIconAutorenew2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAutorenew.ɵfac = function RuxIconAutorenew_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAutorenew)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAutorenew.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAutorenew,
  selectors: [["rux-icon-autorenew"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAutorenew_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAutorenew = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAutorenew);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAutorenew, [{
    type: Component,
    args: [{
      selector: "rux-icon-autorenew",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconAvTimer = class RuxIconAvTimer2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconAvTimer.ɵfac = function RuxIconAvTimer_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconAvTimer)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconAvTimer.ɵcmp = ɵɵdefineComponent({
  type: RuxIconAvTimer,
  selectors: [["rux-icon-av-timer"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconAvTimer_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconAvTimer = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconAvTimer);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconAvTimer, [{
    type: Component,
    args: [{
      selector: "rux-icon-av-timer",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBackspace = class RuxIconBackspace2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBackspace.ɵfac = function RuxIconBackspace_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBackspace)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBackspace.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBackspace,
  selectors: [["rux-icon-backspace"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBackspace_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBackspace = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBackspace);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBackspace, [{
    type: Component,
    args: [{
      selector: "rux-icon-backspace",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBackup = class RuxIconBackup2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBackup.ɵfac = function RuxIconBackup_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBackup)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBackup.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBackup,
  selectors: [["rux-icon-backup"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBackup_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBackup = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBackup);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBackup, [{
    type: Component,
    args: [{
      selector: "rux-icon-backup",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBallot = class RuxIconBallot2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBallot.ɵfac = function RuxIconBallot_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBallot)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBallot.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBallot,
  selectors: [["rux-icon-ballot"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBallot_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBallot = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBallot);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBallot, [{
    type: Component,
    args: [{
      selector: "rux-icon-ballot",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBarChart = class RuxIconBarChart2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBarChart.ɵfac = function RuxIconBarChart_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBarChart)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBarChart.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBarChart,
  selectors: [["rux-icon-bar-chart"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBarChart_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBarChart = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBarChart);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBarChart, [{
    type: Component,
    args: [{
      selector: "rux-icon-bar-chart",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBattery20 = class RuxIconBattery202 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBattery20.ɵfac = function RuxIconBattery20_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBattery20)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBattery20.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBattery20,
  selectors: [["rux-icon-battery-20"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBattery20_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBattery20 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBattery20);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBattery20, [{
    type: Component,
    args: [{
      selector: "rux-icon-battery-20",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBattery30 = class RuxIconBattery302 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBattery30.ɵfac = function RuxIconBattery30_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBattery30)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBattery30.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBattery30,
  selectors: [["rux-icon-battery-30"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBattery30_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBattery30 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBattery30);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBattery30, [{
    type: Component,
    args: [{
      selector: "rux-icon-battery-30",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBattery50 = class RuxIconBattery502 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBattery50.ɵfac = function RuxIconBattery50_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBattery50)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBattery50.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBattery50,
  selectors: [["rux-icon-battery-50"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBattery50_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBattery50 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBattery50);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBattery50, [{
    type: Component,
    args: [{
      selector: "rux-icon-battery-50",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBattery60 = class RuxIconBattery602 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBattery60.ɵfac = function RuxIconBattery60_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBattery60)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBattery60.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBattery60,
  selectors: [["rux-icon-battery-60"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBattery60_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBattery60 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBattery60);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBattery60, [{
    type: Component,
    args: [{
      selector: "rux-icon-battery-60",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBattery80 = class RuxIconBattery802 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBattery80.ɵfac = function RuxIconBattery80_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBattery80)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBattery80.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBattery80,
  selectors: [["rux-icon-battery-80"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBattery80_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBattery80 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBattery80);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBattery80, [{
    type: Component,
    args: [{
      selector: "rux-icon-battery-80",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBattery90 = class RuxIconBattery902 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBattery90.ɵfac = function RuxIconBattery90_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBattery90)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBattery90.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBattery90,
  selectors: [["rux-icon-battery-90"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBattery90_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBattery90 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBattery90);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBattery90, [{
    type: Component,
    args: [{
      selector: "rux-icon-battery-90",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBatteryAlert = class RuxIconBatteryAlert2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBatteryAlert.ɵfac = function RuxIconBatteryAlert_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBatteryAlert)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBatteryAlert.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBatteryAlert,
  selectors: [["rux-icon-battery-alert"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBatteryAlert_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBatteryAlert = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBatteryAlert);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBatteryAlert, [{
    type: Component,
    args: [{
      selector: "rux-icon-battery-alert",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBatteryCharging20 = class RuxIconBatteryCharging202 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBatteryCharging20.ɵfac = function RuxIconBatteryCharging20_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBatteryCharging20)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBatteryCharging20.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBatteryCharging20,
  selectors: [["rux-icon-battery-charging-20"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBatteryCharging20_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBatteryCharging20 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBatteryCharging20);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBatteryCharging20, [{
    type: Component,
    args: [{
      selector: "rux-icon-battery-charging-20",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBatteryCharging30 = class RuxIconBatteryCharging302 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBatteryCharging30.ɵfac = function RuxIconBatteryCharging30_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBatteryCharging30)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBatteryCharging30.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBatteryCharging30,
  selectors: [["rux-icon-battery-charging-30"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBatteryCharging30_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBatteryCharging30 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBatteryCharging30);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBatteryCharging30, [{
    type: Component,
    args: [{
      selector: "rux-icon-battery-charging-30",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBatteryCharging50 = class RuxIconBatteryCharging502 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBatteryCharging50.ɵfac = function RuxIconBatteryCharging50_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBatteryCharging50)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBatteryCharging50.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBatteryCharging50,
  selectors: [["rux-icon-battery-charging-50"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBatteryCharging50_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBatteryCharging50 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBatteryCharging50);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBatteryCharging50, [{
    type: Component,
    args: [{
      selector: "rux-icon-battery-charging-50",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBatteryCharging60 = class RuxIconBatteryCharging602 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBatteryCharging60.ɵfac = function RuxIconBatteryCharging60_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBatteryCharging60)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBatteryCharging60.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBatteryCharging60,
  selectors: [["rux-icon-battery-charging-60"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBatteryCharging60_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBatteryCharging60 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBatteryCharging60);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBatteryCharging60, [{
    type: Component,
    args: [{
      selector: "rux-icon-battery-charging-60",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBatteryCharging80 = class RuxIconBatteryCharging802 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBatteryCharging80.ɵfac = function RuxIconBatteryCharging80_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBatteryCharging80)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBatteryCharging80.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBatteryCharging80,
  selectors: [["rux-icon-battery-charging-80"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBatteryCharging80_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBatteryCharging80 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBatteryCharging80);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBatteryCharging80, [{
    type: Component,
    args: [{
      selector: "rux-icon-battery-charging-80",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBatteryCharging90 = class RuxIconBatteryCharging902 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBatteryCharging90.ɵfac = function RuxIconBatteryCharging90_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBatteryCharging90)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBatteryCharging90.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBatteryCharging90,
  selectors: [["rux-icon-battery-charging-90"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBatteryCharging90_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBatteryCharging90 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBatteryCharging90);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBatteryCharging90, [{
    type: Component,
    args: [{
      selector: "rux-icon-battery-charging-90",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBatteryChargingFull = class RuxIconBatteryChargingFull2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBatteryChargingFull.ɵfac = function RuxIconBatteryChargingFull_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBatteryChargingFull)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBatteryChargingFull.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBatteryChargingFull,
  selectors: [["rux-icon-battery-charging-full"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBatteryChargingFull_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBatteryChargingFull = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBatteryChargingFull);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBatteryChargingFull, [{
    type: Component,
    args: [{
      selector: "rux-icon-battery-charging-full",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBatteryFull = class RuxIconBatteryFull2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBatteryFull.ɵfac = function RuxIconBatteryFull_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBatteryFull)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBatteryFull.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBatteryFull,
  selectors: [["rux-icon-battery-full"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBatteryFull_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBatteryFull = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBatteryFull);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBatteryFull, [{
    type: Component,
    args: [{
      selector: "rux-icon-battery-full",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBatteryStd = class RuxIconBatteryStd2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBatteryStd.ɵfac = function RuxIconBatteryStd_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBatteryStd)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBatteryStd.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBatteryStd,
  selectors: [["rux-icon-battery-std"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBatteryStd_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBatteryStd = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBatteryStd);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBatteryStd, [{
    type: Component,
    args: [{
      selector: "rux-icon-battery-std",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBatteryUnknown = class RuxIconBatteryUnknown2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBatteryUnknown.ɵfac = function RuxIconBatteryUnknown_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBatteryUnknown)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBatteryUnknown.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBatteryUnknown,
  selectors: [["rux-icon-battery-unknown"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBatteryUnknown_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBatteryUnknown = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBatteryUnknown);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBatteryUnknown, [{
    type: Component,
    args: [{
      selector: "rux-icon-battery-unknown",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBeachAccess = class RuxIconBeachAccess2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBeachAccess.ɵfac = function RuxIconBeachAccess_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBeachAccess)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBeachAccess.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBeachAccess,
  selectors: [["rux-icon-beach-access"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBeachAccess_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBeachAccess = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBeachAccess);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBeachAccess, [{
    type: Component,
    args: [{
      selector: "rux-icon-beach-access",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBeenhere = class RuxIconBeenhere2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBeenhere.ɵfac = function RuxIconBeenhere_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBeenhere)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBeenhere.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBeenhere,
  selectors: [["rux-icon-beenhere"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBeenhere_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBeenhere = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBeenhere);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBeenhere, [{
    type: Component,
    args: [{
      selector: "rux-icon-beenhere",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBlock = class RuxIconBlock2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBlock.ɵfac = function RuxIconBlock_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBlock)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBlock.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBlock,
  selectors: [["rux-icon-block"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBlock_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBlock = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBlock);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBlock, [{
    type: Component,
    args: [{
      selector: "rux-icon-block",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBluetooth = class RuxIconBluetooth2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBluetooth.ɵfac = function RuxIconBluetooth_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBluetooth)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBluetooth.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBluetooth,
  selectors: [["rux-icon-bluetooth"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBluetooth_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBluetooth = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBluetooth);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBluetooth, [{
    type: Component,
    args: [{
      selector: "rux-icon-bluetooth",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBluetoothAudio = class RuxIconBluetoothAudio2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBluetoothAudio.ɵfac = function RuxIconBluetoothAudio_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBluetoothAudio)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBluetoothAudio.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBluetoothAudio,
  selectors: [["rux-icon-bluetooth-audio"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBluetoothAudio_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBluetoothAudio = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBluetoothAudio);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBluetoothAudio, [{
    type: Component,
    args: [{
      selector: "rux-icon-bluetooth-audio",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBluetoothConnected = class RuxIconBluetoothConnected2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBluetoothConnected.ɵfac = function RuxIconBluetoothConnected_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBluetoothConnected)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBluetoothConnected.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBluetoothConnected,
  selectors: [["rux-icon-bluetooth-connected"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBluetoothConnected_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBluetoothConnected = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBluetoothConnected);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBluetoothConnected, [{
    type: Component,
    args: [{
      selector: "rux-icon-bluetooth-connected",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBluetoothDisabled = class RuxIconBluetoothDisabled2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBluetoothDisabled.ɵfac = function RuxIconBluetoothDisabled_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBluetoothDisabled)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBluetoothDisabled.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBluetoothDisabled,
  selectors: [["rux-icon-bluetooth-disabled"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBluetoothDisabled_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBluetoothDisabled = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBluetoothDisabled);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBluetoothDisabled, [{
    type: Component,
    args: [{
      selector: "rux-icon-bluetooth-disabled",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBluetoothSearching = class RuxIconBluetoothSearching2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBluetoothSearching.ɵfac = function RuxIconBluetoothSearching_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBluetoothSearching)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBluetoothSearching.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBluetoothSearching,
  selectors: [["rux-icon-bluetooth-searching"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBluetoothSearching_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBluetoothSearching = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBluetoothSearching);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBluetoothSearching, [{
    type: Component,
    args: [{
      selector: "rux-icon-bluetooth-searching",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBlurCircular = class RuxIconBlurCircular2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBlurCircular.ɵfac = function RuxIconBlurCircular_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBlurCircular)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBlurCircular.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBlurCircular,
  selectors: [["rux-icon-blur-circular"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBlurCircular_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBlurCircular = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBlurCircular);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBlurCircular, [{
    type: Component,
    args: [{
      selector: "rux-icon-blur-circular",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBlurLinear = class RuxIconBlurLinear2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBlurLinear.ɵfac = function RuxIconBlurLinear_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBlurLinear)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBlurLinear.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBlurLinear,
  selectors: [["rux-icon-blur-linear"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBlurLinear_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBlurLinear = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBlurLinear);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBlurLinear, [{
    type: Component,
    args: [{
      selector: "rux-icon-blur-linear",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBlurOff = class RuxIconBlurOff2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBlurOff.ɵfac = function RuxIconBlurOff_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBlurOff)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBlurOff.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBlurOff,
  selectors: [["rux-icon-blur-off"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBlurOff_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBlurOff = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBlurOff);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBlurOff, [{
    type: Component,
    args: [{
      selector: "rux-icon-blur-off",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBlurOn = class RuxIconBlurOn2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBlurOn.ɵfac = function RuxIconBlurOn_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBlurOn)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBlurOn.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBlurOn,
  selectors: [["rux-icon-blur-on"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBlurOn_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBlurOn = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBlurOn);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBlurOn, [{
    type: Component,
    args: [{
      selector: "rux-icon-blur-on",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBook = class RuxIconBook2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBook.ɵfac = function RuxIconBook_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBook)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBook.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBook,
  selectors: [["rux-icon-book"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBook_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBook = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBook);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBook, [{
    type: Component,
    args: [{
      selector: "rux-icon-book",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBookmark = class RuxIconBookmark2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBookmark.ɵfac = function RuxIconBookmark_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBookmark)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBookmark.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBookmark,
  selectors: [["rux-icon-bookmark"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBookmark_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBookmark = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBookmark);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBookmark, [{
    type: Component,
    args: [{
      selector: "rux-icon-bookmark",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBookmarkBorder = class RuxIconBookmarkBorder2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBookmarkBorder.ɵfac = function RuxIconBookmarkBorder_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBookmarkBorder)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBookmarkBorder.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBookmarkBorder,
  selectors: [["rux-icon-bookmark-border"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBookmarkBorder_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBookmarkBorder = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBookmarkBorder);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBookmarkBorder, [{
    type: Component,
    args: [{
      selector: "rux-icon-bookmark-border",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBookmarks = class RuxIconBookmarks2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBookmarks.ɵfac = function RuxIconBookmarks_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBookmarks)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBookmarks.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBookmarks,
  selectors: [["rux-icon-bookmarks"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBookmarks_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBookmarks = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBookmarks);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBookmarks, [{
    type: Component,
    args: [{
      selector: "rux-icon-bookmarks",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBorderAll = class RuxIconBorderAll2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBorderAll.ɵfac = function RuxIconBorderAll_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBorderAll)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBorderAll.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBorderAll,
  selectors: [["rux-icon-border-all"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBorderAll_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBorderAll = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBorderAll);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBorderAll, [{
    type: Component,
    args: [{
      selector: "rux-icon-border-all",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBorderBottom = class RuxIconBorderBottom2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBorderBottom.ɵfac = function RuxIconBorderBottom_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBorderBottom)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBorderBottom.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBorderBottom,
  selectors: [["rux-icon-border-bottom"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBorderBottom_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBorderBottom = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBorderBottom);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBorderBottom, [{
    type: Component,
    args: [{
      selector: "rux-icon-border-bottom",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBorderClear = class RuxIconBorderClear2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBorderClear.ɵfac = function RuxIconBorderClear_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBorderClear)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBorderClear.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBorderClear,
  selectors: [["rux-icon-border-clear"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBorderClear_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBorderClear = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBorderClear);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBorderClear, [{
    type: Component,
    args: [{
      selector: "rux-icon-border-clear",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBorderColor = class RuxIconBorderColor2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBorderColor.ɵfac = function RuxIconBorderColor_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBorderColor)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBorderColor.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBorderColor,
  selectors: [["rux-icon-border-color"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBorderColor_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBorderColor = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBorderColor);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBorderColor, [{
    type: Component,
    args: [{
      selector: "rux-icon-border-color",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBorderHorizontal = class RuxIconBorderHorizontal2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBorderHorizontal.ɵfac = function RuxIconBorderHorizontal_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBorderHorizontal)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBorderHorizontal.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBorderHorizontal,
  selectors: [["rux-icon-border-horizontal"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBorderHorizontal_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBorderHorizontal = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBorderHorizontal);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBorderHorizontal, [{
    type: Component,
    args: [{
      selector: "rux-icon-border-horizontal",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBorderInner = class RuxIconBorderInner2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBorderInner.ɵfac = function RuxIconBorderInner_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBorderInner)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBorderInner.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBorderInner,
  selectors: [["rux-icon-border-inner"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBorderInner_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBorderInner = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBorderInner);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBorderInner, [{
    type: Component,
    args: [{
      selector: "rux-icon-border-inner",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBorderLeft = class RuxIconBorderLeft2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBorderLeft.ɵfac = function RuxIconBorderLeft_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBorderLeft)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBorderLeft.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBorderLeft,
  selectors: [["rux-icon-border-left"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBorderLeft_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBorderLeft = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBorderLeft);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBorderLeft, [{
    type: Component,
    args: [{
      selector: "rux-icon-border-left",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBorderOuter = class RuxIconBorderOuter2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBorderOuter.ɵfac = function RuxIconBorderOuter_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBorderOuter)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBorderOuter.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBorderOuter,
  selectors: [["rux-icon-border-outer"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBorderOuter_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBorderOuter = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBorderOuter);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBorderOuter, [{
    type: Component,
    args: [{
      selector: "rux-icon-border-outer",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBorderRight = class RuxIconBorderRight2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBorderRight.ɵfac = function RuxIconBorderRight_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBorderRight)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBorderRight.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBorderRight,
  selectors: [["rux-icon-border-right"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBorderRight_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBorderRight = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBorderRight);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBorderRight, [{
    type: Component,
    args: [{
      selector: "rux-icon-border-right",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBorderStyle = class RuxIconBorderStyle2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBorderStyle.ɵfac = function RuxIconBorderStyle_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBorderStyle)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBorderStyle.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBorderStyle,
  selectors: [["rux-icon-border-style"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBorderStyle_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBorderStyle = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBorderStyle);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBorderStyle, [{
    type: Component,
    args: [{
      selector: "rux-icon-border-style",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBorderTop = class RuxIconBorderTop2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBorderTop.ɵfac = function RuxIconBorderTop_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBorderTop)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBorderTop.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBorderTop,
  selectors: [["rux-icon-border-top"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBorderTop_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBorderTop = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBorderTop);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBorderTop, [{
    type: Component,
    args: [{
      selector: "rux-icon-border-top",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBorderVertical = class RuxIconBorderVertical2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBorderVertical.ɵfac = function RuxIconBorderVertical_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBorderVertical)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBorderVertical.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBorderVertical,
  selectors: [["rux-icon-border-vertical"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBorderVertical_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBorderVertical = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBorderVertical);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBorderVertical, [{
    type: Component,
    args: [{
      selector: "rux-icon-border-vertical",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBrandingWatermark = class RuxIconBrandingWatermark2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBrandingWatermark.ɵfac = function RuxIconBrandingWatermark_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBrandingWatermark)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBrandingWatermark.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBrandingWatermark,
  selectors: [["rux-icon-branding-watermark"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBrandingWatermark_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBrandingWatermark = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBrandingWatermark);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBrandingWatermark, [{
    type: Component,
    args: [{
      selector: "rux-icon-branding-watermark",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBrightness1 = class RuxIconBrightness12 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBrightness1.ɵfac = function RuxIconBrightness1_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBrightness1)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBrightness1.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBrightness1,
  selectors: [["rux-icon-brightness-1"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBrightness1_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBrightness1 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBrightness1);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBrightness1, [{
    type: Component,
    args: [{
      selector: "rux-icon-brightness-1",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBrightness2 = class RuxIconBrightness22 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBrightness2.ɵfac = function RuxIconBrightness2_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBrightness2)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBrightness2.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBrightness2,
  selectors: [["rux-icon-brightness-2"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBrightness2_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBrightness2 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBrightness2);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBrightness2, [{
    type: Component,
    args: [{
      selector: "rux-icon-brightness-2",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBrightness3 = class RuxIconBrightness32 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBrightness3.ɵfac = function RuxIconBrightness3_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBrightness3)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBrightness3.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBrightness3,
  selectors: [["rux-icon-brightness-3"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBrightness3_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBrightness3 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBrightness3);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBrightness3, [{
    type: Component,
    args: [{
      selector: "rux-icon-brightness-3",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBrightness4 = class RuxIconBrightness42 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBrightness4.ɵfac = function RuxIconBrightness4_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBrightness4)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBrightness4.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBrightness4,
  selectors: [["rux-icon-brightness-4"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBrightness4_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBrightness4 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBrightness4);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBrightness4, [{
    type: Component,
    args: [{
      selector: "rux-icon-brightness-4",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBrightness5 = class RuxIconBrightness52 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBrightness5.ɵfac = function RuxIconBrightness5_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBrightness5)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBrightness5.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBrightness5,
  selectors: [["rux-icon-brightness-5"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBrightness5_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBrightness5 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBrightness5);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBrightness5, [{
    type: Component,
    args: [{
      selector: "rux-icon-brightness-5",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBrightness6 = class RuxIconBrightness62 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBrightness6.ɵfac = function RuxIconBrightness6_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBrightness6)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBrightness6.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBrightness6,
  selectors: [["rux-icon-brightness-6"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBrightness6_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBrightness6 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBrightness6);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBrightness6, [{
    type: Component,
    args: [{
      selector: "rux-icon-brightness-6",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBrightness7 = class RuxIconBrightness72 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBrightness7.ɵfac = function RuxIconBrightness7_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBrightness7)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBrightness7.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBrightness7,
  selectors: [["rux-icon-brightness-7"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBrightness7_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBrightness7 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBrightness7);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBrightness7, [{
    type: Component,
    args: [{
      selector: "rux-icon-brightness-7",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBrightnessAuto = class RuxIconBrightnessAuto2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBrightnessAuto.ɵfac = function RuxIconBrightnessAuto_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBrightnessAuto)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBrightnessAuto.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBrightnessAuto,
  selectors: [["rux-icon-brightness-auto"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBrightnessAuto_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBrightnessAuto = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBrightnessAuto);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBrightnessAuto, [{
    type: Component,
    args: [{
      selector: "rux-icon-brightness-auto",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBrightnessHigh = class RuxIconBrightnessHigh2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBrightnessHigh.ɵfac = function RuxIconBrightnessHigh_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBrightnessHigh)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBrightnessHigh.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBrightnessHigh,
  selectors: [["rux-icon-brightness-high"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBrightnessHigh_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBrightnessHigh = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBrightnessHigh);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBrightnessHigh, [{
    type: Component,
    args: [{
      selector: "rux-icon-brightness-high",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBrightnessLow = class RuxIconBrightnessLow2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBrightnessLow.ɵfac = function RuxIconBrightnessLow_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBrightnessLow)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBrightnessLow.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBrightnessLow,
  selectors: [["rux-icon-brightness-low"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBrightnessLow_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBrightnessLow = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBrightnessLow);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBrightnessLow, [{
    type: Component,
    args: [{
      selector: "rux-icon-brightness-low",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBrightnessMedium = class RuxIconBrightnessMedium2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBrightnessMedium.ɵfac = function RuxIconBrightnessMedium_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBrightnessMedium)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBrightnessMedium.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBrightnessMedium,
  selectors: [["rux-icon-brightness-medium"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBrightnessMedium_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBrightnessMedium = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBrightnessMedium);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBrightnessMedium, [{
    type: Component,
    args: [{
      selector: "rux-icon-brightness-medium",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBrokenImage = class RuxIconBrokenImage2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBrokenImage.ɵfac = function RuxIconBrokenImage_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBrokenImage)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBrokenImage.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBrokenImage,
  selectors: [["rux-icon-broken-image"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBrokenImage_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBrokenImage = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBrokenImage);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBrokenImage, [{
    type: Component,
    args: [{
      selector: "rux-icon-broken-image",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBrush = class RuxIconBrush2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBrush.ɵfac = function RuxIconBrush_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBrush)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBrush.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBrush,
  selectors: [["rux-icon-brush"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBrush_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBrush = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBrush);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBrush, [{
    type: Component,
    args: [{
      selector: "rux-icon-brush",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBubbleChart = class RuxIconBubbleChart2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBubbleChart.ɵfac = function RuxIconBubbleChart_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBubbleChart)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBubbleChart.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBubbleChart,
  selectors: [["rux-icon-bubble-chart"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBubbleChart_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBubbleChart = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBubbleChart);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBubbleChart, [{
    type: Component,
    args: [{
      selector: "rux-icon-bubble-chart",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBugReport = class RuxIconBugReport2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBugReport.ɵfac = function RuxIconBugReport_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBugReport)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBugReport.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBugReport,
  selectors: [["rux-icon-bug-report"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBugReport_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBugReport = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBugReport);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBugReport, [{
    type: Component,
    args: [{
      selector: "rux-icon-bug-report",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBuild = class RuxIconBuild2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBuild.ɵfac = function RuxIconBuild_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBuild)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBuild.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBuild,
  selectors: [["rux-icon-build"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBuild_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBuild = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBuild);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBuild, [{
    type: Component,
    args: [{
      selector: "rux-icon-build",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBurstMode = class RuxIconBurstMode2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBurstMode.ɵfac = function RuxIconBurstMode_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBurstMode)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBurstMode.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBurstMode,
  selectors: [["rux-icon-burst-mode"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBurstMode_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBurstMode = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBurstMode);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBurstMode, [{
    type: Component,
    args: [{
      selector: "rux-icon-burst-mode",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBusiness = class RuxIconBusiness2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBusiness.ɵfac = function RuxIconBusiness_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBusiness)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBusiness.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBusiness,
  selectors: [["rux-icon-business"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBusiness_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBusiness = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBusiness);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBusiness, [{
    type: Component,
    args: [{
      selector: "rux-icon-business",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconBusinessCenter = class RuxIconBusinessCenter2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconBusinessCenter.ɵfac = function RuxIconBusinessCenter_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconBusinessCenter)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconBusinessCenter.ɵcmp = ɵɵdefineComponent({
  type: RuxIconBusinessCenter,
  selectors: [["rux-icon-business-center"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconBusinessCenter_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconBusinessCenter = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconBusinessCenter);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconBusinessCenter, [{
    type: Component,
    args: [{
      selector: "rux-icon-business-center",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCached = class RuxIconCached2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCached.ɵfac = function RuxIconCached_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCached)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCached.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCached,
  selectors: [["rux-icon-cached"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCached_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCached = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCached);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCached, [{
    type: Component,
    args: [{
      selector: "rux-icon-cached",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCake = class RuxIconCake2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCake.ɵfac = function RuxIconCake_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCake)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCake.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCake,
  selectors: [["rux-icon-cake"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCake_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCake = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCake);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCake, [{
    type: Component,
    args: [{
      selector: "rux-icon-cake",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCalendarToday = class RuxIconCalendarToday2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCalendarToday.ɵfac = function RuxIconCalendarToday_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCalendarToday)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCalendarToday.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCalendarToday,
  selectors: [["rux-icon-calendar-today"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCalendarToday_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCalendarToday = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCalendarToday);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCalendarToday, [{
    type: Component,
    args: [{
      selector: "rux-icon-calendar-today",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCalendarViewDay = class RuxIconCalendarViewDay2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCalendarViewDay.ɵfac = function RuxIconCalendarViewDay_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCalendarViewDay)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCalendarViewDay.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCalendarViewDay,
  selectors: [["rux-icon-calendar-view-day"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCalendarViewDay_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCalendarViewDay = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCalendarViewDay);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCalendarViewDay, [{
    type: Component,
    args: [{
      selector: "rux-icon-calendar-view-day",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCall = class RuxIconCall2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCall.ɵfac = function RuxIconCall_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCall)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCall.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCall,
  selectors: [["rux-icon-call"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCall_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCall = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCall);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCall, [{
    type: Component,
    args: [{
      selector: "rux-icon-call",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCallEnd = class RuxIconCallEnd2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCallEnd.ɵfac = function RuxIconCallEnd_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCallEnd)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCallEnd.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCallEnd,
  selectors: [["rux-icon-call-end"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCallEnd_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCallEnd = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCallEnd);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCallEnd, [{
    type: Component,
    args: [{
      selector: "rux-icon-call-end",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCallMade = class RuxIconCallMade2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCallMade.ɵfac = function RuxIconCallMade_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCallMade)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCallMade.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCallMade,
  selectors: [["rux-icon-call-made"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCallMade_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCallMade = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCallMade);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCallMade, [{
    type: Component,
    args: [{
      selector: "rux-icon-call-made",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCallMerge = class RuxIconCallMerge2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCallMerge.ɵfac = function RuxIconCallMerge_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCallMerge)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCallMerge.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCallMerge,
  selectors: [["rux-icon-call-merge"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCallMerge_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCallMerge = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCallMerge);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCallMerge, [{
    type: Component,
    args: [{
      selector: "rux-icon-call-merge",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCallMissed = class RuxIconCallMissed2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCallMissed.ɵfac = function RuxIconCallMissed_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCallMissed)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCallMissed.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCallMissed,
  selectors: [["rux-icon-call-missed"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCallMissed_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCallMissed = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCallMissed);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCallMissed, [{
    type: Component,
    args: [{
      selector: "rux-icon-call-missed",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCallMissedOutgoing = class RuxIconCallMissedOutgoing2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCallMissedOutgoing.ɵfac = function RuxIconCallMissedOutgoing_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCallMissedOutgoing)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCallMissedOutgoing.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCallMissedOutgoing,
  selectors: [["rux-icon-call-missed-outgoing"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCallMissedOutgoing_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCallMissedOutgoing = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCallMissedOutgoing);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCallMissedOutgoing, [{
    type: Component,
    args: [{
      selector: "rux-icon-call-missed-outgoing",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCallReceived = class RuxIconCallReceived2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCallReceived.ɵfac = function RuxIconCallReceived_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCallReceived)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCallReceived.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCallReceived,
  selectors: [["rux-icon-call-received"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCallReceived_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCallReceived = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCallReceived);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCallReceived, [{
    type: Component,
    args: [{
      selector: "rux-icon-call-received",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCallSplit = class RuxIconCallSplit2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCallSplit.ɵfac = function RuxIconCallSplit_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCallSplit)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCallSplit.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCallSplit,
  selectors: [["rux-icon-call-split"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCallSplit_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCallSplit = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCallSplit);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCallSplit, [{
    type: Component,
    args: [{
      selector: "rux-icon-call-split",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCallToAction = class RuxIconCallToAction2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCallToAction.ɵfac = function RuxIconCallToAction_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCallToAction)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCallToAction.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCallToAction,
  selectors: [["rux-icon-call-to-action"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCallToAction_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCallToAction = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCallToAction);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCallToAction, [{
    type: Component,
    args: [{
      selector: "rux-icon-call-to-action",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCamera = class RuxIconCamera2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCamera.ɵfac = function RuxIconCamera_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCamera)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCamera.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCamera,
  selectors: [["rux-icon-camera"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCamera_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCamera = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCamera);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCamera, [{
    type: Component,
    args: [{
      selector: "rux-icon-camera",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCameraAlt = class RuxIconCameraAlt2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCameraAlt.ɵfac = function RuxIconCameraAlt_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCameraAlt)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCameraAlt.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCameraAlt,
  selectors: [["rux-icon-camera-alt"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCameraAlt_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCameraAlt = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCameraAlt);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCameraAlt, [{
    type: Component,
    args: [{
      selector: "rux-icon-camera-alt",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCameraEnhance = class RuxIconCameraEnhance2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCameraEnhance.ɵfac = function RuxIconCameraEnhance_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCameraEnhance)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCameraEnhance.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCameraEnhance,
  selectors: [["rux-icon-camera-enhance"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCameraEnhance_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCameraEnhance = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCameraEnhance);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCameraEnhance, [{
    type: Component,
    args: [{
      selector: "rux-icon-camera-enhance",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCameraFront = class RuxIconCameraFront2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCameraFront.ɵfac = function RuxIconCameraFront_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCameraFront)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCameraFront.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCameraFront,
  selectors: [["rux-icon-camera-front"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCameraFront_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCameraFront = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCameraFront);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCameraFront, [{
    type: Component,
    args: [{
      selector: "rux-icon-camera-front",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCameraRear = class RuxIconCameraRear2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCameraRear.ɵfac = function RuxIconCameraRear_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCameraRear)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCameraRear.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCameraRear,
  selectors: [["rux-icon-camera-rear"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCameraRear_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCameraRear = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCameraRear);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCameraRear, [{
    type: Component,
    args: [{
      selector: "rux-icon-camera-rear",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCameraRoll = class RuxIconCameraRoll2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCameraRoll.ɵfac = function RuxIconCameraRoll_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCameraRoll)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCameraRoll.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCameraRoll,
  selectors: [["rux-icon-camera-roll"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCameraRoll_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCameraRoll = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCameraRoll);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCameraRoll, [{
    type: Component,
    args: [{
      selector: "rux-icon-camera-roll",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCancel = class RuxIconCancel2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCancel.ɵfac = function RuxIconCancel_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCancel)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCancel.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCancel,
  selectors: [["rux-icon-cancel"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCancel_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCancel = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCancel);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCancel, [{
    type: Component,
    args: [{
      selector: "rux-icon-cancel",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCancelPresentation = class RuxIconCancelPresentation2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCancelPresentation.ɵfac = function RuxIconCancelPresentation_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCancelPresentation)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCancelPresentation.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCancelPresentation,
  selectors: [["rux-icon-cancel-presentation"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCancelPresentation_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCancelPresentation = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCancelPresentation);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCancelPresentation, [{
    type: Component,
    args: [{
      selector: "rux-icon-cancel-presentation",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCardGiftcard = class RuxIconCardGiftcard2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCardGiftcard.ɵfac = function RuxIconCardGiftcard_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCardGiftcard)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCardGiftcard.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCardGiftcard,
  selectors: [["rux-icon-card-giftcard"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCardGiftcard_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCardGiftcard = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCardGiftcard);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCardGiftcard, [{
    type: Component,
    args: [{
      selector: "rux-icon-card-giftcard",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCardMembership = class RuxIconCardMembership2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCardMembership.ɵfac = function RuxIconCardMembership_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCardMembership)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCardMembership.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCardMembership,
  selectors: [["rux-icon-card-membership"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCardMembership_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCardMembership = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCardMembership);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCardMembership, [{
    type: Component,
    args: [{
      selector: "rux-icon-card-membership",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCardTravel = class RuxIconCardTravel2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCardTravel.ɵfac = function RuxIconCardTravel_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCardTravel)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCardTravel.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCardTravel,
  selectors: [["rux-icon-card-travel"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCardTravel_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCardTravel = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCardTravel);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCardTravel, [{
    type: Component,
    args: [{
      selector: "rux-icon-card-travel",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCasino = class RuxIconCasino2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCasino.ɵfac = function RuxIconCasino_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCasino)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCasino.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCasino,
  selectors: [["rux-icon-casino"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCasino_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCasino = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCasino);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCasino, [{
    type: Component,
    args: [{
      selector: "rux-icon-casino",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCast = class RuxIconCast2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCast.ɵfac = function RuxIconCast_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCast)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCast.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCast,
  selectors: [["rux-icon-cast"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCast_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCast = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCast);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCast, [{
    type: Component,
    args: [{
      selector: "rux-icon-cast",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCastConnected = class RuxIconCastConnected2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCastConnected.ɵfac = function RuxIconCastConnected_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCastConnected)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCastConnected.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCastConnected,
  selectors: [["rux-icon-cast-connected"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCastConnected_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCastConnected = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCastConnected);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCastConnected, [{
    type: Component,
    args: [{
      selector: "rux-icon-cast-connected",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCastForEducation = class RuxIconCastForEducation2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCastForEducation.ɵfac = function RuxIconCastForEducation_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCastForEducation)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCastForEducation.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCastForEducation,
  selectors: [["rux-icon-cast-for-education"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCastForEducation_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCastForEducation = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCastForEducation);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCastForEducation, [{
    type: Component,
    args: [{
      selector: "rux-icon-cast-for-education",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCategory = class RuxIconCategory2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCategory.ɵfac = function RuxIconCategory_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCategory)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCategory.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCategory,
  selectors: [["rux-icon-category"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCategory_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCategory = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCategory);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCategory, [{
    type: Component,
    args: [{
      selector: "rux-icon-category",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCellWifi = class RuxIconCellWifi2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCellWifi.ɵfac = function RuxIconCellWifi_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCellWifi)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCellWifi.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCellWifi,
  selectors: [["rux-icon-cell-wifi"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCellWifi_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCellWifi = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCellWifi);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCellWifi, [{
    type: Component,
    args: [{
      selector: "rux-icon-cell-wifi",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCenterFocusStrong = class RuxIconCenterFocusStrong2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCenterFocusStrong.ɵfac = function RuxIconCenterFocusStrong_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCenterFocusStrong)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCenterFocusStrong.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCenterFocusStrong,
  selectors: [["rux-icon-center-focus-strong"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCenterFocusStrong_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCenterFocusStrong = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCenterFocusStrong);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCenterFocusStrong, [{
    type: Component,
    args: [{
      selector: "rux-icon-center-focus-strong",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCenterFocusWeak = class RuxIconCenterFocusWeak2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCenterFocusWeak.ɵfac = function RuxIconCenterFocusWeak_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCenterFocusWeak)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCenterFocusWeak.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCenterFocusWeak,
  selectors: [["rux-icon-center-focus-weak"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCenterFocusWeak_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCenterFocusWeak = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCenterFocusWeak);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCenterFocusWeak, [{
    type: Component,
    args: [{
      selector: "rux-icon-center-focus-weak",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconChangeHistory = class RuxIconChangeHistory2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconChangeHistory.ɵfac = function RuxIconChangeHistory_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconChangeHistory)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconChangeHistory.ɵcmp = ɵɵdefineComponent({
  type: RuxIconChangeHistory,
  selectors: [["rux-icon-change-history"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconChangeHistory_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconChangeHistory = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconChangeHistory);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconChangeHistory, [{
    type: Component,
    args: [{
      selector: "rux-icon-change-history",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconChat = class RuxIconChat2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconChat.ɵfac = function RuxIconChat_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconChat)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconChat.ɵcmp = ɵɵdefineComponent({
  type: RuxIconChat,
  selectors: [["rux-icon-chat"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconChat_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconChat = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconChat);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconChat, [{
    type: Component,
    args: [{
      selector: "rux-icon-chat",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconChatBubble = class RuxIconChatBubble2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconChatBubble.ɵfac = function RuxIconChatBubble_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconChatBubble)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconChatBubble.ɵcmp = ɵɵdefineComponent({
  type: RuxIconChatBubble,
  selectors: [["rux-icon-chat-bubble"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconChatBubble_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconChatBubble = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconChatBubble);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconChatBubble, [{
    type: Component,
    args: [{
      selector: "rux-icon-chat-bubble",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconChatBubbleOutline = class RuxIconChatBubbleOutline2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconChatBubbleOutline.ɵfac = function RuxIconChatBubbleOutline_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconChatBubbleOutline)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconChatBubbleOutline.ɵcmp = ɵɵdefineComponent({
  type: RuxIconChatBubbleOutline,
  selectors: [["rux-icon-chat-bubble-outline"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconChatBubbleOutline_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconChatBubbleOutline = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconChatBubbleOutline);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconChatBubbleOutline, [{
    type: Component,
    args: [{
      selector: "rux-icon-chat-bubble-outline",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCheck = class RuxIconCheck2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCheck.ɵfac = function RuxIconCheck_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCheck)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCheck.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCheck,
  selectors: [["rux-icon-check"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCheck_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCheck = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCheck);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCheck, [{
    type: Component,
    args: [{
      selector: "rux-icon-check",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCheckBox = class RuxIconCheckBox2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCheckBox.ɵfac = function RuxIconCheckBox_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCheckBox)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCheckBox.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCheckBox,
  selectors: [["rux-icon-check-box"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCheckBox_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCheckBox = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCheckBox);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCheckBox, [{
    type: Component,
    args: [{
      selector: "rux-icon-check-box",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCheckBoxOutlineBlank = class RuxIconCheckBoxOutlineBlank2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCheckBoxOutlineBlank.ɵfac = function RuxIconCheckBoxOutlineBlank_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCheckBoxOutlineBlank)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCheckBoxOutlineBlank.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCheckBoxOutlineBlank,
  selectors: [["rux-icon-check-box-outline-blank"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCheckBoxOutlineBlank_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCheckBoxOutlineBlank = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCheckBoxOutlineBlank);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCheckBoxOutlineBlank, [{
    type: Component,
    args: [{
      selector: "rux-icon-check-box-outline-blank",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCheckCircle = class RuxIconCheckCircle2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCheckCircle.ɵfac = function RuxIconCheckCircle_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCheckCircle)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCheckCircle.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCheckCircle,
  selectors: [["rux-icon-check-circle"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCheckCircle_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCheckCircle = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCheckCircle);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCheckCircle, [{
    type: Component,
    args: [{
      selector: "rux-icon-check-circle",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCheckCircleOutline = class RuxIconCheckCircleOutline2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCheckCircleOutline.ɵfac = function RuxIconCheckCircleOutline_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCheckCircleOutline)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCheckCircleOutline.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCheckCircleOutline,
  selectors: [["rux-icon-check-circle-outline"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCheckCircleOutline_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCheckCircleOutline = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCheckCircleOutline);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCheckCircleOutline, [{
    type: Component,
    args: [{
      selector: "rux-icon-check-circle-outline",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconChevronLeft = class RuxIconChevronLeft2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconChevronLeft.ɵfac = function RuxIconChevronLeft_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconChevronLeft)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconChevronLeft.ɵcmp = ɵɵdefineComponent({
  type: RuxIconChevronLeft,
  selectors: [["rux-icon-chevron-left"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconChevronLeft_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconChevronLeft = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconChevronLeft);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconChevronLeft, [{
    type: Component,
    args: [{
      selector: "rux-icon-chevron-left",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconChevronRight = class RuxIconChevronRight2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconChevronRight.ɵfac = function RuxIconChevronRight_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconChevronRight)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconChevronRight.ɵcmp = ɵɵdefineComponent({
  type: RuxIconChevronRight,
  selectors: [["rux-icon-chevron-right"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconChevronRight_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconChevronRight = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconChevronRight);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconChevronRight, [{
    type: Component,
    args: [{
      selector: "rux-icon-chevron-right",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconChildCare = class RuxIconChildCare2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconChildCare.ɵfac = function RuxIconChildCare_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconChildCare)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconChildCare.ɵcmp = ɵɵdefineComponent({
  type: RuxIconChildCare,
  selectors: [["rux-icon-child-care"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconChildCare_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconChildCare = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconChildCare);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconChildCare, [{
    type: Component,
    args: [{
      selector: "rux-icon-child-care",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconChildFriendly = class RuxIconChildFriendly2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconChildFriendly.ɵfac = function RuxIconChildFriendly_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconChildFriendly)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconChildFriendly.ɵcmp = ɵɵdefineComponent({
  type: RuxIconChildFriendly,
  selectors: [["rux-icon-child-friendly"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconChildFriendly_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconChildFriendly = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconChildFriendly);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconChildFriendly, [{
    type: Component,
    args: [{
      selector: "rux-icon-child-friendly",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconChromeReaderMode = class RuxIconChromeReaderMode2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconChromeReaderMode.ɵfac = function RuxIconChromeReaderMode_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconChromeReaderMode)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconChromeReaderMode.ɵcmp = ɵɵdefineComponent({
  type: RuxIconChromeReaderMode,
  selectors: [["rux-icon-chrome-reader-mode"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconChromeReaderMode_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconChromeReaderMode = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconChromeReaderMode);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconChromeReaderMode, [{
    type: Component,
    args: [{
      selector: "rux-icon-chrome-reader-mode",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconClass = class RuxIconClass2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconClass.ɵfac = function RuxIconClass_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconClass)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconClass.ɵcmp = ɵɵdefineComponent({
  type: RuxIconClass,
  selectors: [["rux-icon-class"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconClass_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconClass = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconClass);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconClass, [{
    type: Component,
    args: [{
      selector: "rux-icon-class",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconClear = class RuxIconClear2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconClear.ɵfac = function RuxIconClear_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconClear)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconClear.ɵcmp = ɵɵdefineComponent({
  type: RuxIconClear,
  selectors: [["rux-icon-clear"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconClear_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconClear = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconClear);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconClear, [{
    type: Component,
    args: [{
      selector: "rux-icon-clear",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconClearAll = class RuxIconClearAll2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconClearAll.ɵfac = function RuxIconClearAll_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconClearAll)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconClearAll.ɵcmp = ɵɵdefineComponent({
  type: RuxIconClearAll,
  selectors: [["rux-icon-clear-all"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconClearAll_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconClearAll = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconClearAll);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconClearAll, [{
    type: Component,
    args: [{
      selector: "rux-icon-clear-all",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconClose = class RuxIconClose2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconClose.ɵfac = function RuxIconClose_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconClose)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconClose.ɵcmp = ɵɵdefineComponent({
  type: RuxIconClose,
  selectors: [["rux-icon-close"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconClose_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconClose = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconClose);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconClose, [{
    type: Component,
    args: [{
      selector: "rux-icon-close",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconClosedCaption = class RuxIconClosedCaption2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconClosedCaption.ɵfac = function RuxIconClosedCaption_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconClosedCaption)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconClosedCaption.ɵcmp = ɵɵdefineComponent({
  type: RuxIconClosedCaption,
  selectors: [["rux-icon-closed-caption"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconClosedCaption_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconClosedCaption = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconClosedCaption);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconClosedCaption, [{
    type: Component,
    args: [{
      selector: "rux-icon-closed-caption",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCloud = class RuxIconCloud2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCloud.ɵfac = function RuxIconCloud_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCloud)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCloud.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCloud,
  selectors: [["rux-icon-cloud"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCloud_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCloud = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCloud);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCloud, [{
    type: Component,
    args: [{
      selector: "rux-icon-cloud",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCloudCircle = class RuxIconCloudCircle2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCloudCircle.ɵfac = function RuxIconCloudCircle_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCloudCircle)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCloudCircle.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCloudCircle,
  selectors: [["rux-icon-cloud-circle"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCloudCircle_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCloudCircle = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCloudCircle);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCloudCircle, [{
    type: Component,
    args: [{
      selector: "rux-icon-cloud-circle",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCloudDone = class RuxIconCloudDone2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCloudDone.ɵfac = function RuxIconCloudDone_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCloudDone)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCloudDone.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCloudDone,
  selectors: [["rux-icon-cloud-done"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCloudDone_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCloudDone = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCloudDone);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCloudDone, [{
    type: Component,
    args: [{
      selector: "rux-icon-cloud-done",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCloudDownload = class RuxIconCloudDownload2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCloudDownload.ɵfac = function RuxIconCloudDownload_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCloudDownload)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCloudDownload.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCloudDownload,
  selectors: [["rux-icon-cloud-download"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCloudDownload_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCloudDownload = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCloudDownload);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCloudDownload, [{
    type: Component,
    args: [{
      selector: "rux-icon-cloud-download",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCloudOff = class RuxIconCloudOff2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCloudOff.ɵfac = function RuxIconCloudOff_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCloudOff)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCloudOff.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCloudOff,
  selectors: [["rux-icon-cloud-off"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCloudOff_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCloudOff = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCloudOff);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCloudOff, [{
    type: Component,
    args: [{
      selector: "rux-icon-cloud-off",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCloudQueue = class RuxIconCloudQueue2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCloudQueue.ɵfac = function RuxIconCloudQueue_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCloudQueue)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCloudQueue.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCloudQueue,
  selectors: [["rux-icon-cloud-queue"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCloudQueue_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCloudQueue = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCloudQueue);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCloudQueue, [{
    type: Component,
    args: [{
      selector: "rux-icon-cloud-queue",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCloudUpload = class RuxIconCloudUpload2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCloudUpload.ɵfac = function RuxIconCloudUpload_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCloudUpload)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCloudUpload.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCloudUpload,
  selectors: [["rux-icon-cloud-upload"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCloudUpload_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCloudUpload = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCloudUpload);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCloudUpload, [{
    type: Component,
    args: [{
      selector: "rux-icon-cloud-upload",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCode = class RuxIconCode2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCode.ɵfac = function RuxIconCode_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCode)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCode.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCode,
  selectors: [["rux-icon-code"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCode_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCode = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCode);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCode, [{
    type: Component,
    args: [{
      selector: "rux-icon-code",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCollections = class RuxIconCollections2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCollections.ɵfac = function RuxIconCollections_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCollections)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCollections.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCollections,
  selectors: [["rux-icon-collections"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCollections_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCollections = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCollections);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCollections, [{
    type: Component,
    args: [{
      selector: "rux-icon-collections",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCollectionsBookmark = class RuxIconCollectionsBookmark2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCollectionsBookmark.ɵfac = function RuxIconCollectionsBookmark_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCollectionsBookmark)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCollectionsBookmark.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCollectionsBookmark,
  selectors: [["rux-icon-collections-bookmark"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCollectionsBookmark_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCollectionsBookmark = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCollectionsBookmark);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCollectionsBookmark, [{
    type: Component,
    args: [{
      selector: "rux-icon-collections-bookmark",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconColorLens = class RuxIconColorLens2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconColorLens.ɵfac = function RuxIconColorLens_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconColorLens)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconColorLens.ɵcmp = ɵɵdefineComponent({
  type: RuxIconColorLens,
  selectors: [["rux-icon-color-lens"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconColorLens_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconColorLens = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconColorLens);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconColorLens, [{
    type: Component,
    args: [{
      selector: "rux-icon-color-lens",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconColorize = class RuxIconColorize2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconColorize.ɵfac = function RuxIconColorize_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconColorize)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconColorize.ɵcmp = ɵɵdefineComponent({
  type: RuxIconColorize,
  selectors: [["rux-icon-colorize"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconColorize_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconColorize = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconColorize);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconColorize, [{
    type: Component,
    args: [{
      selector: "rux-icon-colorize",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconComment = class RuxIconComment2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconComment.ɵfac = function RuxIconComment_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconComment)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconComment.ɵcmp = ɵɵdefineComponent({
  type: RuxIconComment,
  selectors: [["rux-icon-comment"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconComment_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconComment = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconComment);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconComment, [{
    type: Component,
    args: [{
      selector: "rux-icon-comment",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCommute = class RuxIconCommute2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCommute.ɵfac = function RuxIconCommute_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCommute)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCommute.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCommute,
  selectors: [["rux-icon-commute"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCommute_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCommute = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCommute);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCommute, [{
    type: Component,
    args: [{
      selector: "rux-icon-commute",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCompare = class RuxIconCompare2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCompare.ɵfac = function RuxIconCompare_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCompare)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCompare.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCompare,
  selectors: [["rux-icon-compare"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCompare_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCompare = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCompare);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCompare, [{
    type: Component,
    args: [{
      selector: "rux-icon-compare",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCompareArrows = class RuxIconCompareArrows2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCompareArrows.ɵfac = function RuxIconCompareArrows_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCompareArrows)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCompareArrows.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCompareArrows,
  selectors: [["rux-icon-compare-arrows"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCompareArrows_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCompareArrows = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCompareArrows);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCompareArrows, [{
    type: Component,
    args: [{
      selector: "rux-icon-compare-arrows",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCompassCalibration = class RuxIconCompassCalibration2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCompassCalibration.ɵfac = function RuxIconCompassCalibration_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCompassCalibration)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCompassCalibration.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCompassCalibration,
  selectors: [["rux-icon-compass-calibration"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCompassCalibration_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCompassCalibration = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCompassCalibration);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCompassCalibration, [{
    type: Component,
    args: [{
      selector: "rux-icon-compass-calibration",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconComputer = class RuxIconComputer2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconComputer.ɵfac = function RuxIconComputer_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconComputer)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconComputer.ɵcmp = ɵɵdefineComponent({
  type: RuxIconComputer,
  selectors: [["rux-icon-computer"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconComputer_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconComputer = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconComputer);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconComputer, [{
    type: Component,
    args: [{
      selector: "rux-icon-computer",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconConfirmationNumber = class RuxIconConfirmationNumber2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconConfirmationNumber.ɵfac = function RuxIconConfirmationNumber_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconConfirmationNumber)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconConfirmationNumber.ɵcmp = ɵɵdefineComponent({
  type: RuxIconConfirmationNumber,
  selectors: [["rux-icon-confirmation-number"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconConfirmationNumber_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconConfirmationNumber = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconConfirmationNumber);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconConfirmationNumber, [{
    type: Component,
    args: [{
      selector: "rux-icon-confirmation-number",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconContactMail = class RuxIconContactMail2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconContactMail.ɵfac = function RuxIconContactMail_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconContactMail)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconContactMail.ɵcmp = ɵɵdefineComponent({
  type: RuxIconContactMail,
  selectors: [["rux-icon-contact-mail"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconContactMail_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconContactMail = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconContactMail);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconContactMail, [{
    type: Component,
    args: [{
      selector: "rux-icon-contact-mail",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconContactPhone = class RuxIconContactPhone2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconContactPhone.ɵfac = function RuxIconContactPhone_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconContactPhone)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconContactPhone.ɵcmp = ɵɵdefineComponent({
  type: RuxIconContactPhone,
  selectors: [["rux-icon-contact-phone"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconContactPhone_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconContactPhone = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconContactPhone);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconContactPhone, [{
    type: Component,
    args: [{
      selector: "rux-icon-contact-phone",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconContactSupport = class RuxIconContactSupport2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconContactSupport.ɵfac = function RuxIconContactSupport_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconContactSupport)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconContactSupport.ɵcmp = ɵɵdefineComponent({
  type: RuxIconContactSupport,
  selectors: [["rux-icon-contact-support"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconContactSupport_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconContactSupport = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconContactSupport);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconContactSupport, [{
    type: Component,
    args: [{
      selector: "rux-icon-contact-support",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconContacts = class RuxIconContacts2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconContacts.ɵfac = function RuxIconContacts_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconContacts)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconContacts.ɵcmp = ɵɵdefineComponent({
  type: RuxIconContacts,
  selectors: [["rux-icon-contacts"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconContacts_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconContacts = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconContacts);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconContacts, [{
    type: Component,
    args: [{
      selector: "rux-icon-contacts",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconControlCamera = class RuxIconControlCamera2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconControlCamera.ɵfac = function RuxIconControlCamera_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconControlCamera)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconControlCamera.ɵcmp = ɵɵdefineComponent({
  type: RuxIconControlCamera,
  selectors: [["rux-icon-control-camera"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconControlCamera_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconControlCamera = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconControlCamera);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconControlCamera, [{
    type: Component,
    args: [{
      selector: "rux-icon-control-camera",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconControlPoint = class RuxIconControlPoint2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconControlPoint.ɵfac = function RuxIconControlPoint_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconControlPoint)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconControlPoint.ɵcmp = ɵɵdefineComponent({
  type: RuxIconControlPoint,
  selectors: [["rux-icon-control-point"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconControlPoint_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconControlPoint = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconControlPoint);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconControlPoint, [{
    type: Component,
    args: [{
      selector: "rux-icon-control-point",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconControlPointDuplicate = class RuxIconControlPointDuplicate2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconControlPointDuplicate.ɵfac = function RuxIconControlPointDuplicate_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconControlPointDuplicate)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconControlPointDuplicate.ɵcmp = ɵɵdefineComponent({
  type: RuxIconControlPointDuplicate,
  selectors: [["rux-icon-control-point-duplicate"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconControlPointDuplicate_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconControlPointDuplicate = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconControlPointDuplicate);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconControlPointDuplicate, [{
    type: Component,
    args: [{
      selector: "rux-icon-control-point-duplicate",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCopyright = class RuxIconCopyright2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCopyright.ɵfac = function RuxIconCopyright_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCopyright)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCopyright.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCopyright,
  selectors: [["rux-icon-copyright"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCopyright_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCopyright = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCopyright);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCopyright, [{
    type: Component,
    args: [{
      selector: "rux-icon-copyright",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCreate = class RuxIconCreate2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCreate.ɵfac = function RuxIconCreate_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCreate)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCreate.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCreate,
  selectors: [["rux-icon-create"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCreate_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCreate = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCreate);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCreate, [{
    type: Component,
    args: [{
      selector: "rux-icon-create",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCreateNewFolder = class RuxIconCreateNewFolder2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCreateNewFolder.ɵfac = function RuxIconCreateNewFolder_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCreateNewFolder)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCreateNewFolder.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCreateNewFolder,
  selectors: [["rux-icon-create-new-folder"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCreateNewFolder_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCreateNewFolder = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCreateNewFolder);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCreateNewFolder, [{
    type: Component,
    args: [{
      selector: "rux-icon-create-new-folder",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCreditCard = class RuxIconCreditCard2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCreditCard.ɵfac = function RuxIconCreditCard_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCreditCard)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCreditCard.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCreditCard,
  selectors: [["rux-icon-credit-card"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCreditCard_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCreditCard = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCreditCard);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCreditCard, [{
    type: Component,
    args: [{
      selector: "rux-icon-credit-card",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCrop = class RuxIconCrop2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCrop.ɵfac = function RuxIconCrop_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCrop)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCrop.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCrop,
  selectors: [["rux-icon-crop"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCrop_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCrop = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCrop);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCrop, [{
    type: Component,
    args: [{
      selector: "rux-icon-crop",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCrop169 = class RuxIconCrop1692 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCrop169.ɵfac = function RuxIconCrop169_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCrop169)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCrop169.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCrop169,
  selectors: [["rux-icon-crop-16-9"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCrop169_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCrop169 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCrop169);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCrop169, [{
    type: Component,
    args: [{
      selector: "rux-icon-crop-16-9",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCrop32 = class RuxIconCrop322 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCrop32.ɵfac = function RuxIconCrop32_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCrop32)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCrop32.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCrop32,
  selectors: [["rux-icon-crop-3-2"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCrop32_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCrop32 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCrop32);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCrop32, [{
    type: Component,
    args: [{
      selector: "rux-icon-crop-3-2",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCrop54 = class RuxIconCrop542 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCrop54.ɵfac = function RuxIconCrop54_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCrop54)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCrop54.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCrop54,
  selectors: [["rux-icon-crop-5-4"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCrop54_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCrop54 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCrop54);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCrop54, [{
    type: Component,
    args: [{
      selector: "rux-icon-crop-5-4",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCrop75 = class RuxIconCrop752 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCrop75.ɵfac = function RuxIconCrop75_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCrop75)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCrop75.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCrop75,
  selectors: [["rux-icon-crop-7-5"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCrop75_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCrop75 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCrop75);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCrop75, [{
    type: Component,
    args: [{
      selector: "rux-icon-crop-7-5",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCropDin = class RuxIconCropDin2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCropDin.ɵfac = function RuxIconCropDin_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCropDin)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCropDin.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCropDin,
  selectors: [["rux-icon-crop-din"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCropDin_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCropDin = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCropDin);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCropDin, [{
    type: Component,
    args: [{
      selector: "rux-icon-crop-din",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCropFree = class RuxIconCropFree2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCropFree.ɵfac = function RuxIconCropFree_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCropFree)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCropFree.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCropFree,
  selectors: [["rux-icon-crop-free"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCropFree_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCropFree = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCropFree);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCropFree, [{
    type: Component,
    args: [{
      selector: "rux-icon-crop-free",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCropLandscape = class RuxIconCropLandscape2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCropLandscape.ɵfac = function RuxIconCropLandscape_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCropLandscape)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCropLandscape.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCropLandscape,
  selectors: [["rux-icon-crop-landscape"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCropLandscape_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCropLandscape = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCropLandscape);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCropLandscape, [{
    type: Component,
    args: [{
      selector: "rux-icon-crop-landscape",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCropOriginal = class RuxIconCropOriginal2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCropOriginal.ɵfac = function RuxIconCropOriginal_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCropOriginal)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCropOriginal.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCropOriginal,
  selectors: [["rux-icon-crop-original"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCropOriginal_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCropOriginal = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCropOriginal);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCropOriginal, [{
    type: Component,
    args: [{
      selector: "rux-icon-crop-original",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCropPortrait = class RuxIconCropPortrait2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCropPortrait.ɵfac = function RuxIconCropPortrait_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCropPortrait)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCropPortrait.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCropPortrait,
  selectors: [["rux-icon-crop-portrait"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCropPortrait_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCropPortrait = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCropPortrait);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCropPortrait, [{
    type: Component,
    args: [{
      selector: "rux-icon-crop-portrait",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCropRotate = class RuxIconCropRotate2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCropRotate.ɵfac = function RuxIconCropRotate_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCropRotate)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCropRotate.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCropRotate,
  selectors: [["rux-icon-crop-rotate"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCropRotate_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCropRotate = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCropRotate);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCropRotate, [{
    type: Component,
    args: [{
      selector: "rux-icon-crop-rotate",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconCropSquare = class RuxIconCropSquare2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconCropSquare.ɵfac = function RuxIconCropSquare_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconCropSquare)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconCropSquare.ɵcmp = ɵɵdefineComponent({
  type: RuxIconCropSquare,
  selectors: [["rux-icon-crop-square"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconCropSquare_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconCropSquare = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconCropSquare);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconCropSquare, [{
    type: Component,
    args: [{
      selector: "rux-icon-crop-square",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDashboard = class RuxIconDashboard2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDashboard.ɵfac = function RuxIconDashboard_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDashboard)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDashboard.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDashboard,
  selectors: [["rux-icon-dashboard"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDashboard_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDashboard = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDashboard);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDashboard, [{
    type: Component,
    args: [{
      selector: "rux-icon-dashboard",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDataUsage = class RuxIconDataUsage2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDataUsage.ɵfac = function RuxIconDataUsage_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDataUsage)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDataUsage.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDataUsage,
  selectors: [["rux-icon-data-usage"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDataUsage_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDataUsage = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDataUsage);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDataUsage, [{
    type: Component,
    args: [{
      selector: "rux-icon-data-usage",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDateRange = class RuxIconDateRange2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDateRange.ɵfac = function RuxIconDateRange_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDateRange)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDateRange.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDateRange,
  selectors: [["rux-icon-date-range"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDateRange_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDateRange = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDateRange);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDateRange, [{
    type: Component,
    args: [{
      selector: "rux-icon-date-range",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDehaze = class RuxIconDehaze2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDehaze.ɵfac = function RuxIconDehaze_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDehaze)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDehaze.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDehaze,
  selectors: [["rux-icon-dehaze"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDehaze_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDehaze = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDehaze);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDehaze, [{
    type: Component,
    args: [{
      selector: "rux-icon-dehaze",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDelete = class RuxIconDelete2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDelete.ɵfac = function RuxIconDelete_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDelete)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDelete.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDelete,
  selectors: [["rux-icon-delete"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDelete_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDelete = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDelete);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDelete, [{
    type: Component,
    args: [{
      selector: "rux-icon-delete",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDeleteForever = class RuxIconDeleteForever2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDeleteForever.ɵfac = function RuxIconDeleteForever_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDeleteForever)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDeleteForever.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDeleteForever,
  selectors: [["rux-icon-delete-forever"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDeleteForever_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDeleteForever = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDeleteForever);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDeleteForever, [{
    type: Component,
    args: [{
      selector: "rux-icon-delete-forever",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDeleteOutline = class RuxIconDeleteOutline2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDeleteOutline.ɵfac = function RuxIconDeleteOutline_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDeleteOutline)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDeleteOutline.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDeleteOutline,
  selectors: [["rux-icon-delete-outline"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDeleteOutline_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDeleteOutline = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDeleteOutline);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDeleteOutline, [{
    type: Component,
    args: [{
      selector: "rux-icon-delete-outline",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDeleteSweep = class RuxIconDeleteSweep2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDeleteSweep.ɵfac = function RuxIconDeleteSweep_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDeleteSweep)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDeleteSweep.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDeleteSweep,
  selectors: [["rux-icon-delete-sweep"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDeleteSweep_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDeleteSweep = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDeleteSweep);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDeleteSweep, [{
    type: Component,
    args: [{
      selector: "rux-icon-delete-sweep",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDepartureBoard = class RuxIconDepartureBoard2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDepartureBoard.ɵfac = function RuxIconDepartureBoard_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDepartureBoard)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDepartureBoard.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDepartureBoard,
  selectors: [["rux-icon-departure-board"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDepartureBoard_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDepartureBoard = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDepartureBoard);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDepartureBoard, [{
    type: Component,
    args: [{
      selector: "rux-icon-departure-board",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDescription = class RuxIconDescription2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDescription.ɵfac = function RuxIconDescription_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDescription)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDescription.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDescription,
  selectors: [["rux-icon-description"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDescription_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDescription = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDescription);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDescription, [{
    type: Component,
    args: [{
      selector: "rux-icon-description",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDesktopAccessDisabled = class RuxIconDesktopAccessDisabled2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDesktopAccessDisabled.ɵfac = function RuxIconDesktopAccessDisabled_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDesktopAccessDisabled)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDesktopAccessDisabled.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDesktopAccessDisabled,
  selectors: [["rux-icon-desktop-access-disabled"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDesktopAccessDisabled_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDesktopAccessDisabled = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDesktopAccessDisabled);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDesktopAccessDisabled, [{
    type: Component,
    args: [{
      selector: "rux-icon-desktop-access-disabled",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDesktopMac = class RuxIconDesktopMac2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDesktopMac.ɵfac = function RuxIconDesktopMac_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDesktopMac)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDesktopMac.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDesktopMac,
  selectors: [["rux-icon-desktop-mac"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDesktopMac_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDesktopMac = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDesktopMac);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDesktopMac, [{
    type: Component,
    args: [{
      selector: "rux-icon-desktop-mac",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDesktopWindows = class RuxIconDesktopWindows2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDesktopWindows.ɵfac = function RuxIconDesktopWindows_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDesktopWindows)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDesktopWindows.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDesktopWindows,
  selectors: [["rux-icon-desktop-windows"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDesktopWindows_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDesktopWindows = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDesktopWindows);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDesktopWindows, [{
    type: Component,
    args: [{
      selector: "rux-icon-desktop-windows",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDetails = class RuxIconDetails2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDetails.ɵfac = function RuxIconDetails_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDetails)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDetails.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDetails,
  selectors: [["rux-icon-details"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDetails_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDetails = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDetails);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDetails, [{
    type: Component,
    args: [{
      selector: "rux-icon-details",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDeveloperBoard = class RuxIconDeveloperBoard2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDeveloperBoard.ɵfac = function RuxIconDeveloperBoard_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDeveloperBoard)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDeveloperBoard.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDeveloperBoard,
  selectors: [["rux-icon-developer-board"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDeveloperBoard_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDeveloperBoard = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDeveloperBoard);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDeveloperBoard, [{
    type: Component,
    args: [{
      selector: "rux-icon-developer-board",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDeveloperMode = class RuxIconDeveloperMode2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDeveloperMode.ɵfac = function RuxIconDeveloperMode_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDeveloperMode)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDeveloperMode.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDeveloperMode,
  selectors: [["rux-icon-developer-mode"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDeveloperMode_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDeveloperMode = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDeveloperMode);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDeveloperMode, [{
    type: Component,
    args: [{
      selector: "rux-icon-developer-mode",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDeviceHub = class RuxIconDeviceHub2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDeviceHub.ɵfac = function RuxIconDeviceHub_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDeviceHub)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDeviceHub.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDeviceHub,
  selectors: [["rux-icon-device-hub"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDeviceHub_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDeviceHub = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDeviceHub);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDeviceHub, [{
    type: Component,
    args: [{
      selector: "rux-icon-device-hub",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDeviceUnknown = class RuxIconDeviceUnknown2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDeviceUnknown.ɵfac = function RuxIconDeviceUnknown_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDeviceUnknown)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDeviceUnknown.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDeviceUnknown,
  selectors: [["rux-icon-device-unknown"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDeviceUnknown_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDeviceUnknown = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDeviceUnknown);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDeviceUnknown, [{
    type: Component,
    args: [{
      selector: "rux-icon-device-unknown",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDevices = class RuxIconDevices2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDevices.ɵfac = function RuxIconDevices_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDevices)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDevices.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDevices,
  selectors: [["rux-icon-devices"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDevices_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDevices = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDevices);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDevices, [{
    type: Component,
    args: [{
      selector: "rux-icon-devices",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDevicesOther = class RuxIconDevicesOther2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDevicesOther.ɵfac = function RuxIconDevicesOther_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDevicesOther)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDevicesOther.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDevicesOther,
  selectors: [["rux-icon-devices-other"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDevicesOther_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDevicesOther = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDevicesOther);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDevicesOther, [{
    type: Component,
    args: [{
      selector: "rux-icon-devices-other",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDialerSip = class RuxIconDialerSip2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDialerSip.ɵfac = function RuxIconDialerSip_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDialerSip)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDialerSip.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDialerSip,
  selectors: [["rux-icon-dialer-sip"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDialerSip_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDialerSip = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDialerSip);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDialerSip, [{
    type: Component,
    args: [{
      selector: "rux-icon-dialer-sip",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDialpad = class RuxIconDialpad2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDialpad.ɵfac = function RuxIconDialpad_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDialpad)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDialpad.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDialpad,
  selectors: [["rux-icon-dialpad"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDialpad_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDialpad = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDialpad);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDialpad, [{
    type: Component,
    args: [{
      selector: "rux-icon-dialpad",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDirections = class RuxIconDirections2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDirections.ɵfac = function RuxIconDirections_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDirections)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDirections.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDirections,
  selectors: [["rux-icon-directions"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDirections_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDirections = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDirections);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDirections, [{
    type: Component,
    args: [{
      selector: "rux-icon-directions",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDirectionsBike = class RuxIconDirectionsBike2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDirectionsBike.ɵfac = function RuxIconDirectionsBike_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDirectionsBike)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDirectionsBike.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDirectionsBike,
  selectors: [["rux-icon-directions-bike"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDirectionsBike_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDirectionsBike = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDirectionsBike);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDirectionsBike, [{
    type: Component,
    args: [{
      selector: "rux-icon-directions-bike",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDirectionsBoat = class RuxIconDirectionsBoat2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDirectionsBoat.ɵfac = function RuxIconDirectionsBoat_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDirectionsBoat)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDirectionsBoat.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDirectionsBoat,
  selectors: [["rux-icon-directions-boat"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDirectionsBoat_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDirectionsBoat = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDirectionsBoat);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDirectionsBoat, [{
    type: Component,
    args: [{
      selector: "rux-icon-directions-boat",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDirectionsBus = class RuxIconDirectionsBus2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDirectionsBus.ɵfac = function RuxIconDirectionsBus_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDirectionsBus)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDirectionsBus.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDirectionsBus,
  selectors: [["rux-icon-directions-bus"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDirectionsBus_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDirectionsBus = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDirectionsBus);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDirectionsBus, [{
    type: Component,
    args: [{
      selector: "rux-icon-directions-bus",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDirectionsCar = class RuxIconDirectionsCar2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDirectionsCar.ɵfac = function RuxIconDirectionsCar_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDirectionsCar)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDirectionsCar.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDirectionsCar,
  selectors: [["rux-icon-directions-car"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDirectionsCar_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDirectionsCar = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDirectionsCar);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDirectionsCar, [{
    type: Component,
    args: [{
      selector: "rux-icon-directions-car",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDirectionsRailway = class RuxIconDirectionsRailway2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDirectionsRailway.ɵfac = function RuxIconDirectionsRailway_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDirectionsRailway)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDirectionsRailway.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDirectionsRailway,
  selectors: [["rux-icon-directions-railway"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDirectionsRailway_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDirectionsRailway = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDirectionsRailway);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDirectionsRailway, [{
    type: Component,
    args: [{
      selector: "rux-icon-directions-railway",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDirectionsRun = class RuxIconDirectionsRun2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDirectionsRun.ɵfac = function RuxIconDirectionsRun_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDirectionsRun)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDirectionsRun.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDirectionsRun,
  selectors: [["rux-icon-directions-run"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDirectionsRun_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDirectionsRun = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDirectionsRun);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDirectionsRun, [{
    type: Component,
    args: [{
      selector: "rux-icon-directions-run",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDirectionsSubway = class RuxIconDirectionsSubway2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDirectionsSubway.ɵfac = function RuxIconDirectionsSubway_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDirectionsSubway)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDirectionsSubway.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDirectionsSubway,
  selectors: [["rux-icon-directions-subway"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDirectionsSubway_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDirectionsSubway = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDirectionsSubway);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDirectionsSubway, [{
    type: Component,
    args: [{
      selector: "rux-icon-directions-subway",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDirectionsTransit = class RuxIconDirectionsTransit2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDirectionsTransit.ɵfac = function RuxIconDirectionsTransit_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDirectionsTransit)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDirectionsTransit.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDirectionsTransit,
  selectors: [["rux-icon-directions-transit"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDirectionsTransit_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDirectionsTransit = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDirectionsTransit);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDirectionsTransit, [{
    type: Component,
    args: [{
      selector: "rux-icon-directions-transit",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDirectionsWalk = class RuxIconDirectionsWalk2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDirectionsWalk.ɵfac = function RuxIconDirectionsWalk_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDirectionsWalk)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDirectionsWalk.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDirectionsWalk,
  selectors: [["rux-icon-directions-walk"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDirectionsWalk_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDirectionsWalk = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDirectionsWalk);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDirectionsWalk, [{
    type: Component,
    args: [{
      selector: "rux-icon-directions-walk",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDiscFull = class RuxIconDiscFull2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDiscFull.ɵfac = function RuxIconDiscFull_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDiscFull)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDiscFull.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDiscFull,
  selectors: [["rux-icon-disc-full"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDiscFull_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDiscFull = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDiscFull);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDiscFull, [{
    type: Component,
    args: [{
      selector: "rux-icon-disc-full",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDns = class RuxIconDns2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDns.ɵfac = function RuxIconDns_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDns)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDns.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDns,
  selectors: [["rux-icon-dns"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDns_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDns = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDns);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDns, [{
    type: Component,
    args: [{
      selector: "rux-icon-dns",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDock = class RuxIconDock2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDock.ɵfac = function RuxIconDock_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDock)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDock.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDock,
  selectors: [["rux-icon-dock"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDock_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDock = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDock);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDock, [{
    type: Component,
    args: [{
      selector: "rux-icon-dock",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDomain = class RuxIconDomain2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDomain.ɵfac = function RuxIconDomain_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDomain)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDomain.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDomain,
  selectors: [["rux-icon-domain"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDomain_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDomain = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDomain);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDomain, [{
    type: Component,
    args: [{
      selector: "rux-icon-domain",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDomainDisabled = class RuxIconDomainDisabled2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDomainDisabled.ɵfac = function RuxIconDomainDisabled_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDomainDisabled)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDomainDisabled.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDomainDisabled,
  selectors: [["rux-icon-domain-disabled"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDomainDisabled_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDomainDisabled = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDomainDisabled);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDomainDisabled, [{
    type: Component,
    args: [{
      selector: "rux-icon-domain-disabled",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDone = class RuxIconDone2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDone.ɵfac = function RuxIconDone_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDone)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDone.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDone,
  selectors: [["rux-icon-done"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDone_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDone = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDone);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDone, [{
    type: Component,
    args: [{
      selector: "rux-icon-done",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDoneAll = class RuxIconDoneAll2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDoneAll.ɵfac = function RuxIconDoneAll_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDoneAll)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDoneAll.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDoneAll,
  selectors: [["rux-icon-done-all"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDoneAll_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDoneAll = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDoneAll);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDoneAll, [{
    type: Component,
    args: [{
      selector: "rux-icon-done-all",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDoneOutline = class RuxIconDoneOutline2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDoneOutline.ɵfac = function RuxIconDoneOutline_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDoneOutline)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDoneOutline.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDoneOutline,
  selectors: [["rux-icon-done-outline"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDoneOutline_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDoneOutline = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDoneOutline);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDoneOutline, [{
    type: Component,
    args: [{
      selector: "rux-icon-done-outline",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDonutLarge = class RuxIconDonutLarge2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDonutLarge.ɵfac = function RuxIconDonutLarge_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDonutLarge)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDonutLarge.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDonutLarge,
  selectors: [["rux-icon-donut-large"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDonutLarge_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDonutLarge = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDonutLarge);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDonutLarge, [{
    type: Component,
    args: [{
      selector: "rux-icon-donut-large",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDonutSmall = class RuxIconDonutSmall2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDonutSmall.ɵfac = function RuxIconDonutSmall_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDonutSmall)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDonutSmall.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDonutSmall,
  selectors: [["rux-icon-donut-small"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDonutSmall_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDonutSmall = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDonutSmall);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDonutSmall, [{
    type: Component,
    args: [{
      selector: "rux-icon-donut-small",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDrafts = class RuxIconDrafts2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDrafts.ɵfac = function RuxIconDrafts_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDrafts)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDrafts.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDrafts,
  selectors: [["rux-icon-drafts"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDrafts_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDrafts = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDrafts);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDrafts, [{
    type: Component,
    args: [{
      selector: "rux-icon-drafts",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDragHandle = class RuxIconDragHandle2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDragHandle.ɵfac = function RuxIconDragHandle_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDragHandle)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDragHandle.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDragHandle,
  selectors: [["rux-icon-drag-handle"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDragHandle_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDragHandle = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDragHandle);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDragHandle, [{
    type: Component,
    args: [{
      selector: "rux-icon-drag-handle",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDragIndicator = class RuxIconDragIndicator2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDragIndicator.ɵfac = function RuxIconDragIndicator_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDragIndicator)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDragIndicator.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDragIndicator,
  selectors: [["rux-icon-drag-indicator"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDragIndicator_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDragIndicator = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDragIndicator);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDragIndicator, [{
    type: Component,
    args: [{
      selector: "rux-icon-drag-indicator",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDriveEta = class RuxIconDriveEta2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDriveEta.ɵfac = function RuxIconDriveEta_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDriveEta)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDriveEta.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDriveEta,
  selectors: [["rux-icon-drive-eta"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDriveEta_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDriveEta = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDriveEta);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDriveEta, [{
    type: Component,
    args: [{
      selector: "rux-icon-drive-eta",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDuo = class RuxIconDuo2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDuo.ɵfac = function RuxIconDuo_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDuo)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDuo.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDuo,
  selectors: [["rux-icon-duo"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDuo_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDuo = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDuo);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDuo, [{
    type: Component,
    args: [{
      selector: "rux-icon-duo",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconDvr = class RuxIconDvr2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconDvr.ɵfac = function RuxIconDvr_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconDvr)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconDvr.ɵcmp = ɵɵdefineComponent({
  type: RuxIconDvr,
  selectors: [["rux-icon-dvr"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconDvr_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconDvr = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconDvr);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconDvr, [{
    type: Component,
    args: [{
      selector: "rux-icon-dvr",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconEdit = class RuxIconEdit2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconEdit.ɵfac = function RuxIconEdit_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconEdit)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconEdit.ɵcmp = ɵɵdefineComponent({
  type: RuxIconEdit,
  selectors: [["rux-icon-edit"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconEdit_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconEdit = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconEdit);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconEdit, [{
    type: Component,
    args: [{
      selector: "rux-icon-edit",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconEditAttributes = class RuxIconEditAttributes2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconEditAttributes.ɵfac = function RuxIconEditAttributes_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconEditAttributes)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconEditAttributes.ɵcmp = ɵɵdefineComponent({
  type: RuxIconEditAttributes,
  selectors: [["rux-icon-edit-attributes"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconEditAttributes_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconEditAttributes = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconEditAttributes);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconEditAttributes, [{
    type: Component,
    args: [{
      selector: "rux-icon-edit-attributes",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconEditLocation = class RuxIconEditLocation2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconEditLocation.ɵfac = function RuxIconEditLocation_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconEditLocation)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconEditLocation.ɵcmp = ɵɵdefineComponent({
  type: RuxIconEditLocation,
  selectors: [["rux-icon-edit-location"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconEditLocation_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconEditLocation = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconEditLocation);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconEditLocation, [{
    type: Component,
    args: [{
      selector: "rux-icon-edit-location",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconEject = class RuxIconEject2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconEject.ɵfac = function RuxIconEject_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconEject)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconEject.ɵcmp = ɵɵdefineComponent({
  type: RuxIconEject,
  selectors: [["rux-icon-eject"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconEject_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconEject = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconEject);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconEject, [{
    type: Component,
    args: [{
      selector: "rux-icon-eject",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconEmail = class RuxIconEmail2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconEmail.ɵfac = function RuxIconEmail_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconEmail)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconEmail.ɵcmp = ɵɵdefineComponent({
  type: RuxIconEmail,
  selectors: [["rux-icon-email"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconEmail_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconEmail = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconEmail);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconEmail, [{
    type: Component,
    args: [{
      selector: "rux-icon-email",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconEnhancedEncryption = class RuxIconEnhancedEncryption2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconEnhancedEncryption.ɵfac = function RuxIconEnhancedEncryption_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconEnhancedEncryption)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconEnhancedEncryption.ɵcmp = ɵɵdefineComponent({
  type: RuxIconEnhancedEncryption,
  selectors: [["rux-icon-enhanced-encryption"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconEnhancedEncryption_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconEnhancedEncryption = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconEnhancedEncryption);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconEnhancedEncryption, [{
    type: Component,
    args: [{
      selector: "rux-icon-enhanced-encryption",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconEqualizer = class RuxIconEqualizer2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconEqualizer.ɵfac = function RuxIconEqualizer_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconEqualizer)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconEqualizer.ɵcmp = ɵɵdefineComponent({
  type: RuxIconEqualizer,
  selectors: [["rux-icon-equalizer"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconEqualizer_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconEqualizer = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconEqualizer);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconEqualizer, [{
    type: Component,
    args: [{
      selector: "rux-icon-equalizer",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconEquipment = class RuxIconEquipment2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconEquipment.ɵfac = function RuxIconEquipment_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconEquipment)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconEquipment.ɵcmp = ɵɵdefineComponent({
  type: RuxIconEquipment,
  selectors: [["rux-icon-equipment"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconEquipment_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconEquipment = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconEquipment);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconEquipment, [{
    type: Component,
    args: [{
      selector: "rux-icon-equipment",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconError = class RuxIconError2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconError.ɵfac = function RuxIconError_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconError)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconError.ɵcmp = ɵɵdefineComponent({
  type: RuxIconError,
  selectors: [["rux-icon-error"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconError_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconError = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconError);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconError, [{
    type: Component,
    args: [{
      selector: "rux-icon-error",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconErrorOutline = class RuxIconErrorOutline2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconErrorOutline.ɵfac = function RuxIconErrorOutline_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconErrorOutline)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconErrorOutline.ɵcmp = ɵɵdefineComponent({
  type: RuxIconErrorOutline,
  selectors: [["rux-icon-error-outline"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconErrorOutline_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconErrorOutline = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconErrorOutline);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconErrorOutline, [{
    type: Component,
    args: [{
      selector: "rux-icon-error-outline",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconEuroSymbol = class RuxIconEuroSymbol2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconEuroSymbol.ɵfac = function RuxIconEuroSymbol_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconEuroSymbol)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconEuroSymbol.ɵcmp = ɵɵdefineComponent({
  type: RuxIconEuroSymbol,
  selectors: [["rux-icon-euro-symbol"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconEuroSymbol_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconEuroSymbol = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconEuroSymbol);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconEuroSymbol, [{
    type: Component,
    args: [{
      selector: "rux-icon-euro-symbol",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconEvStation = class RuxIconEvStation2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconEvStation.ɵfac = function RuxIconEvStation_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconEvStation)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconEvStation.ɵcmp = ɵɵdefineComponent({
  type: RuxIconEvStation,
  selectors: [["rux-icon-ev-station"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconEvStation_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconEvStation = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconEvStation);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconEvStation, [{
    type: Component,
    args: [{
      selector: "rux-icon-ev-station",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconEvent = class RuxIconEvent2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconEvent.ɵfac = function RuxIconEvent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconEvent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconEvent.ɵcmp = ɵɵdefineComponent({
  type: RuxIconEvent,
  selectors: [["rux-icon-event"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconEvent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconEvent = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconEvent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconEvent, [{
    type: Component,
    args: [{
      selector: "rux-icon-event",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconEventAvailable = class RuxIconEventAvailable2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconEventAvailable.ɵfac = function RuxIconEventAvailable_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconEventAvailable)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconEventAvailable.ɵcmp = ɵɵdefineComponent({
  type: RuxIconEventAvailable,
  selectors: [["rux-icon-event-available"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconEventAvailable_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconEventAvailable = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconEventAvailable);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconEventAvailable, [{
    type: Component,
    args: [{
      selector: "rux-icon-event-available",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconEventBusy = class RuxIconEventBusy2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconEventBusy.ɵfac = function RuxIconEventBusy_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconEventBusy)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconEventBusy.ɵcmp = ɵɵdefineComponent({
  type: RuxIconEventBusy,
  selectors: [["rux-icon-event-busy"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconEventBusy_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconEventBusy = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconEventBusy);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconEventBusy, [{
    type: Component,
    args: [{
      selector: "rux-icon-event-busy",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconEventNote = class RuxIconEventNote2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconEventNote.ɵfac = function RuxIconEventNote_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconEventNote)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconEventNote.ɵcmp = ɵɵdefineComponent({
  type: RuxIconEventNote,
  selectors: [["rux-icon-event-note"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconEventNote_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconEventNote = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconEventNote);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconEventNote, [{
    type: Component,
    args: [{
      selector: "rux-icon-event-note",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconExitToApp = class RuxIconExitToApp2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconExitToApp.ɵfac = function RuxIconExitToApp_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconExitToApp)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconExitToApp.ɵcmp = ɵɵdefineComponent({
  type: RuxIconExitToApp,
  selectors: [["rux-icon-exit-to-app"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconExitToApp_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconExitToApp = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconExitToApp);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconExitToApp, [{
    type: Component,
    args: [{
      selector: "rux-icon-exit-to-app",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconExpandLess = class RuxIconExpandLess2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconExpandLess.ɵfac = function RuxIconExpandLess_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconExpandLess)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconExpandLess.ɵcmp = ɵɵdefineComponent({
  type: RuxIconExpandLess,
  selectors: [["rux-icon-expand-less"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconExpandLess_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconExpandLess = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconExpandLess);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconExpandLess, [{
    type: Component,
    args: [{
      selector: "rux-icon-expand-less",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconExpandMore = class RuxIconExpandMore2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconExpandMore.ɵfac = function RuxIconExpandMore_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconExpandMore)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconExpandMore.ɵcmp = ɵɵdefineComponent({
  type: RuxIconExpandMore,
  selectors: [["rux-icon-expand-more"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconExpandMore_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconExpandMore = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconExpandMore);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconExpandMore, [{
    type: Component,
    args: [{
      selector: "rux-icon-expand-more",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconExplicit = class RuxIconExplicit2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconExplicit.ɵfac = function RuxIconExplicit_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconExplicit)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconExplicit.ɵcmp = ɵɵdefineComponent({
  type: RuxIconExplicit,
  selectors: [["rux-icon-explicit"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconExplicit_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconExplicit = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconExplicit);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconExplicit, [{
    type: Component,
    args: [{
      selector: "rux-icon-explicit",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconExplore = class RuxIconExplore2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconExplore.ɵfac = function RuxIconExplore_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconExplore)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconExplore.ɵcmp = ɵɵdefineComponent({
  type: RuxIconExplore,
  selectors: [["rux-icon-explore"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconExplore_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconExplore = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconExplore);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconExplore, [{
    type: Component,
    args: [{
      selector: "rux-icon-explore",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconExploreOff = class RuxIconExploreOff2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconExploreOff.ɵfac = function RuxIconExploreOff_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconExploreOff)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconExploreOff.ɵcmp = ɵɵdefineComponent({
  type: RuxIconExploreOff,
  selectors: [["rux-icon-explore-off"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconExploreOff_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconExploreOff = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconExploreOff);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconExploreOff, [{
    type: Component,
    args: [{
      selector: "rux-icon-explore-off",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconExposure = class RuxIconExposure2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconExposure.ɵfac = function RuxIconExposure_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconExposure)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconExposure.ɵcmp = ɵɵdefineComponent({
  type: RuxIconExposure,
  selectors: [["rux-icon-exposure"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconExposure_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconExposure = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconExposure);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconExposure, [{
    type: Component,
    args: [{
      selector: "rux-icon-exposure",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconExposureNeg1 = class RuxIconExposureNeg12 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconExposureNeg1.ɵfac = function RuxIconExposureNeg1_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconExposureNeg1)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconExposureNeg1.ɵcmp = ɵɵdefineComponent({
  type: RuxIconExposureNeg1,
  selectors: [["rux-icon-exposure-neg-1"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconExposureNeg1_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconExposureNeg1 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconExposureNeg1);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconExposureNeg1, [{
    type: Component,
    args: [{
      selector: "rux-icon-exposure-neg-1",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconExposureNeg2 = class RuxIconExposureNeg22 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconExposureNeg2.ɵfac = function RuxIconExposureNeg2_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconExposureNeg2)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconExposureNeg2.ɵcmp = ɵɵdefineComponent({
  type: RuxIconExposureNeg2,
  selectors: [["rux-icon-exposure-neg-2"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconExposureNeg2_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconExposureNeg2 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconExposureNeg2);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconExposureNeg2, [{
    type: Component,
    args: [{
      selector: "rux-icon-exposure-neg-2",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconExposurePlus1 = class RuxIconExposurePlus12 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconExposurePlus1.ɵfac = function RuxIconExposurePlus1_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconExposurePlus1)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconExposurePlus1.ɵcmp = ɵɵdefineComponent({
  type: RuxIconExposurePlus1,
  selectors: [["rux-icon-exposure-plus-1"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconExposurePlus1_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconExposurePlus1 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconExposurePlus1);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconExposurePlus1, [{
    type: Component,
    args: [{
      selector: "rux-icon-exposure-plus-1",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconExposurePlus2 = class RuxIconExposurePlus22 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconExposurePlus2.ɵfac = function RuxIconExposurePlus2_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconExposurePlus2)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconExposurePlus2.ɵcmp = ɵɵdefineComponent({
  type: RuxIconExposurePlus2,
  selectors: [["rux-icon-exposure-plus-2"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconExposurePlus2_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconExposurePlus2 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconExposurePlus2);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconExposurePlus2, [{
    type: Component,
    args: [{
      selector: "rux-icon-exposure-plus-2",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconExposureZero = class RuxIconExposureZero2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconExposureZero.ɵfac = function RuxIconExposureZero_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconExposureZero)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconExposureZero.ɵcmp = ɵɵdefineComponent({
  type: RuxIconExposureZero,
  selectors: [["rux-icon-exposure-zero"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconExposureZero_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconExposureZero = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconExposureZero);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconExposureZero, [{
    type: Component,
    args: [{
      selector: "rux-icon-exposure-zero",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconExtension = class RuxIconExtension2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconExtension.ɵfac = function RuxIconExtension_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconExtension)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconExtension.ɵcmp = ɵɵdefineComponent({
  type: RuxIconExtension,
  selectors: [["rux-icon-extension"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconExtension_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconExtension = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconExtension);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconExtension, [{
    type: Component,
    args: [{
      selector: "rux-icon-extension",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFace = class RuxIconFace2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFace.ɵfac = function RuxIconFace_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFace)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFace.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFace,
  selectors: [["rux-icon-face"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFace_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFace = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFace);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFace, [{
    type: Component,
    args: [{
      selector: "rux-icon-face",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFastForward = class RuxIconFastForward2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFastForward.ɵfac = function RuxIconFastForward_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFastForward)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFastForward.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFastForward,
  selectors: [["rux-icon-fast-forward"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFastForward_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFastForward = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFastForward);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFastForward, [{
    type: Component,
    args: [{
      selector: "rux-icon-fast-forward",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFastRewind = class RuxIconFastRewind2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFastRewind.ɵfac = function RuxIconFastRewind_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFastRewind)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFastRewind.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFastRewind,
  selectors: [["rux-icon-fast-rewind"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFastRewind_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFastRewind = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFastRewind);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFastRewind, [{
    type: Component,
    args: [{
      selector: "rux-icon-fast-rewind",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFastfood = class RuxIconFastfood2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFastfood.ɵfac = function RuxIconFastfood_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFastfood)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFastfood.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFastfood,
  selectors: [["rux-icon-fastfood"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFastfood_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFastfood = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFastfood);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFastfood, [{
    type: Component,
    args: [{
      selector: "rux-icon-fastfood",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFavorite = class RuxIconFavorite2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFavorite.ɵfac = function RuxIconFavorite_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFavorite)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFavorite.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFavorite,
  selectors: [["rux-icon-favorite"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFavorite_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFavorite = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFavorite);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFavorite, [{
    type: Component,
    args: [{
      selector: "rux-icon-favorite",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFavoriteBorder = class RuxIconFavoriteBorder2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFavoriteBorder.ɵfac = function RuxIconFavoriteBorder_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFavoriteBorder)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFavoriteBorder.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFavoriteBorder,
  selectors: [["rux-icon-favorite-border"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFavoriteBorder_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFavoriteBorder = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFavoriteBorder);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFavoriteBorder, [{
    type: Component,
    args: [{
      selector: "rux-icon-favorite-border",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFeaturedPlayList = class RuxIconFeaturedPlayList2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFeaturedPlayList.ɵfac = function RuxIconFeaturedPlayList_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFeaturedPlayList)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFeaturedPlayList.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFeaturedPlayList,
  selectors: [["rux-icon-featured-play-list"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFeaturedPlayList_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFeaturedPlayList = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFeaturedPlayList);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFeaturedPlayList, [{
    type: Component,
    args: [{
      selector: "rux-icon-featured-play-list",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFeaturedVideo = class RuxIconFeaturedVideo2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFeaturedVideo.ɵfac = function RuxIconFeaturedVideo_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFeaturedVideo)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFeaturedVideo.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFeaturedVideo,
  selectors: [["rux-icon-featured-video"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFeaturedVideo_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFeaturedVideo = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFeaturedVideo);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFeaturedVideo, [{
    type: Component,
    args: [{
      selector: "rux-icon-featured-video",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFeedback = class RuxIconFeedback2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFeedback.ɵfac = function RuxIconFeedback_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFeedback)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFeedback.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFeedback,
  selectors: [["rux-icon-feedback"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFeedback_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFeedback = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFeedback);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFeedback, [{
    type: Component,
    args: [{
      selector: "rux-icon-feedback",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFiberDvr = class RuxIconFiberDvr2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFiberDvr.ɵfac = function RuxIconFiberDvr_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFiberDvr)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFiberDvr.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFiberDvr,
  selectors: [["rux-icon-fiber-dvr"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFiberDvr_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFiberDvr = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFiberDvr);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFiberDvr, [{
    type: Component,
    args: [{
      selector: "rux-icon-fiber-dvr",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFiberManualRecord = class RuxIconFiberManualRecord2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFiberManualRecord.ɵfac = function RuxIconFiberManualRecord_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFiberManualRecord)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFiberManualRecord.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFiberManualRecord,
  selectors: [["rux-icon-fiber-manual-record"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFiberManualRecord_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFiberManualRecord = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFiberManualRecord);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFiberManualRecord, [{
    type: Component,
    args: [{
      selector: "rux-icon-fiber-manual-record",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFiberNew = class RuxIconFiberNew2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFiberNew.ɵfac = function RuxIconFiberNew_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFiberNew)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFiberNew.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFiberNew,
  selectors: [["rux-icon-fiber-new"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFiberNew_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFiberNew = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFiberNew);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFiberNew, [{
    type: Component,
    args: [{
      selector: "rux-icon-fiber-new",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFiberPin = class RuxIconFiberPin2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFiberPin.ɵfac = function RuxIconFiberPin_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFiberPin)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFiberPin.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFiberPin,
  selectors: [["rux-icon-fiber-pin"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFiberPin_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFiberPin = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFiberPin);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFiberPin, [{
    type: Component,
    args: [{
      selector: "rux-icon-fiber-pin",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFiberSmartRecord = class RuxIconFiberSmartRecord2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFiberSmartRecord.ɵfac = function RuxIconFiberSmartRecord_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFiberSmartRecord)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFiberSmartRecord.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFiberSmartRecord,
  selectors: [["rux-icon-fiber-smart-record"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFiberSmartRecord_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFiberSmartRecord = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFiberSmartRecord);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFiberSmartRecord, [{
    type: Component,
    args: [{
      selector: "rux-icon-fiber-smart-record",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFileCopy = class RuxIconFileCopy2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFileCopy.ɵfac = function RuxIconFileCopy_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFileCopy)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFileCopy.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFileCopy,
  selectors: [["rux-icon-file-copy"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFileCopy_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFileCopy = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFileCopy);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFileCopy, [{
    type: Component,
    args: [{
      selector: "rux-icon-file-copy",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFilter = class RuxIconFilter2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFilter.ɵfac = function RuxIconFilter_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFilter)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFilter.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFilter,
  selectors: [["rux-icon-filter"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFilter_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFilter = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFilter);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFilter, [{
    type: Component,
    args: [{
      selector: "rux-icon-filter",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFilter1 = class RuxIconFilter12 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFilter1.ɵfac = function RuxIconFilter1_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFilter1)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFilter1.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFilter1,
  selectors: [["rux-icon-filter-1"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFilter1_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFilter1 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFilter1);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFilter1, [{
    type: Component,
    args: [{
      selector: "rux-icon-filter-1",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFilter22 = class RuxIconFilter23 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFilter22.ɵfac = function RuxIconFilter2_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFilter22)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFilter22.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFilter22,
  selectors: [["rux-icon-filter-2"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFilter2_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFilter22 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFilter22);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFilter22, [{
    type: Component,
    args: [{
      selector: "rux-icon-filter-2",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFilter3 = class RuxIconFilter32 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFilter3.ɵfac = function RuxIconFilter3_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFilter3)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFilter3.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFilter3,
  selectors: [["rux-icon-filter-3"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFilter3_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFilter3 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFilter3);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFilter3, [{
    type: Component,
    args: [{
      selector: "rux-icon-filter-3",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFilter4 = class RuxIconFilter42 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFilter4.ɵfac = function RuxIconFilter4_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFilter4)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFilter4.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFilter4,
  selectors: [["rux-icon-filter-4"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFilter4_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFilter4 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFilter4);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFilter4, [{
    type: Component,
    args: [{
      selector: "rux-icon-filter-4",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFilter5 = class RuxIconFilter52 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFilter5.ɵfac = function RuxIconFilter5_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFilter5)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFilter5.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFilter5,
  selectors: [["rux-icon-filter-5"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFilter5_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFilter5 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFilter5);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFilter5, [{
    type: Component,
    args: [{
      selector: "rux-icon-filter-5",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFilter6 = class RuxIconFilter62 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFilter6.ɵfac = function RuxIconFilter6_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFilter6)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFilter6.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFilter6,
  selectors: [["rux-icon-filter-6"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFilter6_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFilter6 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFilter6);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFilter6, [{
    type: Component,
    args: [{
      selector: "rux-icon-filter-6",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFilter7 = class RuxIconFilter72 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFilter7.ɵfac = function RuxIconFilter7_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFilter7)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFilter7.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFilter7,
  selectors: [["rux-icon-filter-7"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFilter7_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFilter7 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFilter7);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFilter7, [{
    type: Component,
    args: [{
      selector: "rux-icon-filter-7",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFilter8 = class RuxIconFilter82 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFilter8.ɵfac = function RuxIconFilter8_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFilter8)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFilter8.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFilter8,
  selectors: [["rux-icon-filter-8"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFilter8_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFilter8 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFilter8);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFilter8, [{
    type: Component,
    args: [{
      selector: "rux-icon-filter-8",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFilter9 = class RuxIconFilter92 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFilter9.ɵfac = function RuxIconFilter9_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFilter9)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFilter9.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFilter9,
  selectors: [["rux-icon-filter-9"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFilter9_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFilter9 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFilter9);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFilter9, [{
    type: Component,
    args: [{
      selector: "rux-icon-filter-9",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFilter9Plus = class RuxIconFilter9Plus2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFilter9Plus.ɵfac = function RuxIconFilter9Plus_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFilter9Plus)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFilter9Plus.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFilter9Plus,
  selectors: [["rux-icon-filter-9-plus"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFilter9Plus_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFilter9Plus = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFilter9Plus);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFilter9Plus, [{
    type: Component,
    args: [{
      selector: "rux-icon-filter-9-plus",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFilterBAndW = class RuxIconFilterBAndW2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFilterBAndW.ɵfac = function RuxIconFilterBAndW_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFilterBAndW)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFilterBAndW.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFilterBAndW,
  selectors: [["rux-icon-filter-b-and-w"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFilterBAndW_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFilterBAndW = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFilterBAndW);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFilterBAndW, [{
    type: Component,
    args: [{
      selector: "rux-icon-filter-b-and-w",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFilterCenterFocus = class RuxIconFilterCenterFocus2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFilterCenterFocus.ɵfac = function RuxIconFilterCenterFocus_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFilterCenterFocus)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFilterCenterFocus.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFilterCenterFocus,
  selectors: [["rux-icon-filter-center-focus"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFilterCenterFocus_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFilterCenterFocus = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFilterCenterFocus);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFilterCenterFocus, [{
    type: Component,
    args: [{
      selector: "rux-icon-filter-center-focus",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFilterDrama = class RuxIconFilterDrama2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFilterDrama.ɵfac = function RuxIconFilterDrama_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFilterDrama)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFilterDrama.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFilterDrama,
  selectors: [["rux-icon-filter-drama"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFilterDrama_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFilterDrama = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFilterDrama);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFilterDrama, [{
    type: Component,
    args: [{
      selector: "rux-icon-filter-drama",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFilterFrames = class RuxIconFilterFrames2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFilterFrames.ɵfac = function RuxIconFilterFrames_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFilterFrames)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFilterFrames.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFilterFrames,
  selectors: [["rux-icon-filter-frames"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFilterFrames_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFilterFrames = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFilterFrames);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFilterFrames, [{
    type: Component,
    args: [{
      selector: "rux-icon-filter-frames",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFilterHdr = class RuxIconFilterHdr2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFilterHdr.ɵfac = function RuxIconFilterHdr_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFilterHdr)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFilterHdr.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFilterHdr,
  selectors: [["rux-icon-filter-hdr"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFilterHdr_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFilterHdr = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFilterHdr);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFilterHdr, [{
    type: Component,
    args: [{
      selector: "rux-icon-filter-hdr",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFilterList = class RuxIconFilterList2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFilterList.ɵfac = function RuxIconFilterList_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFilterList)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFilterList.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFilterList,
  selectors: [["rux-icon-filter-list"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFilterList_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFilterList = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFilterList);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFilterList, [{
    type: Component,
    args: [{
      selector: "rux-icon-filter-list",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFilterNone = class RuxIconFilterNone2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFilterNone.ɵfac = function RuxIconFilterNone_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFilterNone)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFilterNone.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFilterNone,
  selectors: [["rux-icon-filter-none"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFilterNone_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFilterNone = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFilterNone);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFilterNone, [{
    type: Component,
    args: [{
      selector: "rux-icon-filter-none",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFilterTiltShift = class RuxIconFilterTiltShift2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFilterTiltShift.ɵfac = function RuxIconFilterTiltShift_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFilterTiltShift)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFilterTiltShift.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFilterTiltShift,
  selectors: [["rux-icon-filter-tilt-shift"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFilterTiltShift_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFilterTiltShift = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFilterTiltShift);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFilterTiltShift, [{
    type: Component,
    args: [{
      selector: "rux-icon-filter-tilt-shift",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFilterVintage = class RuxIconFilterVintage2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFilterVintage.ɵfac = function RuxIconFilterVintage_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFilterVintage)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFilterVintage.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFilterVintage,
  selectors: [["rux-icon-filter-vintage"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFilterVintage_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFilterVintage = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFilterVintage);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFilterVintage, [{
    type: Component,
    args: [{
      selector: "rux-icon-filter-vintage",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFindInPage = class RuxIconFindInPage2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFindInPage.ɵfac = function RuxIconFindInPage_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFindInPage)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFindInPage.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFindInPage,
  selectors: [["rux-icon-find-in-page"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFindInPage_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFindInPage = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFindInPage);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFindInPage, [{
    type: Component,
    args: [{
      selector: "rux-icon-find-in-page",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFindReplace = class RuxIconFindReplace2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFindReplace.ɵfac = function RuxIconFindReplace_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFindReplace)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFindReplace.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFindReplace,
  selectors: [["rux-icon-find-replace"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFindReplace_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFindReplace = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFindReplace);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFindReplace, [{
    type: Component,
    args: [{
      selector: "rux-icon-find-replace",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFingerprint = class RuxIconFingerprint2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFingerprint.ɵfac = function RuxIconFingerprint_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFingerprint)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFingerprint.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFingerprint,
  selectors: [["rux-icon-fingerprint"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFingerprint_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFingerprint = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFingerprint);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFingerprint, [{
    type: Component,
    args: [{
      selector: "rux-icon-fingerprint",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFirstPage = class RuxIconFirstPage2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFirstPage.ɵfac = function RuxIconFirstPage_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFirstPage)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFirstPage.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFirstPage,
  selectors: [["rux-icon-first-page"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFirstPage_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFirstPage = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFirstPage);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFirstPage, [{
    type: Component,
    args: [{
      selector: "rux-icon-first-page",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFitnessCenter = class RuxIconFitnessCenter2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFitnessCenter.ɵfac = function RuxIconFitnessCenter_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFitnessCenter)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFitnessCenter.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFitnessCenter,
  selectors: [["rux-icon-fitness-center"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFitnessCenter_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFitnessCenter = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFitnessCenter);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFitnessCenter, [{
    type: Component,
    args: [{
      selector: "rux-icon-fitness-center",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFlag = class RuxIconFlag2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFlag.ɵfac = function RuxIconFlag_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFlag)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFlag.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFlag,
  selectors: [["rux-icon-flag"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFlag_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFlag = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFlag);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFlag, [{
    type: Component,
    args: [{
      selector: "rux-icon-flag",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFlare = class RuxIconFlare2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFlare.ɵfac = function RuxIconFlare_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFlare)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFlare.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFlare,
  selectors: [["rux-icon-flare"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFlare_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFlare = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFlare);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFlare, [{
    type: Component,
    args: [{
      selector: "rux-icon-flare",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFlashAuto = class RuxIconFlashAuto2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFlashAuto.ɵfac = function RuxIconFlashAuto_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFlashAuto)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFlashAuto.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFlashAuto,
  selectors: [["rux-icon-flash-auto"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFlashAuto_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFlashAuto = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFlashAuto);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFlashAuto, [{
    type: Component,
    args: [{
      selector: "rux-icon-flash-auto",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFlashOff = class RuxIconFlashOff2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFlashOff.ɵfac = function RuxIconFlashOff_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFlashOff)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFlashOff.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFlashOff,
  selectors: [["rux-icon-flash-off"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFlashOff_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFlashOff = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFlashOff);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFlashOff, [{
    type: Component,
    args: [{
      selector: "rux-icon-flash-off",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFlashOn = class RuxIconFlashOn2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFlashOn.ɵfac = function RuxIconFlashOn_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFlashOn)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFlashOn.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFlashOn,
  selectors: [["rux-icon-flash-on"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFlashOn_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFlashOn = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFlashOn);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFlashOn, [{
    type: Component,
    args: [{
      selector: "rux-icon-flash-on",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFlight = class RuxIconFlight2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFlight.ɵfac = function RuxIconFlight_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFlight)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFlight.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFlight,
  selectors: [["rux-icon-flight"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFlight_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFlight = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFlight);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFlight, [{
    type: Component,
    args: [{
      selector: "rux-icon-flight",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFlightLand = class RuxIconFlightLand2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFlightLand.ɵfac = function RuxIconFlightLand_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFlightLand)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFlightLand.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFlightLand,
  selectors: [["rux-icon-flight-land"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFlightLand_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFlightLand = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFlightLand);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFlightLand, [{
    type: Component,
    args: [{
      selector: "rux-icon-flight-land",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFlightTakeoff = class RuxIconFlightTakeoff2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFlightTakeoff.ɵfac = function RuxIconFlightTakeoff_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFlightTakeoff)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFlightTakeoff.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFlightTakeoff,
  selectors: [["rux-icon-flight-takeoff"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFlightTakeoff_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFlightTakeoff = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFlightTakeoff);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFlightTakeoff, [{
    type: Component,
    args: [{
      selector: "rux-icon-flight-takeoff",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFlip = class RuxIconFlip2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFlip.ɵfac = function RuxIconFlip_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFlip)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFlip.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFlip,
  selectors: [["rux-icon-flip"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFlip_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFlip = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFlip);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFlip, [{
    type: Component,
    args: [{
      selector: "rux-icon-flip",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFlipToBack = class RuxIconFlipToBack2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFlipToBack.ɵfac = function RuxIconFlipToBack_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFlipToBack)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFlipToBack.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFlipToBack,
  selectors: [["rux-icon-flip-to-back"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFlipToBack_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFlipToBack = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFlipToBack);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFlipToBack, [{
    type: Component,
    args: [{
      selector: "rux-icon-flip-to-back",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFlipToFront = class RuxIconFlipToFront2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFlipToFront.ɵfac = function RuxIconFlipToFront_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFlipToFront)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFlipToFront.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFlipToFront,
  selectors: [["rux-icon-flip-to-front"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFlipToFront_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFlipToFront = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFlipToFront);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFlipToFront, [{
    type: Component,
    args: [{
      selector: "rux-icon-flip-to-front",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFolder = class RuxIconFolder2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFolder.ɵfac = function RuxIconFolder_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFolder)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFolder.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFolder,
  selectors: [["rux-icon-folder"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFolder_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFolder = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFolder);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFolder, [{
    type: Component,
    args: [{
      selector: "rux-icon-folder",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFolderOpen = class RuxIconFolderOpen2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFolderOpen.ɵfac = function RuxIconFolderOpen_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFolderOpen)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFolderOpen.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFolderOpen,
  selectors: [["rux-icon-folder-open"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFolderOpen_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFolderOpen = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFolderOpen);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFolderOpen, [{
    type: Component,
    args: [{
      selector: "rux-icon-folder-open",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFolderShared = class RuxIconFolderShared2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFolderShared.ɵfac = function RuxIconFolderShared_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFolderShared)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFolderShared.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFolderShared,
  selectors: [["rux-icon-folder-shared"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFolderShared_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFolderShared = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFolderShared);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFolderShared, [{
    type: Component,
    args: [{
      selector: "rux-icon-folder-shared",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFolderSpecial = class RuxIconFolderSpecial2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFolderSpecial.ɵfac = function RuxIconFolderSpecial_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFolderSpecial)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFolderSpecial.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFolderSpecial,
  selectors: [["rux-icon-folder-special"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFolderSpecial_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFolderSpecial = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFolderSpecial);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFolderSpecial, [{
    type: Component,
    args: [{
      selector: "rux-icon-folder-special",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFontDownload = class RuxIconFontDownload2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFontDownload.ɵfac = function RuxIconFontDownload_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFontDownload)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFontDownload.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFontDownload,
  selectors: [["rux-icon-font-download"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFontDownload_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFontDownload = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFontDownload);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFontDownload, [{
    type: Component,
    args: [{
      selector: "rux-icon-font-download",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFormatAlignCenter = class RuxIconFormatAlignCenter2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFormatAlignCenter.ɵfac = function RuxIconFormatAlignCenter_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFormatAlignCenter)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFormatAlignCenter.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFormatAlignCenter,
  selectors: [["rux-icon-format-align-center"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFormatAlignCenter_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFormatAlignCenter = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFormatAlignCenter);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFormatAlignCenter, [{
    type: Component,
    args: [{
      selector: "rux-icon-format-align-center",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFormatAlignJustify = class RuxIconFormatAlignJustify2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFormatAlignJustify.ɵfac = function RuxIconFormatAlignJustify_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFormatAlignJustify)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFormatAlignJustify.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFormatAlignJustify,
  selectors: [["rux-icon-format-align-justify"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFormatAlignJustify_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFormatAlignJustify = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFormatAlignJustify);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFormatAlignJustify, [{
    type: Component,
    args: [{
      selector: "rux-icon-format-align-justify",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFormatAlignLeft = class RuxIconFormatAlignLeft2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFormatAlignLeft.ɵfac = function RuxIconFormatAlignLeft_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFormatAlignLeft)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFormatAlignLeft.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFormatAlignLeft,
  selectors: [["rux-icon-format-align-left"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFormatAlignLeft_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFormatAlignLeft = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFormatAlignLeft);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFormatAlignLeft, [{
    type: Component,
    args: [{
      selector: "rux-icon-format-align-left",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFormatAlignRight = class RuxIconFormatAlignRight2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFormatAlignRight.ɵfac = function RuxIconFormatAlignRight_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFormatAlignRight)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFormatAlignRight.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFormatAlignRight,
  selectors: [["rux-icon-format-align-right"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFormatAlignRight_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFormatAlignRight = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFormatAlignRight);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFormatAlignRight, [{
    type: Component,
    args: [{
      selector: "rux-icon-format-align-right",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFormatBold = class RuxIconFormatBold2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFormatBold.ɵfac = function RuxIconFormatBold_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFormatBold)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFormatBold.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFormatBold,
  selectors: [["rux-icon-format-bold"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFormatBold_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFormatBold = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFormatBold);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFormatBold, [{
    type: Component,
    args: [{
      selector: "rux-icon-format-bold",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFormatClear = class RuxIconFormatClear2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFormatClear.ɵfac = function RuxIconFormatClear_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFormatClear)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFormatClear.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFormatClear,
  selectors: [["rux-icon-format-clear"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFormatClear_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFormatClear = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFormatClear);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFormatClear, [{
    type: Component,
    args: [{
      selector: "rux-icon-format-clear",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFormatColorFill = class RuxIconFormatColorFill2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFormatColorFill.ɵfac = function RuxIconFormatColorFill_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFormatColorFill)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFormatColorFill.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFormatColorFill,
  selectors: [["rux-icon-format-color-fill"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFormatColorFill_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFormatColorFill = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFormatColorFill);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFormatColorFill, [{
    type: Component,
    args: [{
      selector: "rux-icon-format-color-fill",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFormatColorReset = class RuxIconFormatColorReset2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFormatColorReset.ɵfac = function RuxIconFormatColorReset_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFormatColorReset)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFormatColorReset.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFormatColorReset,
  selectors: [["rux-icon-format-color-reset"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFormatColorReset_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFormatColorReset = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFormatColorReset);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFormatColorReset, [{
    type: Component,
    args: [{
      selector: "rux-icon-format-color-reset",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFormatColorText = class RuxIconFormatColorText2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFormatColorText.ɵfac = function RuxIconFormatColorText_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFormatColorText)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFormatColorText.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFormatColorText,
  selectors: [["rux-icon-format-color-text"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFormatColorText_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFormatColorText = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFormatColorText);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFormatColorText, [{
    type: Component,
    args: [{
      selector: "rux-icon-format-color-text",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFormatIndentDecrease = class RuxIconFormatIndentDecrease2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFormatIndentDecrease.ɵfac = function RuxIconFormatIndentDecrease_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFormatIndentDecrease)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFormatIndentDecrease.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFormatIndentDecrease,
  selectors: [["rux-icon-format-indent-decrease"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFormatIndentDecrease_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFormatIndentDecrease = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFormatIndentDecrease);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFormatIndentDecrease, [{
    type: Component,
    args: [{
      selector: "rux-icon-format-indent-decrease",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFormatIndentIncrease = class RuxIconFormatIndentIncrease2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFormatIndentIncrease.ɵfac = function RuxIconFormatIndentIncrease_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFormatIndentIncrease)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFormatIndentIncrease.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFormatIndentIncrease,
  selectors: [["rux-icon-format-indent-increase"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFormatIndentIncrease_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFormatIndentIncrease = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFormatIndentIncrease);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFormatIndentIncrease, [{
    type: Component,
    args: [{
      selector: "rux-icon-format-indent-increase",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFormatItalic = class RuxIconFormatItalic2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFormatItalic.ɵfac = function RuxIconFormatItalic_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFormatItalic)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFormatItalic.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFormatItalic,
  selectors: [["rux-icon-format-italic"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFormatItalic_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFormatItalic = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFormatItalic);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFormatItalic, [{
    type: Component,
    args: [{
      selector: "rux-icon-format-italic",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFormatLineSpacing = class RuxIconFormatLineSpacing2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFormatLineSpacing.ɵfac = function RuxIconFormatLineSpacing_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFormatLineSpacing)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFormatLineSpacing.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFormatLineSpacing,
  selectors: [["rux-icon-format-line-spacing"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFormatLineSpacing_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFormatLineSpacing = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFormatLineSpacing);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFormatLineSpacing, [{
    type: Component,
    args: [{
      selector: "rux-icon-format-line-spacing",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFormatListBulleted = class RuxIconFormatListBulleted2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFormatListBulleted.ɵfac = function RuxIconFormatListBulleted_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFormatListBulleted)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFormatListBulleted.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFormatListBulleted,
  selectors: [["rux-icon-format-list-bulleted"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFormatListBulleted_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFormatListBulleted = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFormatListBulleted);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFormatListBulleted, [{
    type: Component,
    args: [{
      selector: "rux-icon-format-list-bulleted",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFormatListNumbered = class RuxIconFormatListNumbered2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFormatListNumbered.ɵfac = function RuxIconFormatListNumbered_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFormatListNumbered)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFormatListNumbered.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFormatListNumbered,
  selectors: [["rux-icon-format-list-numbered"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFormatListNumbered_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFormatListNumbered = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFormatListNumbered);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFormatListNumbered, [{
    type: Component,
    args: [{
      selector: "rux-icon-format-list-numbered",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFormatListNumberedRtl = class RuxIconFormatListNumberedRtl2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFormatListNumberedRtl.ɵfac = function RuxIconFormatListNumberedRtl_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFormatListNumberedRtl)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFormatListNumberedRtl.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFormatListNumberedRtl,
  selectors: [["rux-icon-format-list-numbered-rtl"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFormatListNumberedRtl_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFormatListNumberedRtl = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFormatListNumberedRtl);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFormatListNumberedRtl, [{
    type: Component,
    args: [{
      selector: "rux-icon-format-list-numbered-rtl",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFormatPaint = class RuxIconFormatPaint2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFormatPaint.ɵfac = function RuxIconFormatPaint_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFormatPaint)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFormatPaint.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFormatPaint,
  selectors: [["rux-icon-format-paint"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFormatPaint_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFormatPaint = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFormatPaint);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFormatPaint, [{
    type: Component,
    args: [{
      selector: "rux-icon-format-paint",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFormatQuote = class RuxIconFormatQuote2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFormatQuote.ɵfac = function RuxIconFormatQuote_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFormatQuote)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFormatQuote.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFormatQuote,
  selectors: [["rux-icon-format-quote"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFormatQuote_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFormatQuote = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFormatQuote);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFormatQuote, [{
    type: Component,
    args: [{
      selector: "rux-icon-format-quote",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFormatShapes = class RuxIconFormatShapes2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFormatShapes.ɵfac = function RuxIconFormatShapes_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFormatShapes)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFormatShapes.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFormatShapes,
  selectors: [["rux-icon-format-shapes"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFormatShapes_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFormatShapes = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFormatShapes);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFormatShapes, [{
    type: Component,
    args: [{
      selector: "rux-icon-format-shapes",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFormatSize = class RuxIconFormatSize2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFormatSize.ɵfac = function RuxIconFormatSize_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFormatSize)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFormatSize.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFormatSize,
  selectors: [["rux-icon-format-size"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFormatSize_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFormatSize = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFormatSize);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFormatSize, [{
    type: Component,
    args: [{
      selector: "rux-icon-format-size",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFormatStrikethrough = class RuxIconFormatStrikethrough2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFormatStrikethrough.ɵfac = function RuxIconFormatStrikethrough_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFormatStrikethrough)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFormatStrikethrough.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFormatStrikethrough,
  selectors: [["rux-icon-format-strikethrough"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFormatStrikethrough_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFormatStrikethrough = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFormatStrikethrough);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFormatStrikethrough, [{
    type: Component,
    args: [{
      selector: "rux-icon-format-strikethrough",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFormatTextdirectionLToR = class RuxIconFormatTextdirectionLToR2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFormatTextdirectionLToR.ɵfac = function RuxIconFormatTextdirectionLToR_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFormatTextdirectionLToR)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFormatTextdirectionLToR.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFormatTextdirectionLToR,
  selectors: [["rux-icon-format-textdirection-l-to-r"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFormatTextdirectionLToR_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFormatTextdirectionLToR = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFormatTextdirectionLToR);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFormatTextdirectionLToR, [{
    type: Component,
    args: [{
      selector: "rux-icon-format-textdirection-l-to-r",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFormatTextdirectionRToL = class RuxIconFormatTextdirectionRToL2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFormatTextdirectionRToL.ɵfac = function RuxIconFormatTextdirectionRToL_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFormatTextdirectionRToL)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFormatTextdirectionRToL.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFormatTextdirectionRToL,
  selectors: [["rux-icon-format-textdirection-r-to-l"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFormatTextdirectionRToL_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFormatTextdirectionRToL = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFormatTextdirectionRToL);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFormatTextdirectionRToL, [{
    type: Component,
    args: [{
      selector: "rux-icon-format-textdirection-r-to-l",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFormatUnderlined = class RuxIconFormatUnderlined2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFormatUnderlined.ɵfac = function RuxIconFormatUnderlined_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFormatUnderlined)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFormatUnderlined.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFormatUnderlined,
  selectors: [["rux-icon-format-underlined"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFormatUnderlined_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFormatUnderlined = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFormatUnderlined);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFormatUnderlined, [{
    type: Component,
    args: [{
      selector: "rux-icon-format-underlined",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconForum = class RuxIconForum2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconForum.ɵfac = function RuxIconForum_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconForum)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconForum.ɵcmp = ɵɵdefineComponent({
  type: RuxIconForum,
  selectors: [["rux-icon-forum"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconForum_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconForum = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconForum);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconForum, [{
    type: Component,
    args: [{
      selector: "rux-icon-forum",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconForward = class RuxIconForward2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconForward.ɵfac = function RuxIconForward_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconForward)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconForward.ɵcmp = ɵɵdefineComponent({
  type: RuxIconForward,
  selectors: [["rux-icon-forward"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconForward_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconForward = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconForward);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconForward, [{
    type: Component,
    args: [{
      selector: "rux-icon-forward",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconForward10 = class RuxIconForward102 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconForward10.ɵfac = function RuxIconForward10_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconForward10)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconForward10.ɵcmp = ɵɵdefineComponent({
  type: RuxIconForward10,
  selectors: [["rux-icon-forward-10"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconForward10_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconForward10 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconForward10);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconForward10, [{
    type: Component,
    args: [{
      selector: "rux-icon-forward-10",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconForward30 = class RuxIconForward302 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconForward30.ɵfac = function RuxIconForward30_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconForward30)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconForward30.ɵcmp = ɵɵdefineComponent({
  type: RuxIconForward30,
  selectors: [["rux-icon-forward-30"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconForward30_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconForward30 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconForward30);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconForward30, [{
    type: Component,
    args: [{
      selector: "rux-icon-forward-30",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconForward5 = class RuxIconForward52 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconForward5.ɵfac = function RuxIconForward5_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconForward5)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconForward5.ɵcmp = ɵɵdefineComponent({
  type: RuxIconForward5,
  selectors: [["rux-icon-forward-5"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconForward5_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconForward5 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconForward5);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconForward5, [{
    type: Component,
    args: [{
      selector: "rux-icon-forward-5",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFreeBreakfast = class RuxIconFreeBreakfast2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFreeBreakfast.ɵfac = function RuxIconFreeBreakfast_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFreeBreakfast)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFreeBreakfast.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFreeBreakfast,
  selectors: [["rux-icon-free-breakfast"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFreeBreakfast_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFreeBreakfast = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFreeBreakfast);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFreeBreakfast, [{
    type: Component,
    args: [{
      selector: "rux-icon-free-breakfast",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFullscreen = class RuxIconFullscreen2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFullscreen.ɵfac = function RuxIconFullscreen_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFullscreen)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFullscreen.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFullscreen,
  selectors: [["rux-icon-fullscreen"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFullscreen_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFullscreen = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFullscreen);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFullscreen, [{
    type: Component,
    args: [{
      selector: "rux-icon-fullscreen",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFullscreenExit = class RuxIconFullscreenExit2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFullscreenExit.ɵfac = function RuxIconFullscreenExit_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFullscreenExit)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFullscreenExit.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFullscreenExit,
  selectors: [["rux-icon-fullscreen-exit"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFullscreenExit_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFullscreenExit = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFullscreenExit);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFullscreenExit, [{
    type: Component,
    args: [{
      selector: "rux-icon-fullscreen-exit",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconFunctions = class RuxIconFunctions2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconFunctions.ɵfac = function RuxIconFunctions_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconFunctions)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconFunctions.ɵcmp = ɵɵdefineComponent({
  type: RuxIconFunctions,
  selectors: [["rux-icon-functions"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconFunctions_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconFunctions = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconFunctions);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconFunctions, [{
    type: Component,
    args: [{
      selector: "rux-icon-functions",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconGTranslate = class RuxIconGTranslate2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconGTranslate.ɵfac = function RuxIconGTranslate_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconGTranslate)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconGTranslate.ɵcmp = ɵɵdefineComponent({
  type: RuxIconGTranslate,
  selectors: [["rux-icon-g-translate"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconGTranslate_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconGTranslate = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconGTranslate);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconGTranslate, [{
    type: Component,
    args: [{
      selector: "rux-icon-g-translate",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconGamepad = class RuxIconGamepad2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconGamepad.ɵfac = function RuxIconGamepad_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconGamepad)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconGamepad.ɵcmp = ɵɵdefineComponent({
  type: RuxIconGamepad,
  selectors: [["rux-icon-gamepad"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconGamepad_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconGamepad = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconGamepad);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconGamepad, [{
    type: Component,
    args: [{
      selector: "rux-icon-gamepad",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconGames = class RuxIconGames2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconGames.ɵfac = function RuxIconGames_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconGames)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconGames.ɵcmp = ɵɵdefineComponent({
  type: RuxIconGames,
  selectors: [["rux-icon-games"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconGames_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconGames = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconGames);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconGames, [{
    type: Component,
    args: [{
      selector: "rux-icon-games",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconGavel = class RuxIconGavel2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconGavel.ɵfac = function RuxIconGavel_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconGavel)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconGavel.ɵcmp = ɵɵdefineComponent({
  type: RuxIconGavel,
  selectors: [["rux-icon-gavel"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconGavel_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconGavel = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconGavel);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconGavel, [{
    type: Component,
    args: [{
      selector: "rux-icon-gavel",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconGesture = class RuxIconGesture2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconGesture.ɵfac = function RuxIconGesture_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconGesture)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconGesture.ɵcmp = ɵɵdefineComponent({
  type: RuxIconGesture,
  selectors: [["rux-icon-gesture"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconGesture_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconGesture = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconGesture);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconGesture, [{
    type: Component,
    args: [{
      selector: "rux-icon-gesture",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconGetApp = class RuxIconGetApp2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconGetApp.ɵfac = function RuxIconGetApp_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconGetApp)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconGetApp.ɵcmp = ɵɵdefineComponent({
  type: RuxIconGetApp,
  selectors: [["rux-icon-get-app"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconGetApp_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconGetApp = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconGetApp);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconGetApp, [{
    type: Component,
    args: [{
      selector: "rux-icon-get-app",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconGif = class RuxIconGif2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconGif.ɵfac = function RuxIconGif_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconGif)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconGif.ɵcmp = ɵɵdefineComponent({
  type: RuxIconGif,
  selectors: [["rux-icon-gif"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconGif_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconGif = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconGif);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconGif, [{
    type: Component,
    args: [{
      selector: "rux-icon-gif",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconGolfCourse = class RuxIconGolfCourse2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconGolfCourse.ɵfac = function RuxIconGolfCourse_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconGolfCourse)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconGolfCourse.ɵcmp = ɵɵdefineComponent({
  type: RuxIconGolfCourse,
  selectors: [["rux-icon-golf-course"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconGolfCourse_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconGolfCourse = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconGolfCourse);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconGolfCourse, [{
    type: Component,
    args: [{
      selector: "rux-icon-golf-course",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconGpsFixed = class RuxIconGpsFixed2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconGpsFixed.ɵfac = function RuxIconGpsFixed_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconGpsFixed)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconGpsFixed.ɵcmp = ɵɵdefineComponent({
  type: RuxIconGpsFixed,
  selectors: [["rux-icon-gps-fixed"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconGpsFixed_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconGpsFixed = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconGpsFixed);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconGpsFixed, [{
    type: Component,
    args: [{
      selector: "rux-icon-gps-fixed",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconGpsNotFixed = class RuxIconGpsNotFixed2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconGpsNotFixed.ɵfac = function RuxIconGpsNotFixed_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconGpsNotFixed)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconGpsNotFixed.ɵcmp = ɵɵdefineComponent({
  type: RuxIconGpsNotFixed,
  selectors: [["rux-icon-gps-not-fixed"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconGpsNotFixed_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconGpsNotFixed = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconGpsNotFixed);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconGpsNotFixed, [{
    type: Component,
    args: [{
      selector: "rux-icon-gps-not-fixed",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconGpsOff = class RuxIconGpsOff2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconGpsOff.ɵfac = function RuxIconGpsOff_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconGpsOff)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconGpsOff.ɵcmp = ɵɵdefineComponent({
  type: RuxIconGpsOff,
  selectors: [["rux-icon-gps-off"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconGpsOff_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconGpsOff = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconGpsOff);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconGpsOff, [{
    type: Component,
    args: [{
      selector: "rux-icon-gps-off",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconGrade = class RuxIconGrade2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconGrade.ɵfac = function RuxIconGrade_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconGrade)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconGrade.ɵcmp = ɵɵdefineComponent({
  type: RuxIconGrade,
  selectors: [["rux-icon-grade"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconGrade_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconGrade = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconGrade);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconGrade, [{
    type: Component,
    args: [{
      selector: "rux-icon-grade",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconGradient = class RuxIconGradient2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconGradient.ɵfac = function RuxIconGradient_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconGradient)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconGradient.ɵcmp = ɵɵdefineComponent({
  type: RuxIconGradient,
  selectors: [["rux-icon-gradient"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconGradient_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconGradient = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconGradient);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconGradient, [{
    type: Component,
    args: [{
      selector: "rux-icon-gradient",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconGrain = class RuxIconGrain2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconGrain.ɵfac = function RuxIconGrain_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconGrain)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconGrain.ɵcmp = ɵɵdefineComponent({
  type: RuxIconGrain,
  selectors: [["rux-icon-grain"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconGrain_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconGrain = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconGrain);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconGrain, [{
    type: Component,
    args: [{
      selector: "rux-icon-grain",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconGraphicEq = class RuxIconGraphicEq2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconGraphicEq.ɵfac = function RuxIconGraphicEq_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconGraphicEq)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconGraphicEq.ɵcmp = ɵɵdefineComponent({
  type: RuxIconGraphicEq,
  selectors: [["rux-icon-graphic-eq"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconGraphicEq_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconGraphicEq = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconGraphicEq);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconGraphicEq, [{
    type: Component,
    args: [{
      selector: "rux-icon-graphic-eq",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconGridOff = class RuxIconGridOff2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconGridOff.ɵfac = function RuxIconGridOff_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconGridOff)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconGridOff.ɵcmp = ɵɵdefineComponent({
  type: RuxIconGridOff,
  selectors: [["rux-icon-grid-off"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconGridOff_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconGridOff = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconGridOff);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconGridOff, [{
    type: Component,
    args: [{
      selector: "rux-icon-grid-off",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconGridOn = class RuxIconGridOn2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconGridOn.ɵfac = function RuxIconGridOn_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconGridOn)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconGridOn.ɵcmp = ɵɵdefineComponent({
  type: RuxIconGridOn,
  selectors: [["rux-icon-grid-on"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconGridOn_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconGridOn = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconGridOn);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconGridOn, [{
    type: Component,
    args: [{
      selector: "rux-icon-grid-on",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconGroup = class RuxIconGroup2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconGroup.ɵfac = function RuxIconGroup_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconGroup)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconGroup.ɵcmp = ɵɵdefineComponent({
  type: RuxIconGroup,
  selectors: [["rux-icon-group"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconGroup_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconGroup = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconGroup);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconGroup, [{
    type: Component,
    args: [{
      selector: "rux-icon-group",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconGroupAdd = class RuxIconGroupAdd2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconGroupAdd.ɵfac = function RuxIconGroupAdd_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconGroupAdd)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconGroupAdd.ɵcmp = ɵɵdefineComponent({
  type: RuxIconGroupAdd,
  selectors: [["rux-icon-group-add"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconGroupAdd_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconGroupAdd = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconGroupAdd);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconGroupAdd, [{
    type: Component,
    args: [{
      selector: "rux-icon-group-add",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconGroupWork = class RuxIconGroupWork2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconGroupWork.ɵfac = function RuxIconGroupWork_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconGroupWork)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconGroupWork.ɵcmp = ɵɵdefineComponent({
  type: RuxIconGroupWork,
  selectors: [["rux-icon-group-work"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconGroupWork_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconGroupWork = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconGroupWork);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconGroupWork, [{
    type: Component,
    args: [{
      selector: "rux-icon-group-work",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconHardware = class RuxIconHardware2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconHardware.ɵfac = function RuxIconHardware_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconHardware)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconHardware.ɵcmp = ɵɵdefineComponent({
  type: RuxIconHardware,
  selectors: [["rux-icon-hardware"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconHardware_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconHardware = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconHardware);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconHardware, [{
    type: Component,
    args: [{
      selector: "rux-icon-hardware",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconHd = class RuxIconHd2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconHd.ɵfac = function RuxIconHd_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconHd)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconHd.ɵcmp = ɵɵdefineComponent({
  type: RuxIconHd,
  selectors: [["rux-icon-hd"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconHd_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconHd = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconHd);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconHd, [{
    type: Component,
    args: [{
      selector: "rux-icon-hd",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconHdrOff = class RuxIconHdrOff2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconHdrOff.ɵfac = function RuxIconHdrOff_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconHdrOff)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconHdrOff.ɵcmp = ɵɵdefineComponent({
  type: RuxIconHdrOff,
  selectors: [["rux-icon-hdr-off"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconHdrOff_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconHdrOff = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconHdrOff);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconHdrOff, [{
    type: Component,
    args: [{
      selector: "rux-icon-hdr-off",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconHdrOn = class RuxIconHdrOn2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconHdrOn.ɵfac = function RuxIconHdrOn_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconHdrOn)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconHdrOn.ɵcmp = ɵɵdefineComponent({
  type: RuxIconHdrOn,
  selectors: [["rux-icon-hdr-on"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconHdrOn_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconHdrOn = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconHdrOn);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconHdrOn, [{
    type: Component,
    args: [{
      selector: "rux-icon-hdr-on",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconHdrStrong = class RuxIconHdrStrong2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconHdrStrong.ɵfac = function RuxIconHdrStrong_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconHdrStrong)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconHdrStrong.ɵcmp = ɵɵdefineComponent({
  type: RuxIconHdrStrong,
  selectors: [["rux-icon-hdr-strong"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconHdrStrong_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconHdrStrong = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconHdrStrong);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconHdrStrong, [{
    type: Component,
    args: [{
      selector: "rux-icon-hdr-strong",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconHdrWeak = class RuxIconHdrWeak2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconHdrWeak.ɵfac = function RuxIconHdrWeak_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconHdrWeak)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconHdrWeak.ɵcmp = ɵɵdefineComponent({
  type: RuxIconHdrWeak,
  selectors: [["rux-icon-hdr-weak"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconHdrWeak_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconHdrWeak = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconHdrWeak);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconHdrWeak, [{
    type: Component,
    args: [{
      selector: "rux-icon-hdr-weak",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconHeadset = class RuxIconHeadset2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconHeadset.ɵfac = function RuxIconHeadset_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconHeadset)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconHeadset.ɵcmp = ɵɵdefineComponent({
  type: RuxIconHeadset,
  selectors: [["rux-icon-headset"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconHeadset_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconHeadset = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconHeadset);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconHeadset, [{
    type: Component,
    args: [{
      selector: "rux-icon-headset",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconHeadsetMic = class RuxIconHeadsetMic2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconHeadsetMic.ɵfac = function RuxIconHeadsetMic_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconHeadsetMic)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconHeadsetMic.ɵcmp = ɵɵdefineComponent({
  type: RuxIconHeadsetMic,
  selectors: [["rux-icon-headset-mic"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconHeadsetMic_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconHeadsetMic = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconHeadsetMic);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconHeadsetMic, [{
    type: Component,
    args: [{
      selector: "rux-icon-headset-mic",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconHealing = class RuxIconHealing2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconHealing.ɵfac = function RuxIconHealing_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconHealing)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconHealing.ɵcmp = ɵɵdefineComponent({
  type: RuxIconHealing,
  selectors: [["rux-icon-healing"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconHealing_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconHealing = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconHealing);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconHealing, [{
    type: Component,
    args: [{
      selector: "rux-icon-healing",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconHearing = class RuxIconHearing2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconHearing.ɵfac = function RuxIconHearing_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconHearing)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconHearing.ɵcmp = ɵɵdefineComponent({
  type: RuxIconHearing,
  selectors: [["rux-icon-hearing"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconHearing_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconHearing = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconHearing);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconHearing, [{
    type: Component,
    args: [{
      selector: "rux-icon-hearing",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconHelp = class RuxIconHelp2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconHelp.ɵfac = function RuxIconHelp_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconHelp)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconHelp.ɵcmp = ɵɵdefineComponent({
  type: RuxIconHelp,
  selectors: [["rux-icon-help"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconHelp_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconHelp = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconHelp);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconHelp, [{
    type: Component,
    args: [{
      selector: "rux-icon-help",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconHelpOutline = class RuxIconHelpOutline2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconHelpOutline.ɵfac = function RuxIconHelpOutline_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconHelpOutline)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconHelpOutline.ɵcmp = ɵɵdefineComponent({
  type: RuxIconHelpOutline,
  selectors: [["rux-icon-help-outline"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconHelpOutline_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconHelpOutline = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconHelpOutline);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconHelpOutline, [{
    type: Component,
    args: [{
      selector: "rux-icon-help-outline",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconHighQuality = class RuxIconHighQuality2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconHighQuality.ɵfac = function RuxIconHighQuality_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconHighQuality)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconHighQuality.ɵcmp = ɵɵdefineComponent({
  type: RuxIconHighQuality,
  selectors: [["rux-icon-high-quality"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconHighQuality_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconHighQuality = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconHighQuality);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconHighQuality, [{
    type: Component,
    args: [{
      selector: "rux-icon-high-quality",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconHighlight = class RuxIconHighlight2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconHighlight.ɵfac = function RuxIconHighlight_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconHighlight)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconHighlight.ɵcmp = ɵɵdefineComponent({
  type: RuxIconHighlight,
  selectors: [["rux-icon-highlight"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconHighlight_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconHighlight = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconHighlight);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconHighlight, [{
    type: Component,
    args: [{
      selector: "rux-icon-highlight",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconHighlightOff = class RuxIconHighlightOff2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconHighlightOff.ɵfac = function RuxIconHighlightOff_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconHighlightOff)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconHighlightOff.ɵcmp = ɵɵdefineComponent({
  type: RuxIconHighlightOff,
  selectors: [["rux-icon-highlight-off"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconHighlightOff_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconHighlightOff = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconHighlightOff);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconHighlightOff, [{
    type: Component,
    args: [{
      selector: "rux-icon-highlight-off",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconHistory = class RuxIconHistory2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconHistory.ɵfac = function RuxIconHistory_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconHistory)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconHistory.ɵcmp = ɵɵdefineComponent({
  type: RuxIconHistory,
  selectors: [["rux-icon-history"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconHistory_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconHistory = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconHistory);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconHistory, [{
    type: Component,
    args: [{
      selector: "rux-icon-history",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconHome = class RuxIconHome2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconHome.ɵfac = function RuxIconHome_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconHome)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconHome.ɵcmp = ɵɵdefineComponent({
  type: RuxIconHome,
  selectors: [["rux-icon-home"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconHome_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconHome = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconHome);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconHome, [{
    type: Component,
    args: [{
      selector: "rux-icon-home",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconHorizontalSplit = class RuxIconHorizontalSplit2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconHorizontalSplit.ɵfac = function RuxIconHorizontalSplit_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconHorizontalSplit)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconHorizontalSplit.ɵcmp = ɵɵdefineComponent({
  type: RuxIconHorizontalSplit,
  selectors: [["rux-icon-horizontal-split"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconHorizontalSplit_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconHorizontalSplit = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconHorizontalSplit);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconHorizontalSplit, [{
    type: Component,
    args: [{
      selector: "rux-icon-horizontal-split",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconHotTub = class RuxIconHotTub2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconHotTub.ɵfac = function RuxIconHotTub_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconHotTub)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconHotTub.ɵcmp = ɵɵdefineComponent({
  type: RuxIconHotTub,
  selectors: [["rux-icon-hot-tub"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconHotTub_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconHotTub = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconHotTub);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconHotTub, [{
    type: Component,
    args: [{
      selector: "rux-icon-hot-tub",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconHotel = class RuxIconHotel2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconHotel.ɵfac = function RuxIconHotel_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconHotel)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconHotel.ɵcmp = ɵɵdefineComponent({
  type: RuxIconHotel,
  selectors: [["rux-icon-hotel"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconHotel_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconHotel = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconHotel);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconHotel, [{
    type: Component,
    args: [{
      selector: "rux-icon-hotel",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconHourglassEmpty = class RuxIconHourglassEmpty2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconHourglassEmpty.ɵfac = function RuxIconHourglassEmpty_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconHourglassEmpty)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconHourglassEmpty.ɵcmp = ɵɵdefineComponent({
  type: RuxIconHourglassEmpty,
  selectors: [["rux-icon-hourglass-empty"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconHourglassEmpty_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconHourglassEmpty = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconHourglassEmpty);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconHourglassEmpty, [{
    type: Component,
    args: [{
      selector: "rux-icon-hourglass-empty",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconHourglassFull = class RuxIconHourglassFull2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconHourglassFull.ɵfac = function RuxIconHourglassFull_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconHourglassFull)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconHourglassFull.ɵcmp = ɵɵdefineComponent({
  type: RuxIconHourglassFull,
  selectors: [["rux-icon-hourglass-full"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconHourglassFull_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconHourglassFull = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconHourglassFull);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconHourglassFull, [{
    type: Component,
    args: [{
      selector: "rux-icon-hourglass-full",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconHowToReg = class RuxIconHowToReg2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconHowToReg.ɵfac = function RuxIconHowToReg_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconHowToReg)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconHowToReg.ɵcmp = ɵɵdefineComponent({
  type: RuxIconHowToReg,
  selectors: [["rux-icon-how-to-reg"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconHowToReg_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconHowToReg = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconHowToReg);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconHowToReg, [{
    type: Component,
    args: [{
      selector: "rux-icon-how-to-reg",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconHowToVote = class RuxIconHowToVote2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconHowToVote.ɵfac = function RuxIconHowToVote_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconHowToVote)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconHowToVote.ɵcmp = ɵɵdefineComponent({
  type: RuxIconHowToVote,
  selectors: [["rux-icon-how-to-vote"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconHowToVote_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconHowToVote = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconHowToVote);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconHowToVote, [{
    type: Component,
    args: [{
      selector: "rux-icon-how-to-vote",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconHttp = class RuxIconHttp2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconHttp.ɵfac = function RuxIconHttp_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconHttp)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconHttp.ɵcmp = ɵɵdefineComponent({
  type: RuxIconHttp,
  selectors: [["rux-icon-http"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconHttp_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconHttp = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconHttp);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconHttp, [{
    type: Component,
    args: [{
      selector: "rux-icon-http",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconHttps = class RuxIconHttps2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconHttps.ɵfac = function RuxIconHttps_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconHttps)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconHttps.ɵcmp = ɵɵdefineComponent({
  type: RuxIconHttps,
  selectors: [["rux-icon-https"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconHttps_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconHttps = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconHttps);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconHttps, [{
    type: Component,
    args: [{
      selector: "rux-icon-https",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconImage = class RuxIconImage2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconImage.ɵfac = function RuxIconImage_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconImage)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconImage.ɵcmp = ɵɵdefineComponent({
  type: RuxIconImage,
  selectors: [["rux-icon-image"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconImage_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconImage = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconImage);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconImage, [{
    type: Component,
    args: [{
      selector: "rux-icon-image",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconImageAspectRatio = class RuxIconImageAspectRatio2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconImageAspectRatio.ɵfac = function RuxIconImageAspectRatio_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconImageAspectRatio)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconImageAspectRatio.ɵcmp = ɵɵdefineComponent({
  type: RuxIconImageAspectRatio,
  selectors: [["rux-icon-image-aspect-ratio"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconImageAspectRatio_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconImageAspectRatio = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconImageAspectRatio);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconImageAspectRatio, [{
    type: Component,
    args: [{
      selector: "rux-icon-image-aspect-ratio",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconImageSearch = class RuxIconImageSearch2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconImageSearch.ɵfac = function RuxIconImageSearch_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconImageSearch)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconImageSearch.ɵcmp = ɵɵdefineComponent({
  type: RuxIconImageSearch,
  selectors: [["rux-icon-image-search"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconImageSearch_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconImageSearch = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconImageSearch);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconImageSearch, [{
    type: Component,
    args: [{
      selector: "rux-icon-image-search",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconImportContacts = class RuxIconImportContacts2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconImportContacts.ɵfac = function RuxIconImportContacts_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconImportContacts)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconImportContacts.ɵcmp = ɵɵdefineComponent({
  type: RuxIconImportContacts,
  selectors: [["rux-icon-import-contacts"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconImportContacts_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconImportContacts = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconImportContacts);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconImportContacts, [{
    type: Component,
    args: [{
      selector: "rux-icon-import-contacts",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconImportExport = class RuxIconImportExport2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconImportExport.ɵfac = function RuxIconImportExport_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconImportExport)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconImportExport.ɵcmp = ɵɵdefineComponent({
  type: RuxIconImportExport,
  selectors: [["rux-icon-import-export"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconImportExport_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconImportExport = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconImportExport);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconImportExport, [{
    type: Component,
    args: [{
      selector: "rux-icon-import-export",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconImportantDevices = class RuxIconImportantDevices2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconImportantDevices.ɵfac = function RuxIconImportantDevices_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconImportantDevices)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconImportantDevices.ɵcmp = ɵɵdefineComponent({
  type: RuxIconImportantDevices,
  selectors: [["rux-icon-important-devices"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconImportantDevices_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconImportantDevices = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconImportantDevices);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconImportantDevices, [{
    type: Component,
    args: [{
      selector: "rux-icon-important-devices",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconInbox = class RuxIconInbox2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconInbox.ɵfac = function RuxIconInbox_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconInbox)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconInbox.ɵcmp = ɵɵdefineComponent({
  type: RuxIconInbox,
  selectors: [["rux-icon-inbox"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconInbox_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconInbox = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconInbox);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconInbox, [{
    type: Component,
    args: [{
      selector: "rux-icon-inbox",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconIndeterminateCheckBox = class RuxIconIndeterminateCheckBox2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconIndeterminateCheckBox.ɵfac = function RuxIconIndeterminateCheckBox_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconIndeterminateCheckBox)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconIndeterminateCheckBox.ɵcmp = ɵɵdefineComponent({
  type: RuxIconIndeterminateCheckBox,
  selectors: [["rux-icon-indeterminate-check-box"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconIndeterminateCheckBox_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconIndeterminateCheckBox = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconIndeterminateCheckBox);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconIndeterminateCheckBox, [{
    type: Component,
    args: [{
      selector: "rux-icon-indeterminate-check-box",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconInfo = class RuxIconInfo2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconInfo.ɵfac = function RuxIconInfo_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconInfo)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconInfo.ɵcmp = ɵɵdefineComponent({
  type: RuxIconInfo,
  selectors: [["rux-icon-info"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconInfo_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconInfo = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconInfo);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconInfo, [{
    type: Component,
    args: [{
      selector: "rux-icon-info",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconInput = class RuxIconInput2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconInput.ɵfac = function RuxIconInput_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconInput)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconInput.ɵcmp = ɵɵdefineComponent({
  type: RuxIconInput,
  selectors: [["rux-icon-input"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconInput_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconInput = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconInput);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconInput, [{
    type: Component,
    args: [{
      selector: "rux-icon-input",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconInsertChart = class RuxIconInsertChart2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconInsertChart.ɵfac = function RuxIconInsertChart_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconInsertChart)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconInsertChart.ɵcmp = ɵɵdefineComponent({
  type: RuxIconInsertChart,
  selectors: [["rux-icon-insert-chart"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconInsertChart_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconInsertChart = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconInsertChart);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconInsertChart, [{
    type: Component,
    args: [{
      selector: "rux-icon-insert-chart",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconInsertChartOutlined = class RuxIconInsertChartOutlined2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconInsertChartOutlined.ɵfac = function RuxIconInsertChartOutlined_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconInsertChartOutlined)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconInsertChartOutlined.ɵcmp = ɵɵdefineComponent({
  type: RuxIconInsertChartOutlined,
  selectors: [["rux-icon-insert-chart-outlined"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconInsertChartOutlined_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconInsertChartOutlined = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconInsertChartOutlined);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconInsertChartOutlined, [{
    type: Component,
    args: [{
      selector: "rux-icon-insert-chart-outlined",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconInsertComment = class RuxIconInsertComment2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconInsertComment.ɵfac = function RuxIconInsertComment_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconInsertComment)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconInsertComment.ɵcmp = ɵɵdefineComponent({
  type: RuxIconInsertComment,
  selectors: [["rux-icon-insert-comment"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconInsertComment_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconInsertComment = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconInsertComment);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconInsertComment, [{
    type: Component,
    args: [{
      selector: "rux-icon-insert-comment",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconInsertDriveFile = class RuxIconInsertDriveFile2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconInsertDriveFile.ɵfac = function RuxIconInsertDriveFile_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconInsertDriveFile)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconInsertDriveFile.ɵcmp = ɵɵdefineComponent({
  type: RuxIconInsertDriveFile,
  selectors: [["rux-icon-insert-drive-file"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconInsertDriveFile_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconInsertDriveFile = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconInsertDriveFile);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconInsertDriveFile, [{
    type: Component,
    args: [{
      selector: "rux-icon-insert-drive-file",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconInsertEmoticon = class RuxIconInsertEmoticon2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconInsertEmoticon.ɵfac = function RuxIconInsertEmoticon_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconInsertEmoticon)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconInsertEmoticon.ɵcmp = ɵɵdefineComponent({
  type: RuxIconInsertEmoticon,
  selectors: [["rux-icon-insert-emoticon"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconInsertEmoticon_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconInsertEmoticon = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconInsertEmoticon);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconInsertEmoticon, [{
    type: Component,
    args: [{
      selector: "rux-icon-insert-emoticon",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconInsertInvitation = class RuxIconInsertInvitation2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconInsertInvitation.ɵfac = function RuxIconInsertInvitation_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconInsertInvitation)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconInsertInvitation.ɵcmp = ɵɵdefineComponent({
  type: RuxIconInsertInvitation,
  selectors: [["rux-icon-insert-invitation"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconInsertInvitation_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconInsertInvitation = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconInsertInvitation);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconInsertInvitation, [{
    type: Component,
    args: [{
      selector: "rux-icon-insert-invitation",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconInsertLink = class RuxIconInsertLink2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconInsertLink.ɵfac = function RuxIconInsertLink_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconInsertLink)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconInsertLink.ɵcmp = ɵɵdefineComponent({
  type: RuxIconInsertLink,
  selectors: [["rux-icon-insert-link"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconInsertLink_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconInsertLink = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconInsertLink);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconInsertLink, [{
    type: Component,
    args: [{
      selector: "rux-icon-insert-link",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconInsertPhoto = class RuxIconInsertPhoto2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconInsertPhoto.ɵfac = function RuxIconInsertPhoto_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconInsertPhoto)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconInsertPhoto.ɵcmp = ɵɵdefineComponent({
  type: RuxIconInsertPhoto,
  selectors: [["rux-icon-insert-photo"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconInsertPhoto_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconInsertPhoto = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconInsertPhoto);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconInsertPhoto, [{
    type: Component,
    args: [{
      selector: "rux-icon-insert-photo",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconInvertColors = class RuxIconInvertColors2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconInvertColors.ɵfac = function RuxIconInvertColors_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconInvertColors)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconInvertColors.ɵcmp = ɵɵdefineComponent({
  type: RuxIconInvertColors,
  selectors: [["rux-icon-invert-colors"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconInvertColors_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconInvertColors = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconInvertColors);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconInvertColors, [{
    type: Component,
    args: [{
      selector: "rux-icon-invert-colors",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconInvertColorsOff = class RuxIconInvertColorsOff2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconInvertColorsOff.ɵfac = function RuxIconInvertColorsOff_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconInvertColorsOff)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconInvertColorsOff.ɵcmp = ɵɵdefineComponent({
  type: RuxIconInvertColorsOff,
  selectors: [["rux-icon-invert-colors-off"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconInvertColorsOff_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconInvertColorsOff = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconInvertColorsOff);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconInvertColorsOff, [{
    type: Component,
    args: [{
      selector: "rux-icon-invert-colors-off",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconIso = class RuxIconIso2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconIso.ɵfac = function RuxIconIso_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconIso)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconIso.ɵcmp = ɵɵdefineComponent({
  type: RuxIconIso,
  selectors: [["rux-icon-iso"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconIso_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconIso = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconIso);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconIso, [{
    type: Component,
    args: [{
      selector: "rux-icon-iso",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconKeyboard = class RuxIconKeyboard2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconKeyboard.ɵfac = function RuxIconKeyboard_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconKeyboard)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconKeyboard.ɵcmp = ɵɵdefineComponent({
  type: RuxIconKeyboard,
  selectors: [["rux-icon-keyboard"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconKeyboard_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconKeyboard = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconKeyboard);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconKeyboard, [{
    type: Component,
    args: [{
      selector: "rux-icon-keyboard",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconKeyboardArrowDown = class RuxIconKeyboardArrowDown2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconKeyboardArrowDown.ɵfac = function RuxIconKeyboardArrowDown_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconKeyboardArrowDown)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconKeyboardArrowDown.ɵcmp = ɵɵdefineComponent({
  type: RuxIconKeyboardArrowDown,
  selectors: [["rux-icon-keyboard-arrow-down"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconKeyboardArrowDown_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconKeyboardArrowDown = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconKeyboardArrowDown);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconKeyboardArrowDown, [{
    type: Component,
    args: [{
      selector: "rux-icon-keyboard-arrow-down",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconKeyboardArrowLeft = class RuxIconKeyboardArrowLeft2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconKeyboardArrowLeft.ɵfac = function RuxIconKeyboardArrowLeft_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconKeyboardArrowLeft)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconKeyboardArrowLeft.ɵcmp = ɵɵdefineComponent({
  type: RuxIconKeyboardArrowLeft,
  selectors: [["rux-icon-keyboard-arrow-left"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconKeyboardArrowLeft_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconKeyboardArrowLeft = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconKeyboardArrowLeft);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconKeyboardArrowLeft, [{
    type: Component,
    args: [{
      selector: "rux-icon-keyboard-arrow-left",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconKeyboardArrowRight = class RuxIconKeyboardArrowRight2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconKeyboardArrowRight.ɵfac = function RuxIconKeyboardArrowRight_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconKeyboardArrowRight)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconKeyboardArrowRight.ɵcmp = ɵɵdefineComponent({
  type: RuxIconKeyboardArrowRight,
  selectors: [["rux-icon-keyboard-arrow-right"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconKeyboardArrowRight_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconKeyboardArrowRight = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconKeyboardArrowRight);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconKeyboardArrowRight, [{
    type: Component,
    args: [{
      selector: "rux-icon-keyboard-arrow-right",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconKeyboardArrowUp = class RuxIconKeyboardArrowUp2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconKeyboardArrowUp.ɵfac = function RuxIconKeyboardArrowUp_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconKeyboardArrowUp)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconKeyboardArrowUp.ɵcmp = ɵɵdefineComponent({
  type: RuxIconKeyboardArrowUp,
  selectors: [["rux-icon-keyboard-arrow-up"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconKeyboardArrowUp_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconKeyboardArrowUp = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconKeyboardArrowUp);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconKeyboardArrowUp, [{
    type: Component,
    args: [{
      selector: "rux-icon-keyboard-arrow-up",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconKeyboardBackspace = class RuxIconKeyboardBackspace2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconKeyboardBackspace.ɵfac = function RuxIconKeyboardBackspace_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconKeyboardBackspace)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconKeyboardBackspace.ɵcmp = ɵɵdefineComponent({
  type: RuxIconKeyboardBackspace,
  selectors: [["rux-icon-keyboard-backspace"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconKeyboardBackspace_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconKeyboardBackspace = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconKeyboardBackspace);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconKeyboardBackspace, [{
    type: Component,
    args: [{
      selector: "rux-icon-keyboard-backspace",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconKeyboardCapslock = class RuxIconKeyboardCapslock2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconKeyboardCapslock.ɵfac = function RuxIconKeyboardCapslock_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconKeyboardCapslock)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconKeyboardCapslock.ɵcmp = ɵɵdefineComponent({
  type: RuxIconKeyboardCapslock,
  selectors: [["rux-icon-keyboard-capslock"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconKeyboardCapslock_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconKeyboardCapslock = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconKeyboardCapslock);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconKeyboardCapslock, [{
    type: Component,
    args: [{
      selector: "rux-icon-keyboard-capslock",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconKeyboardHide = class RuxIconKeyboardHide2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconKeyboardHide.ɵfac = function RuxIconKeyboardHide_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconKeyboardHide)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconKeyboardHide.ɵcmp = ɵɵdefineComponent({
  type: RuxIconKeyboardHide,
  selectors: [["rux-icon-keyboard-hide"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconKeyboardHide_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconKeyboardHide = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconKeyboardHide);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconKeyboardHide, [{
    type: Component,
    args: [{
      selector: "rux-icon-keyboard-hide",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconKeyboardReturn = class RuxIconKeyboardReturn2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconKeyboardReturn.ɵfac = function RuxIconKeyboardReturn_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconKeyboardReturn)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconKeyboardReturn.ɵcmp = ɵɵdefineComponent({
  type: RuxIconKeyboardReturn,
  selectors: [["rux-icon-keyboard-return"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconKeyboardReturn_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconKeyboardReturn = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconKeyboardReturn);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconKeyboardReturn, [{
    type: Component,
    args: [{
      selector: "rux-icon-keyboard-return",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconKeyboardTab = class RuxIconKeyboardTab2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconKeyboardTab.ɵfac = function RuxIconKeyboardTab_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconKeyboardTab)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconKeyboardTab.ɵcmp = ɵɵdefineComponent({
  type: RuxIconKeyboardTab,
  selectors: [["rux-icon-keyboard-tab"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconKeyboardTab_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconKeyboardTab = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconKeyboardTab);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconKeyboardTab, [{
    type: Component,
    args: [{
      selector: "rux-icon-keyboard-tab",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconKeyboardVoice = class RuxIconKeyboardVoice2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconKeyboardVoice.ɵfac = function RuxIconKeyboardVoice_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconKeyboardVoice)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconKeyboardVoice.ɵcmp = ɵɵdefineComponent({
  type: RuxIconKeyboardVoice,
  selectors: [["rux-icon-keyboard-voice"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconKeyboardVoice_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconKeyboardVoice = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconKeyboardVoice);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconKeyboardVoice, [{
    type: Component,
    args: [{
      selector: "rux-icon-keyboard-voice",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconKitchen = class RuxIconKitchen2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconKitchen.ɵfac = function RuxIconKitchen_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconKitchen)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconKitchen.ɵcmp = ɵɵdefineComponent({
  type: RuxIconKitchen,
  selectors: [["rux-icon-kitchen"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconKitchen_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconKitchen = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconKitchen);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconKitchen, [{
    type: Component,
    args: [{
      selector: "rux-icon-kitchen",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLabel = class RuxIconLabel2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLabel.ɵfac = function RuxIconLabel_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLabel)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLabel.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLabel,
  selectors: [["rux-icon-label"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLabel_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLabel = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLabel);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLabel, [{
    type: Component,
    args: [{
      selector: "rux-icon-label",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLabelImportant = class RuxIconLabelImportant2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLabelImportant.ɵfac = function RuxIconLabelImportant_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLabelImportant)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLabelImportant.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLabelImportant,
  selectors: [["rux-icon-label-important"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLabelImportant_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLabelImportant = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLabelImportant);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLabelImportant, [{
    type: Component,
    args: [{
      selector: "rux-icon-label-important",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLabelOff = class RuxIconLabelOff2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLabelOff.ɵfac = function RuxIconLabelOff_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLabelOff)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLabelOff.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLabelOff,
  selectors: [["rux-icon-label-off"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLabelOff_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLabelOff = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLabelOff);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLabelOff, [{
    type: Component,
    args: [{
      selector: "rux-icon-label-off",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLandscape = class RuxIconLandscape2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLandscape.ɵfac = function RuxIconLandscape_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLandscape)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLandscape.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLandscape,
  selectors: [["rux-icon-landscape"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLandscape_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLandscape = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLandscape);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLandscape, [{
    type: Component,
    args: [{
      selector: "rux-icon-landscape",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLanguage = class RuxIconLanguage2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLanguage.ɵfac = function RuxIconLanguage_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLanguage)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLanguage.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLanguage,
  selectors: [["rux-icon-language"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLanguage_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLanguage = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLanguage);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLanguage, [{
    type: Component,
    args: [{
      selector: "rux-icon-language",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLaptop = class RuxIconLaptop2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLaptop.ɵfac = function RuxIconLaptop_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLaptop)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLaptop.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLaptop,
  selectors: [["rux-icon-laptop"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLaptop_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLaptop = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLaptop);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLaptop, [{
    type: Component,
    args: [{
      selector: "rux-icon-laptop",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLaptopChromebook = class RuxIconLaptopChromebook2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLaptopChromebook.ɵfac = function RuxIconLaptopChromebook_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLaptopChromebook)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLaptopChromebook.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLaptopChromebook,
  selectors: [["rux-icon-laptop-chromebook"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLaptopChromebook_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLaptopChromebook = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLaptopChromebook);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLaptopChromebook, [{
    type: Component,
    args: [{
      selector: "rux-icon-laptop-chromebook",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLaptopMac = class RuxIconLaptopMac2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLaptopMac.ɵfac = function RuxIconLaptopMac_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLaptopMac)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLaptopMac.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLaptopMac,
  selectors: [["rux-icon-laptop-mac"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLaptopMac_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLaptopMac = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLaptopMac);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLaptopMac, [{
    type: Component,
    args: [{
      selector: "rux-icon-laptop-mac",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLaptopWindows = class RuxIconLaptopWindows2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLaptopWindows.ɵfac = function RuxIconLaptopWindows_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLaptopWindows)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLaptopWindows.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLaptopWindows,
  selectors: [["rux-icon-laptop-windows"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLaptopWindows_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLaptopWindows = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLaptopWindows);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLaptopWindows, [{
    type: Component,
    args: [{
      selector: "rux-icon-laptop-windows",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLastPage = class RuxIconLastPage2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLastPage.ɵfac = function RuxIconLastPage_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLastPage)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLastPage.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLastPage,
  selectors: [["rux-icon-last-page"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLastPage_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLastPage = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLastPage);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLastPage, [{
    type: Component,
    args: [{
      selector: "rux-icon-last-page",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLaunch = class RuxIconLaunch2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLaunch.ɵfac = function RuxIconLaunch_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLaunch)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLaunch.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLaunch,
  selectors: [["rux-icon-launch"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLaunch_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLaunch = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLaunch);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLaunch, [{
    type: Component,
    args: [{
      selector: "rux-icon-launch",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLayers = class RuxIconLayers2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLayers.ɵfac = function RuxIconLayers_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLayers)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLayers.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLayers,
  selectors: [["rux-icon-layers"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLayers_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLayers = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLayers);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLayers, [{
    type: Component,
    args: [{
      selector: "rux-icon-layers",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLayersClear = class RuxIconLayersClear2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLayersClear.ɵfac = function RuxIconLayersClear_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLayersClear)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLayersClear.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLayersClear,
  selectors: [["rux-icon-layers-clear"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLayersClear_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLayersClear = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLayersClear);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLayersClear, [{
    type: Component,
    args: [{
      selector: "rux-icon-layers-clear",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLeakAdd = class RuxIconLeakAdd2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLeakAdd.ɵfac = function RuxIconLeakAdd_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLeakAdd)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLeakAdd.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLeakAdd,
  selectors: [["rux-icon-leak-add"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLeakAdd_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLeakAdd = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLeakAdd);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLeakAdd, [{
    type: Component,
    args: [{
      selector: "rux-icon-leak-add",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLeakRemove = class RuxIconLeakRemove2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLeakRemove.ɵfac = function RuxIconLeakRemove_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLeakRemove)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLeakRemove.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLeakRemove,
  selectors: [["rux-icon-leak-remove"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLeakRemove_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLeakRemove = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLeakRemove);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLeakRemove, [{
    type: Component,
    args: [{
      selector: "rux-icon-leak-remove",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLens = class RuxIconLens2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLens.ɵfac = function RuxIconLens_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLens)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLens.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLens,
  selectors: [["rux-icon-lens"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLens_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLens = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLens);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLens, [{
    type: Component,
    args: [{
      selector: "rux-icon-lens",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLibraryAdd = class RuxIconLibraryAdd2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLibraryAdd.ɵfac = function RuxIconLibraryAdd_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLibraryAdd)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLibraryAdd.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLibraryAdd,
  selectors: [["rux-icon-library-add"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLibraryAdd_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLibraryAdd = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLibraryAdd);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLibraryAdd, [{
    type: Component,
    args: [{
      selector: "rux-icon-library-add",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLibraryBooks = class RuxIconLibraryBooks2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLibraryBooks.ɵfac = function RuxIconLibraryBooks_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLibraryBooks)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLibraryBooks.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLibraryBooks,
  selectors: [["rux-icon-library-books"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLibraryBooks_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLibraryBooks = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLibraryBooks);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLibraryBooks, [{
    type: Component,
    args: [{
      selector: "rux-icon-library-books",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLibraryMusic = class RuxIconLibraryMusic2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLibraryMusic.ɵfac = function RuxIconLibraryMusic_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLibraryMusic)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLibraryMusic.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLibraryMusic,
  selectors: [["rux-icon-library-music"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLibraryMusic_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLibraryMusic = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLibraryMusic);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLibraryMusic, [{
    type: Component,
    args: [{
      selector: "rux-icon-library-music",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLineStyle = class RuxIconLineStyle2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLineStyle.ɵfac = function RuxIconLineStyle_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLineStyle)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLineStyle.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLineStyle,
  selectors: [["rux-icon-line-style"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLineStyle_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLineStyle = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLineStyle);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLineStyle, [{
    type: Component,
    args: [{
      selector: "rux-icon-line-style",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLineWeight = class RuxIconLineWeight2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLineWeight.ɵfac = function RuxIconLineWeight_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLineWeight)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLineWeight.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLineWeight,
  selectors: [["rux-icon-line-weight"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLineWeight_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLineWeight = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLineWeight);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLineWeight, [{
    type: Component,
    args: [{
      selector: "rux-icon-line-weight",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLinearScale = class RuxIconLinearScale2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLinearScale.ɵfac = function RuxIconLinearScale_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLinearScale)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLinearScale.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLinearScale,
  selectors: [["rux-icon-linear-scale"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLinearScale_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLinearScale = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLinearScale);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLinearScale, [{
    type: Component,
    args: [{
      selector: "rux-icon-linear-scale",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLink = class RuxIconLink2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLink.ɵfac = function RuxIconLink_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLink)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLink.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLink,
  selectors: [["rux-icon-link"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLink_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLink = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLink);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLink, [{
    type: Component,
    args: [{
      selector: "rux-icon-link",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLinkOff = class RuxIconLinkOff2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLinkOff.ɵfac = function RuxIconLinkOff_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLinkOff)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLinkOff.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLinkOff,
  selectors: [["rux-icon-link-off"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLinkOff_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLinkOff = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLinkOff);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLinkOff, [{
    type: Component,
    args: [{
      selector: "rux-icon-link-off",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLinkedCamera = class RuxIconLinkedCamera2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLinkedCamera.ɵfac = function RuxIconLinkedCamera_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLinkedCamera)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLinkedCamera.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLinkedCamera,
  selectors: [["rux-icon-linked-camera"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLinkedCamera_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLinkedCamera = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLinkedCamera);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLinkedCamera, [{
    type: Component,
    args: [{
      selector: "rux-icon-linked-camera",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconList = class RuxIconList2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconList.ɵfac = function RuxIconList_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconList)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconList.ɵcmp = ɵɵdefineComponent({
  type: RuxIconList,
  selectors: [["rux-icon-list"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconList_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconList = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconList);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconList, [{
    type: Component,
    args: [{
      selector: "rux-icon-list",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconListAlt = class RuxIconListAlt2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconListAlt.ɵfac = function RuxIconListAlt_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconListAlt)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconListAlt.ɵcmp = ɵɵdefineComponent({
  type: RuxIconListAlt,
  selectors: [["rux-icon-list-alt"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconListAlt_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconListAlt = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconListAlt);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconListAlt, [{
    type: Component,
    args: [{
      selector: "rux-icon-list-alt",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLiveHelp = class RuxIconLiveHelp2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLiveHelp.ɵfac = function RuxIconLiveHelp_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLiveHelp)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLiveHelp.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLiveHelp,
  selectors: [["rux-icon-live-help"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLiveHelp_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLiveHelp = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLiveHelp);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLiveHelp, [{
    type: Component,
    args: [{
      selector: "rux-icon-live-help",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLiveTv = class RuxIconLiveTv2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLiveTv.ɵfac = function RuxIconLiveTv_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLiveTv)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLiveTv.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLiveTv,
  selectors: [["rux-icon-live-tv"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLiveTv_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLiveTv = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLiveTv);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLiveTv, [{
    type: Component,
    args: [{
      selector: "rux-icon-live-tv",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLocalActivity = class RuxIconLocalActivity2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLocalActivity.ɵfac = function RuxIconLocalActivity_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLocalActivity)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLocalActivity.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLocalActivity,
  selectors: [["rux-icon-local-activity"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLocalActivity_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLocalActivity = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLocalActivity);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLocalActivity, [{
    type: Component,
    args: [{
      selector: "rux-icon-local-activity",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLocalAirport = class RuxIconLocalAirport2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLocalAirport.ɵfac = function RuxIconLocalAirport_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLocalAirport)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLocalAirport.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLocalAirport,
  selectors: [["rux-icon-local-airport"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLocalAirport_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLocalAirport = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLocalAirport);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLocalAirport, [{
    type: Component,
    args: [{
      selector: "rux-icon-local-airport",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLocalAtm = class RuxIconLocalAtm2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLocalAtm.ɵfac = function RuxIconLocalAtm_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLocalAtm)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLocalAtm.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLocalAtm,
  selectors: [["rux-icon-local-atm"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLocalAtm_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLocalAtm = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLocalAtm);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLocalAtm, [{
    type: Component,
    args: [{
      selector: "rux-icon-local-atm",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLocalBar = class RuxIconLocalBar2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLocalBar.ɵfac = function RuxIconLocalBar_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLocalBar)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLocalBar.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLocalBar,
  selectors: [["rux-icon-local-bar"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLocalBar_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLocalBar = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLocalBar);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLocalBar, [{
    type: Component,
    args: [{
      selector: "rux-icon-local-bar",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLocalCafe = class RuxIconLocalCafe2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLocalCafe.ɵfac = function RuxIconLocalCafe_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLocalCafe)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLocalCafe.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLocalCafe,
  selectors: [["rux-icon-local-cafe"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLocalCafe_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLocalCafe = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLocalCafe);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLocalCafe, [{
    type: Component,
    args: [{
      selector: "rux-icon-local-cafe",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLocalCarWash = class RuxIconLocalCarWash2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLocalCarWash.ɵfac = function RuxIconLocalCarWash_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLocalCarWash)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLocalCarWash.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLocalCarWash,
  selectors: [["rux-icon-local-car-wash"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLocalCarWash_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLocalCarWash = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLocalCarWash);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLocalCarWash, [{
    type: Component,
    args: [{
      selector: "rux-icon-local-car-wash",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLocalConvenienceStore = class RuxIconLocalConvenienceStore2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLocalConvenienceStore.ɵfac = function RuxIconLocalConvenienceStore_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLocalConvenienceStore)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLocalConvenienceStore.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLocalConvenienceStore,
  selectors: [["rux-icon-local-convenience-store"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLocalConvenienceStore_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLocalConvenienceStore = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLocalConvenienceStore);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLocalConvenienceStore, [{
    type: Component,
    args: [{
      selector: "rux-icon-local-convenience-store",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLocalDining = class RuxIconLocalDining2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLocalDining.ɵfac = function RuxIconLocalDining_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLocalDining)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLocalDining.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLocalDining,
  selectors: [["rux-icon-local-dining"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLocalDining_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLocalDining = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLocalDining);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLocalDining, [{
    type: Component,
    args: [{
      selector: "rux-icon-local-dining",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLocalDrink = class RuxIconLocalDrink2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLocalDrink.ɵfac = function RuxIconLocalDrink_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLocalDrink)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLocalDrink.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLocalDrink,
  selectors: [["rux-icon-local-drink"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLocalDrink_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLocalDrink = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLocalDrink);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLocalDrink, [{
    type: Component,
    args: [{
      selector: "rux-icon-local-drink",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLocalGasStation = class RuxIconLocalGasStation2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLocalGasStation.ɵfac = function RuxIconLocalGasStation_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLocalGasStation)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLocalGasStation.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLocalGasStation,
  selectors: [["rux-icon-local-gas-station"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLocalGasStation_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLocalGasStation = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLocalGasStation);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLocalGasStation, [{
    type: Component,
    args: [{
      selector: "rux-icon-local-gas-station",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLocalGroceryStore = class RuxIconLocalGroceryStore2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLocalGroceryStore.ɵfac = function RuxIconLocalGroceryStore_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLocalGroceryStore)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLocalGroceryStore.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLocalGroceryStore,
  selectors: [["rux-icon-local-grocery-store"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLocalGroceryStore_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLocalGroceryStore = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLocalGroceryStore);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLocalGroceryStore, [{
    type: Component,
    args: [{
      selector: "rux-icon-local-grocery-store",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLocalHospital = class RuxIconLocalHospital2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLocalHospital.ɵfac = function RuxIconLocalHospital_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLocalHospital)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLocalHospital.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLocalHospital,
  selectors: [["rux-icon-local-hospital"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLocalHospital_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLocalHospital = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLocalHospital);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLocalHospital, [{
    type: Component,
    args: [{
      selector: "rux-icon-local-hospital",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLocalHotel = class RuxIconLocalHotel2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLocalHotel.ɵfac = function RuxIconLocalHotel_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLocalHotel)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLocalHotel.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLocalHotel,
  selectors: [["rux-icon-local-hotel"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLocalHotel_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLocalHotel = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLocalHotel);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLocalHotel, [{
    type: Component,
    args: [{
      selector: "rux-icon-local-hotel",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLocalLaundryService = class RuxIconLocalLaundryService2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLocalLaundryService.ɵfac = function RuxIconLocalLaundryService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLocalLaundryService)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLocalLaundryService.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLocalLaundryService,
  selectors: [["rux-icon-local-laundry-service"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLocalLaundryService_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLocalLaundryService = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLocalLaundryService);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLocalLaundryService, [{
    type: Component,
    args: [{
      selector: "rux-icon-local-laundry-service",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLocalLibrary = class RuxIconLocalLibrary2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLocalLibrary.ɵfac = function RuxIconLocalLibrary_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLocalLibrary)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLocalLibrary.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLocalLibrary,
  selectors: [["rux-icon-local-library"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLocalLibrary_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLocalLibrary = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLocalLibrary);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLocalLibrary, [{
    type: Component,
    args: [{
      selector: "rux-icon-local-library",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLocalMall = class RuxIconLocalMall2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLocalMall.ɵfac = function RuxIconLocalMall_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLocalMall)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLocalMall.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLocalMall,
  selectors: [["rux-icon-local-mall"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLocalMall_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLocalMall = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLocalMall);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLocalMall, [{
    type: Component,
    args: [{
      selector: "rux-icon-local-mall",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLocalMovies = class RuxIconLocalMovies2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLocalMovies.ɵfac = function RuxIconLocalMovies_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLocalMovies)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLocalMovies.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLocalMovies,
  selectors: [["rux-icon-local-movies"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLocalMovies_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLocalMovies = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLocalMovies);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLocalMovies, [{
    type: Component,
    args: [{
      selector: "rux-icon-local-movies",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLocalOffer = class RuxIconLocalOffer2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLocalOffer.ɵfac = function RuxIconLocalOffer_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLocalOffer)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLocalOffer.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLocalOffer,
  selectors: [["rux-icon-local-offer"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLocalOffer_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLocalOffer = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLocalOffer);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLocalOffer, [{
    type: Component,
    args: [{
      selector: "rux-icon-local-offer",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLocalParking = class RuxIconLocalParking2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLocalParking.ɵfac = function RuxIconLocalParking_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLocalParking)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLocalParking.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLocalParking,
  selectors: [["rux-icon-local-parking"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLocalParking_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLocalParking = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLocalParking);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLocalParking, [{
    type: Component,
    args: [{
      selector: "rux-icon-local-parking",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLocalPharmacy = class RuxIconLocalPharmacy2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLocalPharmacy.ɵfac = function RuxIconLocalPharmacy_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLocalPharmacy)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLocalPharmacy.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLocalPharmacy,
  selectors: [["rux-icon-local-pharmacy"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLocalPharmacy_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLocalPharmacy = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLocalPharmacy);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLocalPharmacy, [{
    type: Component,
    args: [{
      selector: "rux-icon-local-pharmacy",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLocalPhone = class RuxIconLocalPhone2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLocalPhone.ɵfac = function RuxIconLocalPhone_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLocalPhone)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLocalPhone.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLocalPhone,
  selectors: [["rux-icon-local-phone"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLocalPhone_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLocalPhone = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLocalPhone);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLocalPhone, [{
    type: Component,
    args: [{
      selector: "rux-icon-local-phone",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLocalPlay = class RuxIconLocalPlay2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLocalPlay.ɵfac = function RuxIconLocalPlay_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLocalPlay)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLocalPlay.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLocalPlay,
  selectors: [["rux-icon-local-play"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLocalPlay_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLocalPlay = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLocalPlay);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLocalPlay, [{
    type: Component,
    args: [{
      selector: "rux-icon-local-play",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLocalPostOffice = class RuxIconLocalPostOffice2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLocalPostOffice.ɵfac = function RuxIconLocalPostOffice_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLocalPostOffice)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLocalPostOffice.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLocalPostOffice,
  selectors: [["rux-icon-local-post-office"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLocalPostOffice_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLocalPostOffice = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLocalPostOffice);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLocalPostOffice, [{
    type: Component,
    args: [{
      selector: "rux-icon-local-post-office",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLocalPrintshop = class RuxIconLocalPrintshop2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLocalPrintshop.ɵfac = function RuxIconLocalPrintshop_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLocalPrintshop)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLocalPrintshop.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLocalPrintshop,
  selectors: [["rux-icon-local-printshop"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLocalPrintshop_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLocalPrintshop = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLocalPrintshop);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLocalPrintshop, [{
    type: Component,
    args: [{
      selector: "rux-icon-local-printshop",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLocalSee = class RuxIconLocalSee2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLocalSee.ɵfac = function RuxIconLocalSee_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLocalSee)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLocalSee.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLocalSee,
  selectors: [["rux-icon-local-see"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLocalSee_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLocalSee = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLocalSee);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLocalSee, [{
    type: Component,
    args: [{
      selector: "rux-icon-local-see",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLocalShipping = class RuxIconLocalShipping2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLocalShipping.ɵfac = function RuxIconLocalShipping_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLocalShipping)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLocalShipping.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLocalShipping,
  selectors: [["rux-icon-local-shipping"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLocalShipping_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLocalShipping = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLocalShipping);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLocalShipping, [{
    type: Component,
    args: [{
      selector: "rux-icon-local-shipping",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLocalTaxi = class RuxIconLocalTaxi2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLocalTaxi.ɵfac = function RuxIconLocalTaxi_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLocalTaxi)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLocalTaxi.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLocalTaxi,
  selectors: [["rux-icon-local-taxi"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLocalTaxi_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLocalTaxi = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLocalTaxi);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLocalTaxi, [{
    type: Component,
    args: [{
      selector: "rux-icon-local-taxi",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLocationCity = class RuxIconLocationCity2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLocationCity.ɵfac = function RuxIconLocationCity_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLocationCity)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLocationCity.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLocationCity,
  selectors: [["rux-icon-location-city"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLocationCity_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLocationCity = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLocationCity);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLocationCity, [{
    type: Component,
    args: [{
      selector: "rux-icon-location-city",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLocationDisabled = class RuxIconLocationDisabled2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLocationDisabled.ɵfac = function RuxIconLocationDisabled_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLocationDisabled)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLocationDisabled.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLocationDisabled,
  selectors: [["rux-icon-location-disabled"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLocationDisabled_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLocationDisabled = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLocationDisabled);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLocationDisabled, [{
    type: Component,
    args: [{
      selector: "rux-icon-location-disabled",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLocationOff = class RuxIconLocationOff2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLocationOff.ɵfac = function RuxIconLocationOff_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLocationOff)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLocationOff.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLocationOff,
  selectors: [["rux-icon-location-off"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLocationOff_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLocationOff = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLocationOff);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLocationOff, [{
    type: Component,
    args: [{
      selector: "rux-icon-location-off",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLocationOn = class RuxIconLocationOn2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLocationOn.ɵfac = function RuxIconLocationOn_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLocationOn)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLocationOn.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLocationOn,
  selectors: [["rux-icon-location-on"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLocationOn_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLocationOn = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLocationOn);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLocationOn, [{
    type: Component,
    args: [{
      selector: "rux-icon-location-on",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLocationSearching = class RuxIconLocationSearching2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLocationSearching.ɵfac = function RuxIconLocationSearching_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLocationSearching)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLocationSearching.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLocationSearching,
  selectors: [["rux-icon-location-searching"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLocationSearching_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLocationSearching = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLocationSearching);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLocationSearching, [{
    type: Component,
    args: [{
      selector: "rux-icon-location-searching",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLock = class RuxIconLock2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLock.ɵfac = function RuxIconLock_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLock)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLock.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLock,
  selectors: [["rux-icon-lock"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLock_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLock = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLock);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLock, [{
    type: Component,
    args: [{
      selector: "rux-icon-lock",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLockOpen = class RuxIconLockOpen2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLockOpen.ɵfac = function RuxIconLockOpen_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLockOpen)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLockOpen.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLockOpen,
  selectors: [["rux-icon-lock-open"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLockOpen_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLockOpen = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLockOpen);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLockOpen, [{
    type: Component,
    args: [{
      selector: "rux-icon-lock-open",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLooks = class RuxIconLooks2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLooks.ɵfac = function RuxIconLooks_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLooks)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLooks.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLooks,
  selectors: [["rux-icon-looks"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLooks_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLooks = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLooks);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLooks, [{
    type: Component,
    args: [{
      selector: "rux-icon-looks",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLooks1 = class RuxIconLooks12 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLooks1.ɵfac = function RuxIconLooks1_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLooks1)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLooks1.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLooks1,
  selectors: [["rux-icon-looks-1"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLooks1_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLooks1 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLooks1);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLooks1, [{
    type: Component,
    args: [{
      selector: "rux-icon-looks-1",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLooks22 = class RuxIconLooks23 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLooks22.ɵfac = function RuxIconLooks2_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLooks22)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLooks22.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLooks22,
  selectors: [["rux-icon-looks-2"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLooks2_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLooks22 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLooks22);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLooks22, [{
    type: Component,
    args: [{
      selector: "rux-icon-looks-2",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLooks3 = class RuxIconLooks32 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLooks3.ɵfac = function RuxIconLooks3_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLooks3)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLooks3.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLooks3,
  selectors: [["rux-icon-looks-3"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLooks3_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLooks3 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLooks3);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLooks3, [{
    type: Component,
    args: [{
      selector: "rux-icon-looks-3",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLooks4 = class RuxIconLooks42 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLooks4.ɵfac = function RuxIconLooks4_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLooks4)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLooks4.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLooks4,
  selectors: [["rux-icon-looks-4"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLooks4_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLooks4 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLooks4);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLooks4, [{
    type: Component,
    args: [{
      selector: "rux-icon-looks-4",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLooks5 = class RuxIconLooks52 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLooks5.ɵfac = function RuxIconLooks5_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLooks5)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLooks5.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLooks5,
  selectors: [["rux-icon-looks-5"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLooks5_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLooks5 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLooks5);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLooks5, [{
    type: Component,
    args: [{
      selector: "rux-icon-looks-5",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLooks6 = class RuxIconLooks62 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLooks6.ɵfac = function RuxIconLooks6_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLooks6)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLooks6.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLooks6,
  selectors: [["rux-icon-looks-6"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLooks6_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLooks6 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLooks6);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLooks6, [{
    type: Component,
    args: [{
      selector: "rux-icon-looks-6",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLoop = class RuxIconLoop2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLoop.ɵfac = function RuxIconLoop_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLoop)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLoop.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLoop,
  selectors: [["rux-icon-loop"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLoop_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLoop = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLoop);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLoop, [{
    type: Component,
    args: [{
      selector: "rux-icon-loop",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLoupe = class RuxIconLoupe2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLoupe.ɵfac = function RuxIconLoupe_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLoupe)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLoupe.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLoupe,
  selectors: [["rux-icon-loupe"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLoupe_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLoupe = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLoupe);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLoupe, [{
    type: Component,
    args: [{
      selector: "rux-icon-loupe",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLowPriority = class RuxIconLowPriority2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLowPriority.ɵfac = function RuxIconLowPriority_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLowPriority)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLowPriority.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLowPriority,
  selectors: [["rux-icon-low-priority"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLowPriority_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLowPriority = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLowPriority);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLowPriority, [{
    type: Component,
    args: [{
      selector: "rux-icon-low-priority",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconLoyalty = class RuxIconLoyalty2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconLoyalty.ɵfac = function RuxIconLoyalty_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconLoyalty)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconLoyalty.ɵcmp = ɵɵdefineComponent({
  type: RuxIconLoyalty,
  selectors: [["rux-icon-loyalty"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconLoyalty_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconLoyalty = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconLoyalty);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconLoyalty, [{
    type: Component,
    args: [{
      selector: "rux-icon-loyalty",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconMail = class RuxIconMail2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconMail.ɵfac = function RuxIconMail_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconMail)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconMail.ɵcmp = ɵɵdefineComponent({
  type: RuxIconMail,
  selectors: [["rux-icon-mail"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconMail_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconMail = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconMail);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconMail, [{
    type: Component,
    args: [{
      selector: "rux-icon-mail",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconMailOutline = class RuxIconMailOutline2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconMailOutline.ɵfac = function RuxIconMailOutline_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconMailOutline)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconMailOutline.ɵcmp = ɵɵdefineComponent({
  type: RuxIconMailOutline,
  selectors: [["rux-icon-mail-outline"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconMailOutline_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconMailOutline = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconMailOutline);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconMailOutline, [{
    type: Component,
    args: [{
      selector: "rux-icon-mail-outline",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconMap = class RuxIconMap2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconMap.ɵfac = function RuxIconMap_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconMap)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconMap.ɵcmp = ɵɵdefineComponent({
  type: RuxIconMap,
  selectors: [["rux-icon-map"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconMap_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconMap = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconMap);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconMap, [{
    type: Component,
    args: [{
      selector: "rux-icon-map",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconMarkunread = class RuxIconMarkunread2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconMarkunread.ɵfac = function RuxIconMarkunread_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconMarkunread)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconMarkunread.ɵcmp = ɵɵdefineComponent({
  type: RuxIconMarkunread,
  selectors: [["rux-icon-markunread"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconMarkunread_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconMarkunread = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconMarkunread);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconMarkunread, [{
    type: Component,
    args: [{
      selector: "rux-icon-markunread",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconMarkunreadMailbox = class RuxIconMarkunreadMailbox2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconMarkunreadMailbox.ɵfac = function RuxIconMarkunreadMailbox_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconMarkunreadMailbox)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconMarkunreadMailbox.ɵcmp = ɵɵdefineComponent({
  type: RuxIconMarkunreadMailbox,
  selectors: [["rux-icon-markunread-mailbox"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconMarkunreadMailbox_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconMarkunreadMailbox = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconMarkunreadMailbox);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconMarkunreadMailbox, [{
    type: Component,
    args: [{
      selector: "rux-icon-markunread-mailbox",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconMaximize = class RuxIconMaximize2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconMaximize.ɵfac = function RuxIconMaximize_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconMaximize)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconMaximize.ɵcmp = ɵɵdefineComponent({
  type: RuxIconMaximize,
  selectors: [["rux-icon-maximize"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconMaximize_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconMaximize = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconMaximize);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconMaximize, [{
    type: Component,
    args: [{
      selector: "rux-icon-maximize",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconMeetingRoom = class RuxIconMeetingRoom2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconMeetingRoom.ɵfac = function RuxIconMeetingRoom_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconMeetingRoom)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconMeetingRoom.ɵcmp = ɵɵdefineComponent({
  type: RuxIconMeetingRoom,
  selectors: [["rux-icon-meeting-room"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconMeetingRoom_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconMeetingRoom = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconMeetingRoom);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconMeetingRoom, [{
    type: Component,
    args: [{
      selector: "rux-icon-meeting-room",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconMemory = class RuxIconMemory2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconMemory.ɵfac = function RuxIconMemory_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconMemory)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconMemory.ɵcmp = ɵɵdefineComponent({
  type: RuxIconMemory,
  selectors: [["rux-icon-memory"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconMemory_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconMemory = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconMemory);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconMemory, [{
    type: Component,
    args: [{
      selector: "rux-icon-memory",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconMenu = class RuxIconMenu2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconMenu.ɵfac = function RuxIconMenu_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconMenu)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconMenu.ɵcmp = ɵɵdefineComponent({
  type: RuxIconMenu,
  selectors: [["rux-icon-menu"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconMenu_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconMenu = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconMenu);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconMenu, [{
    type: Component,
    args: [{
      selector: "rux-icon-menu",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconMergeType = class RuxIconMergeType2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconMergeType.ɵfac = function RuxIconMergeType_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconMergeType)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconMergeType.ɵcmp = ɵɵdefineComponent({
  type: RuxIconMergeType,
  selectors: [["rux-icon-merge-type"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconMergeType_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconMergeType = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconMergeType);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconMergeType, [{
    type: Component,
    args: [{
      selector: "rux-icon-merge-type",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconMessage = class RuxIconMessage2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconMessage.ɵfac = function RuxIconMessage_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconMessage)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconMessage.ɵcmp = ɵɵdefineComponent({
  type: RuxIconMessage,
  selectors: [["rux-icon-message"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconMessage_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconMessage = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconMessage);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconMessage, [{
    type: Component,
    args: [{
      selector: "rux-icon-message",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconMic = class RuxIconMic2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconMic.ɵfac = function RuxIconMic_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconMic)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconMic.ɵcmp = ɵɵdefineComponent({
  type: RuxIconMic,
  selectors: [["rux-icon-mic"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconMic_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconMic = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconMic);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconMic, [{
    type: Component,
    args: [{
      selector: "rux-icon-mic",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconMicNone = class RuxIconMicNone2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconMicNone.ɵfac = function RuxIconMicNone_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconMicNone)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconMicNone.ɵcmp = ɵɵdefineComponent({
  type: RuxIconMicNone,
  selectors: [["rux-icon-mic-none"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconMicNone_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconMicNone = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconMicNone);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconMicNone, [{
    type: Component,
    args: [{
      selector: "rux-icon-mic-none",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconMicOff = class RuxIconMicOff2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconMicOff.ɵfac = function RuxIconMicOff_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconMicOff)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconMicOff.ɵcmp = ɵɵdefineComponent({
  type: RuxIconMicOff,
  selectors: [["rux-icon-mic-off"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconMicOff_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconMicOff = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconMicOff);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconMicOff, [{
    type: Component,
    args: [{
      selector: "rux-icon-mic-off",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconMinimize = class RuxIconMinimize2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconMinimize.ɵfac = function RuxIconMinimize_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconMinimize)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconMinimize.ɵcmp = ɵɵdefineComponent({
  type: RuxIconMinimize,
  selectors: [["rux-icon-minimize"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconMinimize_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconMinimize = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconMinimize);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconMinimize, [{
    type: Component,
    args: [{
      selector: "rux-icon-minimize",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconMissedVideoCall = class RuxIconMissedVideoCall2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconMissedVideoCall.ɵfac = function RuxIconMissedVideoCall_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconMissedVideoCall)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconMissedVideoCall.ɵcmp = ɵɵdefineComponent({
  type: RuxIconMissedVideoCall,
  selectors: [["rux-icon-missed-video-call"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconMissedVideoCall_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconMissedVideoCall = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconMissedVideoCall);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconMissedVideoCall, [{
    type: Component,
    args: [{
      selector: "rux-icon-missed-video-call",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconMission = class RuxIconMission2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconMission.ɵfac = function RuxIconMission_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconMission)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconMission.ɵcmp = ɵɵdefineComponent({
  type: RuxIconMission,
  selectors: [["rux-icon-mission"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconMission_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconMission = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconMission);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconMission, [{
    type: Component,
    args: [{
      selector: "rux-icon-mission",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconMms = class RuxIconMms2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconMms.ɵfac = function RuxIconMms_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconMms)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconMms.ɵcmp = ɵɵdefineComponent({
  type: RuxIconMms,
  selectors: [["rux-icon-mms"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconMms_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconMms = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconMms);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconMms, [{
    type: Component,
    args: [{
      selector: "rux-icon-mms",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconMobileFriendly = class RuxIconMobileFriendly2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconMobileFriendly.ɵfac = function RuxIconMobileFriendly_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconMobileFriendly)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconMobileFriendly.ɵcmp = ɵɵdefineComponent({
  type: RuxIconMobileFriendly,
  selectors: [["rux-icon-mobile-friendly"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconMobileFriendly_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconMobileFriendly = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconMobileFriendly);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconMobileFriendly, [{
    type: Component,
    args: [{
      selector: "rux-icon-mobile-friendly",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconMobileOff = class RuxIconMobileOff2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconMobileOff.ɵfac = function RuxIconMobileOff_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconMobileOff)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconMobileOff.ɵcmp = ɵɵdefineComponent({
  type: RuxIconMobileOff,
  selectors: [["rux-icon-mobile-off"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconMobileOff_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconMobileOff = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconMobileOff);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconMobileOff, [{
    type: Component,
    args: [{
      selector: "rux-icon-mobile-off",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconMobileScreenShare = class RuxIconMobileScreenShare2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconMobileScreenShare.ɵfac = function RuxIconMobileScreenShare_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconMobileScreenShare)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconMobileScreenShare.ɵcmp = ɵɵdefineComponent({
  type: RuxIconMobileScreenShare,
  selectors: [["rux-icon-mobile-screen-share"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconMobileScreenShare_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconMobileScreenShare = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconMobileScreenShare);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconMobileScreenShare, [{
    type: Component,
    args: [{
      selector: "rux-icon-mobile-screen-share",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconModeComment = class RuxIconModeComment2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconModeComment.ɵfac = function RuxIconModeComment_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconModeComment)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconModeComment.ɵcmp = ɵɵdefineComponent({
  type: RuxIconModeComment,
  selectors: [["rux-icon-mode-comment"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconModeComment_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconModeComment = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconModeComment);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconModeComment, [{
    type: Component,
    args: [{
      selector: "rux-icon-mode-comment",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconMonetizationOn = class RuxIconMonetizationOn2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconMonetizationOn.ɵfac = function RuxIconMonetizationOn_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconMonetizationOn)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconMonetizationOn.ɵcmp = ɵɵdefineComponent({
  type: RuxIconMonetizationOn,
  selectors: [["rux-icon-monetization-on"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconMonetizationOn_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconMonetizationOn = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconMonetizationOn);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconMonetizationOn, [{
    type: Component,
    args: [{
      selector: "rux-icon-monetization-on",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconMoney = class RuxIconMoney2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconMoney.ɵfac = function RuxIconMoney_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconMoney)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconMoney.ɵcmp = ɵɵdefineComponent({
  type: RuxIconMoney,
  selectors: [["rux-icon-money"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconMoney_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconMoney = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconMoney);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconMoney, [{
    type: Component,
    args: [{
      selector: "rux-icon-money",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconMoneyOff = class RuxIconMoneyOff2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconMoneyOff.ɵfac = function RuxIconMoneyOff_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconMoneyOff)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconMoneyOff.ɵcmp = ɵɵdefineComponent({
  type: RuxIconMoneyOff,
  selectors: [["rux-icon-money-off"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconMoneyOff_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconMoneyOff = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconMoneyOff);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconMoneyOff, [{
    type: Component,
    args: [{
      selector: "rux-icon-money-off",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconMonochromePhotos = class RuxIconMonochromePhotos2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconMonochromePhotos.ɵfac = function RuxIconMonochromePhotos_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconMonochromePhotos)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconMonochromePhotos.ɵcmp = ɵɵdefineComponent({
  type: RuxIconMonochromePhotos,
  selectors: [["rux-icon-monochrome-photos"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconMonochromePhotos_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconMonochromePhotos = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconMonochromePhotos);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconMonochromePhotos, [{
    type: Component,
    args: [{
      selector: "rux-icon-monochrome-photos",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconMood = class RuxIconMood2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconMood.ɵfac = function RuxIconMood_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconMood)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconMood.ɵcmp = ɵɵdefineComponent({
  type: RuxIconMood,
  selectors: [["rux-icon-mood"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconMood_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconMood = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconMood);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconMood, [{
    type: Component,
    args: [{
      selector: "rux-icon-mood",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconMoodBad = class RuxIconMoodBad2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconMoodBad.ɵfac = function RuxIconMoodBad_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconMoodBad)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconMoodBad.ɵcmp = ɵɵdefineComponent({
  type: RuxIconMoodBad,
  selectors: [["rux-icon-mood-bad"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconMoodBad_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconMoodBad = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconMoodBad);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconMoodBad, [{
    type: Component,
    args: [{
      selector: "rux-icon-mood-bad",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconMore = class RuxIconMore2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconMore.ɵfac = function RuxIconMore_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconMore)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconMore.ɵcmp = ɵɵdefineComponent({
  type: RuxIconMore,
  selectors: [["rux-icon-more"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconMore_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconMore = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconMore);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconMore, [{
    type: Component,
    args: [{
      selector: "rux-icon-more",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconMoreHoriz = class RuxIconMoreHoriz2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconMoreHoriz.ɵfac = function RuxIconMoreHoriz_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconMoreHoriz)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconMoreHoriz.ɵcmp = ɵɵdefineComponent({
  type: RuxIconMoreHoriz,
  selectors: [["rux-icon-more-horiz"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconMoreHoriz_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconMoreHoriz = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconMoreHoriz);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconMoreHoriz, [{
    type: Component,
    args: [{
      selector: "rux-icon-more-horiz",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconMoreVert = class RuxIconMoreVert2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconMoreVert.ɵfac = function RuxIconMoreVert_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconMoreVert)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconMoreVert.ɵcmp = ɵɵdefineComponent({
  type: RuxIconMoreVert,
  selectors: [["rux-icon-more-vert"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconMoreVert_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconMoreVert = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconMoreVert);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconMoreVert, [{
    type: Component,
    args: [{
      selector: "rux-icon-more-vert",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconMotorcycle = class RuxIconMotorcycle2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconMotorcycle.ɵfac = function RuxIconMotorcycle_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconMotorcycle)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconMotorcycle.ɵcmp = ɵɵdefineComponent({
  type: RuxIconMotorcycle,
  selectors: [["rux-icon-motorcycle"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconMotorcycle_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconMotorcycle = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconMotorcycle);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconMotorcycle, [{
    type: Component,
    args: [{
      selector: "rux-icon-motorcycle",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconMouse = class RuxIconMouse2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconMouse.ɵfac = function RuxIconMouse_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconMouse)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconMouse.ɵcmp = ɵɵdefineComponent({
  type: RuxIconMouse,
  selectors: [["rux-icon-mouse"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconMouse_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconMouse = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconMouse);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconMouse, [{
    type: Component,
    args: [{
      selector: "rux-icon-mouse",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconMoveToInbox = class RuxIconMoveToInbox2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconMoveToInbox.ɵfac = function RuxIconMoveToInbox_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconMoveToInbox)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconMoveToInbox.ɵcmp = ɵɵdefineComponent({
  type: RuxIconMoveToInbox,
  selectors: [["rux-icon-move-to-inbox"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconMoveToInbox_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconMoveToInbox = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconMoveToInbox);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconMoveToInbox, [{
    type: Component,
    args: [{
      selector: "rux-icon-move-to-inbox",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconMovie = class RuxIconMovie2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconMovie.ɵfac = function RuxIconMovie_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconMovie)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconMovie.ɵcmp = ɵɵdefineComponent({
  type: RuxIconMovie,
  selectors: [["rux-icon-movie"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconMovie_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconMovie = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconMovie);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconMovie, [{
    type: Component,
    args: [{
      selector: "rux-icon-movie",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconMovieCreation = class RuxIconMovieCreation2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconMovieCreation.ɵfac = function RuxIconMovieCreation_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconMovieCreation)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconMovieCreation.ɵcmp = ɵɵdefineComponent({
  type: RuxIconMovieCreation,
  selectors: [["rux-icon-movie-creation"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconMovieCreation_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconMovieCreation = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconMovieCreation);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconMovieCreation, [{
    type: Component,
    args: [{
      selector: "rux-icon-movie-creation",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconMovieFilter = class RuxIconMovieFilter2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconMovieFilter.ɵfac = function RuxIconMovieFilter_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconMovieFilter)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconMovieFilter.ɵcmp = ɵɵdefineComponent({
  type: RuxIconMovieFilter,
  selectors: [["rux-icon-movie-filter"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconMovieFilter_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconMovieFilter = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconMovieFilter);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconMovieFilter, [{
    type: Component,
    args: [{
      selector: "rux-icon-movie-filter",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconMultilineChart = class RuxIconMultilineChart2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconMultilineChart.ɵfac = function RuxIconMultilineChart_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconMultilineChart)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconMultilineChart.ɵcmp = ɵɵdefineComponent({
  type: RuxIconMultilineChart,
  selectors: [["rux-icon-multiline-chart"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconMultilineChart_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconMultilineChart = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconMultilineChart);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconMultilineChart, [{
    type: Component,
    args: [{
      selector: "rux-icon-multiline-chart",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconMusicNote = class RuxIconMusicNote2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconMusicNote.ɵfac = function RuxIconMusicNote_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconMusicNote)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconMusicNote.ɵcmp = ɵɵdefineComponent({
  type: RuxIconMusicNote,
  selectors: [["rux-icon-music-note"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconMusicNote_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconMusicNote = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconMusicNote);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconMusicNote, [{
    type: Component,
    args: [{
      selector: "rux-icon-music-note",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconMusicOff = class RuxIconMusicOff2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconMusicOff.ɵfac = function RuxIconMusicOff_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconMusicOff)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconMusicOff.ɵcmp = ɵɵdefineComponent({
  type: RuxIconMusicOff,
  selectors: [["rux-icon-music-off"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconMusicOff_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconMusicOff = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconMusicOff);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconMusicOff, [{
    type: Component,
    args: [{
      selector: "rux-icon-music-off",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconMusicVideo = class RuxIconMusicVideo2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconMusicVideo.ɵfac = function RuxIconMusicVideo_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconMusicVideo)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconMusicVideo.ɵcmp = ɵɵdefineComponent({
  type: RuxIconMusicVideo,
  selectors: [["rux-icon-music-video"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconMusicVideo_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconMusicVideo = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconMusicVideo);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconMusicVideo, [{
    type: Component,
    args: [{
      selector: "rux-icon-music-video",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconMyLocation = class RuxIconMyLocation2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconMyLocation.ɵfac = function RuxIconMyLocation_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconMyLocation)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconMyLocation.ɵcmp = ɵɵdefineComponent({
  type: RuxIconMyLocation,
  selectors: [["rux-icon-my-location"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconMyLocation_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconMyLocation = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconMyLocation);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconMyLocation, [{
    type: Component,
    args: [{
      selector: "rux-icon-my-location",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconNature = class RuxIconNature2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconNature.ɵfac = function RuxIconNature_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconNature)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconNature.ɵcmp = ɵɵdefineComponent({
  type: RuxIconNature,
  selectors: [["rux-icon-nature"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconNature_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconNature = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconNature);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconNature, [{
    type: Component,
    args: [{
      selector: "rux-icon-nature",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconNaturePeople = class RuxIconNaturePeople2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconNaturePeople.ɵfac = function RuxIconNaturePeople_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconNaturePeople)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconNaturePeople.ɵcmp = ɵɵdefineComponent({
  type: RuxIconNaturePeople,
  selectors: [["rux-icon-nature-people"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconNaturePeople_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconNaturePeople = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconNaturePeople);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconNaturePeople, [{
    type: Component,
    args: [{
      selector: "rux-icon-nature-people",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconNavigateBefore = class RuxIconNavigateBefore2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconNavigateBefore.ɵfac = function RuxIconNavigateBefore_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconNavigateBefore)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconNavigateBefore.ɵcmp = ɵɵdefineComponent({
  type: RuxIconNavigateBefore,
  selectors: [["rux-icon-navigate-before"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconNavigateBefore_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconNavigateBefore = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconNavigateBefore);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconNavigateBefore, [{
    type: Component,
    args: [{
      selector: "rux-icon-navigate-before",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconNavigateNext = class RuxIconNavigateNext2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconNavigateNext.ɵfac = function RuxIconNavigateNext_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconNavigateNext)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconNavigateNext.ɵcmp = ɵɵdefineComponent({
  type: RuxIconNavigateNext,
  selectors: [["rux-icon-navigate-next"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconNavigateNext_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconNavigateNext = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconNavigateNext);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconNavigateNext, [{
    type: Component,
    args: [{
      selector: "rux-icon-navigate-next",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconNavigation = class RuxIconNavigation2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconNavigation.ɵfac = function RuxIconNavigation_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconNavigation)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconNavigation.ɵcmp = ɵɵdefineComponent({
  type: RuxIconNavigation,
  selectors: [["rux-icon-navigation"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconNavigation_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconNavigation = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconNavigation);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconNavigation, [{
    type: Component,
    args: [{
      selector: "rux-icon-navigation",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconNearMe = class RuxIconNearMe2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconNearMe.ɵfac = function RuxIconNearMe_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconNearMe)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconNearMe.ɵcmp = ɵɵdefineComponent({
  type: RuxIconNearMe,
  selectors: [["rux-icon-near-me"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconNearMe_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconNearMe = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconNearMe);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconNearMe, [{
    type: Component,
    args: [{
      selector: "rux-icon-near-me",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconNetcom = class RuxIconNetcom2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconNetcom.ɵfac = function RuxIconNetcom_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconNetcom)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconNetcom.ɵcmp = ɵɵdefineComponent({
  type: RuxIconNetcom,
  selectors: [["rux-icon-netcom"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconNetcom_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconNetcom = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconNetcom);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconNetcom, [{
    type: Component,
    args: [{
      selector: "rux-icon-netcom",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconNetworkCell = class RuxIconNetworkCell2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconNetworkCell.ɵfac = function RuxIconNetworkCell_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconNetworkCell)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconNetworkCell.ɵcmp = ɵɵdefineComponent({
  type: RuxIconNetworkCell,
  selectors: [["rux-icon-network-cell"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconNetworkCell_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconNetworkCell = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconNetworkCell);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconNetworkCell, [{
    type: Component,
    args: [{
      selector: "rux-icon-network-cell",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconNetworkCheck = class RuxIconNetworkCheck2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconNetworkCheck.ɵfac = function RuxIconNetworkCheck_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconNetworkCheck)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconNetworkCheck.ɵcmp = ɵɵdefineComponent({
  type: RuxIconNetworkCheck,
  selectors: [["rux-icon-network-check"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconNetworkCheck_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconNetworkCheck = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconNetworkCheck);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconNetworkCheck, [{
    type: Component,
    args: [{
      selector: "rux-icon-network-check",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconNetworkLocked = class RuxIconNetworkLocked2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconNetworkLocked.ɵfac = function RuxIconNetworkLocked_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconNetworkLocked)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconNetworkLocked.ɵcmp = ɵɵdefineComponent({
  type: RuxIconNetworkLocked,
  selectors: [["rux-icon-network-locked"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconNetworkLocked_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconNetworkLocked = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconNetworkLocked);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconNetworkLocked, [{
    type: Component,
    args: [{
      selector: "rux-icon-network-locked",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconNetworkWifi = class RuxIconNetworkWifi2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconNetworkWifi.ɵfac = function RuxIconNetworkWifi_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconNetworkWifi)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconNetworkWifi.ɵcmp = ɵɵdefineComponent({
  type: RuxIconNetworkWifi,
  selectors: [["rux-icon-network-wifi"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconNetworkWifi_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconNetworkWifi = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconNetworkWifi);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconNetworkWifi, [{
    type: Component,
    args: [{
      selector: "rux-icon-network-wifi",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconNewReleases = class RuxIconNewReleases2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconNewReleases.ɵfac = function RuxIconNewReleases_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconNewReleases)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconNewReleases.ɵcmp = ɵɵdefineComponent({
  type: RuxIconNewReleases,
  selectors: [["rux-icon-new-releases"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconNewReleases_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconNewReleases = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconNewReleases);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconNewReleases, [{
    type: Component,
    args: [{
      selector: "rux-icon-new-releases",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconNextWeek = class RuxIconNextWeek2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconNextWeek.ɵfac = function RuxIconNextWeek_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconNextWeek)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconNextWeek.ɵcmp = ɵɵdefineComponent({
  type: RuxIconNextWeek,
  selectors: [["rux-icon-next-week"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconNextWeek_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconNextWeek = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconNextWeek);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconNextWeek, [{
    type: Component,
    args: [{
      selector: "rux-icon-next-week",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconNfc = class RuxIconNfc2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconNfc.ɵfac = function RuxIconNfc_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconNfc)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconNfc.ɵcmp = ɵɵdefineComponent({
  type: RuxIconNfc,
  selectors: [["rux-icon-nfc"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconNfc_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconNfc = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconNfc);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconNfc, [{
    type: Component,
    args: [{
      selector: "rux-icon-nfc",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconNoEncryption = class RuxIconNoEncryption2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconNoEncryption.ɵfac = function RuxIconNoEncryption_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconNoEncryption)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconNoEncryption.ɵcmp = ɵɵdefineComponent({
  type: RuxIconNoEncryption,
  selectors: [["rux-icon-no-encryption"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconNoEncryption_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconNoEncryption = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconNoEncryption);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconNoEncryption, [{
    type: Component,
    args: [{
      selector: "rux-icon-no-encryption",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconNoMeetingRoom = class RuxIconNoMeetingRoom2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconNoMeetingRoom.ɵfac = function RuxIconNoMeetingRoom_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconNoMeetingRoom)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconNoMeetingRoom.ɵcmp = ɵɵdefineComponent({
  type: RuxIconNoMeetingRoom,
  selectors: [["rux-icon-no-meeting-room"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconNoMeetingRoom_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconNoMeetingRoom = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconNoMeetingRoom);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconNoMeetingRoom, [{
    type: Component,
    args: [{
      selector: "rux-icon-no-meeting-room",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconNoSim = class RuxIconNoSim2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconNoSim.ɵfac = function RuxIconNoSim_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconNoSim)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconNoSim.ɵcmp = ɵɵdefineComponent({
  type: RuxIconNoSim,
  selectors: [["rux-icon-no-sim"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconNoSim_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconNoSim = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconNoSim);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconNoSim, [{
    type: Component,
    args: [{
      selector: "rux-icon-no-sim",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconNotInterested = class RuxIconNotInterested2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconNotInterested.ɵfac = function RuxIconNotInterested_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconNotInterested)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconNotInterested.ɵcmp = ɵɵdefineComponent({
  type: RuxIconNotInterested,
  selectors: [["rux-icon-not-interested"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconNotInterested_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconNotInterested = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconNotInterested);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconNotInterested, [{
    type: Component,
    args: [{
      selector: "rux-icon-not-interested",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconNotListedLocation = class RuxIconNotListedLocation2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconNotListedLocation.ɵfac = function RuxIconNotListedLocation_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconNotListedLocation)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconNotListedLocation.ɵcmp = ɵɵdefineComponent({
  type: RuxIconNotListedLocation,
  selectors: [["rux-icon-not-listed-location"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconNotListedLocation_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconNotListedLocation = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconNotListedLocation);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconNotListedLocation, [{
    type: Component,
    args: [{
      selector: "rux-icon-not-listed-location",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconNote = class RuxIconNote2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconNote.ɵfac = function RuxIconNote_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconNote)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconNote.ɵcmp = ɵɵdefineComponent({
  type: RuxIconNote,
  selectors: [["rux-icon-note"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconNote_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconNote = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconNote);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconNote, [{
    type: Component,
    args: [{
      selector: "rux-icon-note",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconNoteAdd = class RuxIconNoteAdd2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconNoteAdd.ɵfac = function RuxIconNoteAdd_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconNoteAdd)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconNoteAdd.ɵcmp = ɵɵdefineComponent({
  type: RuxIconNoteAdd,
  selectors: [["rux-icon-note-add"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconNoteAdd_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconNoteAdd = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconNoteAdd);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconNoteAdd, [{
    type: Component,
    args: [{
      selector: "rux-icon-note-add",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconNotes = class RuxIconNotes2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconNotes.ɵfac = function RuxIconNotes_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconNotes)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconNotes.ɵcmp = ɵɵdefineComponent({
  type: RuxIconNotes,
  selectors: [["rux-icon-notes"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconNotes_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconNotes = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconNotes);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconNotes, [{
    type: Component,
    args: [{
      selector: "rux-icon-notes",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconNotificationImportant = class RuxIconNotificationImportant2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconNotificationImportant.ɵfac = function RuxIconNotificationImportant_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconNotificationImportant)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconNotificationImportant.ɵcmp = ɵɵdefineComponent({
  type: RuxIconNotificationImportant,
  selectors: [["rux-icon-notification-important"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconNotificationImportant_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconNotificationImportant = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconNotificationImportant);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconNotificationImportant, [{
    type: Component,
    args: [{
      selector: "rux-icon-notification-important",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconNotifications = class RuxIconNotifications2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconNotifications.ɵfac = function RuxIconNotifications_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconNotifications)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconNotifications.ɵcmp = ɵɵdefineComponent({
  type: RuxIconNotifications,
  selectors: [["rux-icon-notifications"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconNotifications_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconNotifications = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconNotifications);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconNotifications, [{
    type: Component,
    args: [{
      selector: "rux-icon-notifications",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconNotificationsActive = class RuxIconNotificationsActive2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconNotificationsActive.ɵfac = function RuxIconNotificationsActive_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconNotificationsActive)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconNotificationsActive.ɵcmp = ɵɵdefineComponent({
  type: RuxIconNotificationsActive,
  selectors: [["rux-icon-notifications-active"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconNotificationsActive_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconNotificationsActive = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconNotificationsActive);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconNotificationsActive, [{
    type: Component,
    args: [{
      selector: "rux-icon-notifications-active",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconNotificationsNone = class RuxIconNotificationsNone2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconNotificationsNone.ɵfac = function RuxIconNotificationsNone_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconNotificationsNone)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconNotificationsNone.ɵcmp = ɵɵdefineComponent({
  type: RuxIconNotificationsNone,
  selectors: [["rux-icon-notifications-none"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconNotificationsNone_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconNotificationsNone = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconNotificationsNone);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconNotificationsNone, [{
    type: Component,
    args: [{
      selector: "rux-icon-notifications-none",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconNotificationsOff = class RuxIconNotificationsOff2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconNotificationsOff.ɵfac = function RuxIconNotificationsOff_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconNotificationsOff)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconNotificationsOff.ɵcmp = ɵɵdefineComponent({
  type: RuxIconNotificationsOff,
  selectors: [["rux-icon-notifications-off"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconNotificationsOff_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconNotificationsOff = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconNotificationsOff);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconNotificationsOff, [{
    type: Component,
    args: [{
      selector: "rux-icon-notifications-off",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconNotificationsPaused = class RuxIconNotificationsPaused2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconNotificationsPaused.ɵfac = function RuxIconNotificationsPaused_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconNotificationsPaused)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconNotificationsPaused.ɵcmp = ɵɵdefineComponent({
  type: RuxIconNotificationsPaused,
  selectors: [["rux-icon-notifications-paused"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconNotificationsPaused_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconNotificationsPaused = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconNotificationsPaused);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconNotificationsPaused, [{
    type: Component,
    args: [{
      selector: "rux-icon-notifications-paused",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconOfflineBolt = class RuxIconOfflineBolt2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconOfflineBolt.ɵfac = function RuxIconOfflineBolt_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconOfflineBolt)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconOfflineBolt.ɵcmp = ɵɵdefineComponent({
  type: RuxIconOfflineBolt,
  selectors: [["rux-icon-offline-bolt"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconOfflineBolt_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconOfflineBolt = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconOfflineBolt);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconOfflineBolt, [{
    type: Component,
    args: [{
      selector: "rux-icon-offline-bolt",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconOfflinePin = class RuxIconOfflinePin2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconOfflinePin.ɵfac = function RuxIconOfflinePin_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconOfflinePin)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconOfflinePin.ɵcmp = ɵɵdefineComponent({
  type: RuxIconOfflinePin,
  selectors: [["rux-icon-offline-pin"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconOfflinePin_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconOfflinePin = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconOfflinePin);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconOfflinePin, [{
    type: Component,
    args: [{
      selector: "rux-icon-offline-pin",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconOndemandVideo = class RuxIconOndemandVideo2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconOndemandVideo.ɵfac = function RuxIconOndemandVideo_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconOndemandVideo)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconOndemandVideo.ɵcmp = ɵɵdefineComponent({
  type: RuxIconOndemandVideo,
  selectors: [["rux-icon-ondemand-video"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconOndemandVideo_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconOndemandVideo = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconOndemandVideo);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconOndemandVideo, [{
    type: Component,
    args: [{
      selector: "rux-icon-ondemand-video",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconOpacity = class RuxIconOpacity2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconOpacity.ɵfac = function RuxIconOpacity_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconOpacity)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconOpacity.ɵcmp = ɵɵdefineComponent({
  type: RuxIconOpacity,
  selectors: [["rux-icon-opacity"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconOpacity_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconOpacity = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconOpacity);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconOpacity, [{
    type: Component,
    args: [{
      selector: "rux-icon-opacity",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconOpenInBrowser = class RuxIconOpenInBrowser2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconOpenInBrowser.ɵfac = function RuxIconOpenInBrowser_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconOpenInBrowser)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconOpenInBrowser.ɵcmp = ɵɵdefineComponent({
  type: RuxIconOpenInBrowser,
  selectors: [["rux-icon-open-in-browser"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconOpenInBrowser_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconOpenInBrowser = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconOpenInBrowser);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconOpenInBrowser, [{
    type: Component,
    args: [{
      selector: "rux-icon-open-in-browser",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconOpenInNew = class RuxIconOpenInNew2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconOpenInNew.ɵfac = function RuxIconOpenInNew_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconOpenInNew)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconOpenInNew.ɵcmp = ɵɵdefineComponent({
  type: RuxIconOpenInNew,
  selectors: [["rux-icon-open-in-new"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconOpenInNew_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconOpenInNew = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconOpenInNew);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconOpenInNew, [{
    type: Component,
    args: [{
      selector: "rux-icon-open-in-new",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconOpenWith = class RuxIconOpenWith2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconOpenWith.ɵfac = function RuxIconOpenWith_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconOpenWith)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconOpenWith.ɵcmp = ɵɵdefineComponent({
  type: RuxIconOpenWith,
  selectors: [["rux-icon-open-with"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconOpenWith_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconOpenWith = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconOpenWith);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconOpenWith, [{
    type: Component,
    args: [{
      selector: "rux-icon-open-with",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconOutlinedFlag = class RuxIconOutlinedFlag2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconOutlinedFlag.ɵfac = function RuxIconOutlinedFlag_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconOutlinedFlag)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconOutlinedFlag.ɵcmp = ɵɵdefineComponent({
  type: RuxIconOutlinedFlag,
  selectors: [["rux-icon-outlined-flag"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconOutlinedFlag_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconOutlinedFlag = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconOutlinedFlag);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconOutlinedFlag, [{
    type: Component,
    args: [{
      selector: "rux-icon-outlined-flag",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPages = class RuxIconPages2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPages.ɵfac = function RuxIconPages_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPages)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPages.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPages,
  selectors: [["rux-icon-pages"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPages_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPages = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPages);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPages, [{
    type: Component,
    args: [{
      selector: "rux-icon-pages",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPageview = class RuxIconPageview2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPageview.ɵfac = function RuxIconPageview_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPageview)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPageview.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPageview,
  selectors: [["rux-icon-pageview"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPageview_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPageview = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPageview);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPageview, [{
    type: Component,
    args: [{
      selector: "rux-icon-pageview",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPalette = class RuxIconPalette2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPalette.ɵfac = function RuxIconPalette_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPalette)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPalette.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPalette,
  selectors: [["rux-icon-palette"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPalette_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPalette = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPalette);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPalette, [{
    type: Component,
    args: [{
      selector: "rux-icon-palette",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPanTool = class RuxIconPanTool2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPanTool.ɵfac = function RuxIconPanTool_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPanTool)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPanTool.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPanTool,
  selectors: [["rux-icon-pan-tool"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPanTool_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPanTool = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPanTool);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPanTool, [{
    type: Component,
    args: [{
      selector: "rux-icon-pan-tool",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPanorama = class RuxIconPanorama2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPanorama.ɵfac = function RuxIconPanorama_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPanorama)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPanorama.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPanorama,
  selectors: [["rux-icon-panorama"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPanorama_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPanorama = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPanorama);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPanorama, [{
    type: Component,
    args: [{
      selector: "rux-icon-panorama",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPanoramaFishEye = class RuxIconPanoramaFishEye2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPanoramaFishEye.ɵfac = function RuxIconPanoramaFishEye_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPanoramaFishEye)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPanoramaFishEye.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPanoramaFishEye,
  selectors: [["rux-icon-panorama-fish-eye"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPanoramaFishEye_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPanoramaFishEye = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPanoramaFishEye);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPanoramaFishEye, [{
    type: Component,
    args: [{
      selector: "rux-icon-panorama-fish-eye",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPanoramaHorizontal = class RuxIconPanoramaHorizontal2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPanoramaHorizontal.ɵfac = function RuxIconPanoramaHorizontal_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPanoramaHorizontal)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPanoramaHorizontal.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPanoramaHorizontal,
  selectors: [["rux-icon-panorama-horizontal"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPanoramaHorizontal_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPanoramaHorizontal = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPanoramaHorizontal);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPanoramaHorizontal, [{
    type: Component,
    args: [{
      selector: "rux-icon-panorama-horizontal",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPanoramaVertical = class RuxIconPanoramaVertical2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPanoramaVertical.ɵfac = function RuxIconPanoramaVertical_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPanoramaVertical)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPanoramaVertical.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPanoramaVertical,
  selectors: [["rux-icon-panorama-vertical"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPanoramaVertical_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPanoramaVertical = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPanoramaVertical);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPanoramaVertical, [{
    type: Component,
    args: [{
      selector: "rux-icon-panorama-vertical",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPanoramaWideAngle = class RuxIconPanoramaWideAngle2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPanoramaWideAngle.ɵfac = function RuxIconPanoramaWideAngle_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPanoramaWideAngle)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPanoramaWideAngle.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPanoramaWideAngle,
  selectors: [["rux-icon-panorama-wide-angle"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPanoramaWideAngle_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPanoramaWideAngle = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPanoramaWideAngle);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPanoramaWideAngle, [{
    type: Component,
    args: [{
      selector: "rux-icon-panorama-wide-angle",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPartyMode = class RuxIconPartyMode2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPartyMode.ɵfac = function RuxIconPartyMode_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPartyMode)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPartyMode.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPartyMode,
  selectors: [["rux-icon-party-mode"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPartyMode_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPartyMode = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPartyMode);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPartyMode, [{
    type: Component,
    args: [{
      selector: "rux-icon-party-mode",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPause = class RuxIconPause2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPause.ɵfac = function RuxIconPause_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPause)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPause.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPause,
  selectors: [["rux-icon-pause"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPause_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPause = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPause);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPause, [{
    type: Component,
    args: [{
      selector: "rux-icon-pause",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPauseCircleFilled = class RuxIconPauseCircleFilled2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPauseCircleFilled.ɵfac = function RuxIconPauseCircleFilled_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPauseCircleFilled)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPauseCircleFilled.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPauseCircleFilled,
  selectors: [["rux-icon-pause-circle-filled"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPauseCircleFilled_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPauseCircleFilled = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPauseCircleFilled);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPauseCircleFilled, [{
    type: Component,
    args: [{
      selector: "rux-icon-pause-circle-filled",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPauseCircleOutline = class RuxIconPauseCircleOutline2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPauseCircleOutline.ɵfac = function RuxIconPauseCircleOutline_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPauseCircleOutline)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPauseCircleOutline.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPauseCircleOutline,
  selectors: [["rux-icon-pause-circle-outline"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPauseCircleOutline_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPauseCircleOutline = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPauseCircleOutline);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPauseCircleOutline, [{
    type: Component,
    args: [{
      selector: "rux-icon-pause-circle-outline",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPausePresentation = class RuxIconPausePresentation2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPausePresentation.ɵfac = function RuxIconPausePresentation_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPausePresentation)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPausePresentation.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPausePresentation,
  selectors: [["rux-icon-pause-presentation"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPausePresentation_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPausePresentation = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPausePresentation);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPausePresentation, [{
    type: Component,
    args: [{
      selector: "rux-icon-pause-presentation",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPayload = class RuxIconPayload2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPayload.ɵfac = function RuxIconPayload_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPayload)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPayload.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPayload,
  selectors: [["rux-icon-payload"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPayload_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPayload = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPayload);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPayload, [{
    type: Component,
    args: [{
      selector: "rux-icon-payload",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPayment = class RuxIconPayment2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPayment.ɵfac = function RuxIconPayment_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPayment)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPayment.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPayment,
  selectors: [["rux-icon-payment"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPayment_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPayment = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPayment);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPayment, [{
    type: Component,
    args: [{
      selector: "rux-icon-payment",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPeopleOutline = class RuxIconPeopleOutline2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPeopleOutline.ɵfac = function RuxIconPeopleOutline_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPeopleOutline)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPeopleOutline.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPeopleOutline,
  selectors: [["rux-icon-people-outline"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPeopleOutline_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPeopleOutline = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPeopleOutline);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPeopleOutline, [{
    type: Component,
    args: [{
      selector: "rux-icon-people-outline",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPermCameraMic = class RuxIconPermCameraMic2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPermCameraMic.ɵfac = function RuxIconPermCameraMic_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPermCameraMic)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPermCameraMic.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPermCameraMic,
  selectors: [["rux-icon-perm-camera-mic"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPermCameraMic_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPermCameraMic = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPermCameraMic);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPermCameraMic, [{
    type: Component,
    args: [{
      selector: "rux-icon-perm-camera-mic",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPermContactCalendar = class RuxIconPermContactCalendar2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPermContactCalendar.ɵfac = function RuxIconPermContactCalendar_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPermContactCalendar)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPermContactCalendar.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPermContactCalendar,
  selectors: [["rux-icon-perm-contact-calendar"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPermContactCalendar_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPermContactCalendar = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPermContactCalendar);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPermContactCalendar, [{
    type: Component,
    args: [{
      selector: "rux-icon-perm-contact-calendar",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPermDataSetting = class RuxIconPermDataSetting2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPermDataSetting.ɵfac = function RuxIconPermDataSetting_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPermDataSetting)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPermDataSetting.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPermDataSetting,
  selectors: [["rux-icon-perm-data-setting"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPermDataSetting_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPermDataSetting = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPermDataSetting);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPermDataSetting, [{
    type: Component,
    args: [{
      selector: "rux-icon-perm-data-setting",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPermDeviceInformation = class RuxIconPermDeviceInformation2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPermDeviceInformation.ɵfac = function RuxIconPermDeviceInformation_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPermDeviceInformation)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPermDeviceInformation.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPermDeviceInformation,
  selectors: [["rux-icon-perm-device-information"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPermDeviceInformation_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPermDeviceInformation = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPermDeviceInformation);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPermDeviceInformation, [{
    type: Component,
    args: [{
      selector: "rux-icon-perm-device-information",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPermIdentity = class RuxIconPermIdentity2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPermIdentity.ɵfac = function RuxIconPermIdentity_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPermIdentity)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPermIdentity.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPermIdentity,
  selectors: [["rux-icon-perm-identity"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPermIdentity_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPermIdentity = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPermIdentity);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPermIdentity, [{
    type: Component,
    args: [{
      selector: "rux-icon-perm-identity",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPermMedia = class RuxIconPermMedia2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPermMedia.ɵfac = function RuxIconPermMedia_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPermMedia)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPermMedia.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPermMedia,
  selectors: [["rux-icon-perm-media"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPermMedia_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPermMedia = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPermMedia);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPermMedia, [{
    type: Component,
    args: [{
      selector: "rux-icon-perm-media",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPermPhoneMsg = class RuxIconPermPhoneMsg2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPermPhoneMsg.ɵfac = function RuxIconPermPhoneMsg_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPermPhoneMsg)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPermPhoneMsg.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPermPhoneMsg,
  selectors: [["rux-icon-perm-phone-msg"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPermPhoneMsg_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPermPhoneMsg = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPermPhoneMsg);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPermPhoneMsg, [{
    type: Component,
    args: [{
      selector: "rux-icon-perm-phone-msg",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPermScanWifi = class RuxIconPermScanWifi2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPermScanWifi.ɵfac = function RuxIconPermScanWifi_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPermScanWifi)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPermScanWifi.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPermScanWifi,
  selectors: [["rux-icon-perm-scan-wifi"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPermScanWifi_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPermScanWifi = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPermScanWifi);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPermScanWifi, [{
    type: Component,
    args: [{
      selector: "rux-icon-perm-scan-wifi",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPerson = class RuxIconPerson2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPerson.ɵfac = function RuxIconPerson_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPerson)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPerson.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPerson,
  selectors: [["rux-icon-person"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPerson_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPerson = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPerson);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPerson, [{
    type: Component,
    args: [{
      selector: "rux-icon-person",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPersonAdd = class RuxIconPersonAdd2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPersonAdd.ɵfac = function RuxIconPersonAdd_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPersonAdd)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPersonAdd.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPersonAdd,
  selectors: [["rux-icon-person-add"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPersonAdd_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPersonAdd = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPersonAdd);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPersonAdd, [{
    type: Component,
    args: [{
      selector: "rux-icon-person-add",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPersonAddDisabled = class RuxIconPersonAddDisabled2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPersonAddDisabled.ɵfac = function RuxIconPersonAddDisabled_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPersonAddDisabled)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPersonAddDisabled.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPersonAddDisabled,
  selectors: [["rux-icon-person-add-disabled"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPersonAddDisabled_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPersonAddDisabled = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPersonAddDisabled);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPersonAddDisabled, [{
    type: Component,
    args: [{
      selector: "rux-icon-person-add-disabled",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPersonOutline = class RuxIconPersonOutline2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPersonOutline.ɵfac = function RuxIconPersonOutline_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPersonOutline)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPersonOutline.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPersonOutline,
  selectors: [["rux-icon-person-outline"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPersonOutline_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPersonOutline = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPersonOutline);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPersonOutline, [{
    type: Component,
    args: [{
      selector: "rux-icon-person-outline",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPersonPin = class RuxIconPersonPin2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPersonPin.ɵfac = function RuxIconPersonPin_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPersonPin)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPersonPin.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPersonPin,
  selectors: [["rux-icon-person-pin"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPersonPin_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPersonPin = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPersonPin);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPersonPin, [{
    type: Component,
    args: [{
      selector: "rux-icon-person-pin",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPersonPinCircle = class RuxIconPersonPinCircle2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPersonPinCircle.ɵfac = function RuxIconPersonPinCircle_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPersonPinCircle)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPersonPinCircle.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPersonPinCircle,
  selectors: [["rux-icon-person-pin-circle"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPersonPinCircle_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPersonPinCircle = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPersonPinCircle);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPersonPinCircle, [{
    type: Component,
    args: [{
      selector: "rux-icon-person-pin-circle",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPersonalVideo = class RuxIconPersonalVideo2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPersonalVideo.ɵfac = function RuxIconPersonalVideo_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPersonalVideo)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPersonalVideo.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPersonalVideo,
  selectors: [["rux-icon-personal-video"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPersonalVideo_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPersonalVideo = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPersonalVideo);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPersonalVideo, [{
    type: Component,
    args: [{
      selector: "rux-icon-personal-video",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPets = class RuxIconPets2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPets.ɵfac = function RuxIconPets_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPets)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPets.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPets,
  selectors: [["rux-icon-pets"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPets_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPets = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPets);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPets, [{
    type: Component,
    args: [{
      selector: "rux-icon-pets",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPhone = class RuxIconPhone2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPhone.ɵfac = function RuxIconPhone_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPhone)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPhone.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPhone,
  selectors: [["rux-icon-phone"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPhone_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPhone = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPhone);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPhone, [{
    type: Component,
    args: [{
      selector: "rux-icon-phone",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPhoneAndroid = class RuxIconPhoneAndroid2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPhoneAndroid.ɵfac = function RuxIconPhoneAndroid_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPhoneAndroid)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPhoneAndroid.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPhoneAndroid,
  selectors: [["rux-icon-phone-android"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPhoneAndroid_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPhoneAndroid = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPhoneAndroid);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPhoneAndroid, [{
    type: Component,
    args: [{
      selector: "rux-icon-phone-android",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPhoneBluetoothSpeaker = class RuxIconPhoneBluetoothSpeaker2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPhoneBluetoothSpeaker.ɵfac = function RuxIconPhoneBluetoothSpeaker_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPhoneBluetoothSpeaker)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPhoneBluetoothSpeaker.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPhoneBluetoothSpeaker,
  selectors: [["rux-icon-phone-bluetooth-speaker"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPhoneBluetoothSpeaker_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPhoneBluetoothSpeaker = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPhoneBluetoothSpeaker);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPhoneBluetoothSpeaker, [{
    type: Component,
    args: [{
      selector: "rux-icon-phone-bluetooth-speaker",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPhoneCallback = class RuxIconPhoneCallback2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPhoneCallback.ɵfac = function RuxIconPhoneCallback_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPhoneCallback)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPhoneCallback.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPhoneCallback,
  selectors: [["rux-icon-phone-callback"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPhoneCallback_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPhoneCallback = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPhoneCallback);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPhoneCallback, [{
    type: Component,
    args: [{
      selector: "rux-icon-phone-callback",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPhoneForwarded = class RuxIconPhoneForwarded2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPhoneForwarded.ɵfac = function RuxIconPhoneForwarded_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPhoneForwarded)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPhoneForwarded.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPhoneForwarded,
  selectors: [["rux-icon-phone-forwarded"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPhoneForwarded_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPhoneForwarded = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPhoneForwarded);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPhoneForwarded, [{
    type: Component,
    args: [{
      selector: "rux-icon-phone-forwarded",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPhoneInTalk = class RuxIconPhoneInTalk2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPhoneInTalk.ɵfac = function RuxIconPhoneInTalk_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPhoneInTalk)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPhoneInTalk.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPhoneInTalk,
  selectors: [["rux-icon-phone-in-talk"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPhoneInTalk_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPhoneInTalk = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPhoneInTalk);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPhoneInTalk, [{
    type: Component,
    args: [{
      selector: "rux-icon-phone-in-talk",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPhoneIphone = class RuxIconPhoneIphone2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPhoneIphone.ɵfac = function RuxIconPhoneIphone_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPhoneIphone)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPhoneIphone.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPhoneIphone,
  selectors: [["rux-icon-phone-iphone"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPhoneIphone_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPhoneIphone = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPhoneIphone);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPhoneIphone, [{
    type: Component,
    args: [{
      selector: "rux-icon-phone-iphone",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPhoneLocked = class RuxIconPhoneLocked2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPhoneLocked.ɵfac = function RuxIconPhoneLocked_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPhoneLocked)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPhoneLocked.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPhoneLocked,
  selectors: [["rux-icon-phone-locked"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPhoneLocked_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPhoneLocked = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPhoneLocked);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPhoneLocked, [{
    type: Component,
    args: [{
      selector: "rux-icon-phone-locked",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPhoneMissed = class RuxIconPhoneMissed2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPhoneMissed.ɵfac = function RuxIconPhoneMissed_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPhoneMissed)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPhoneMissed.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPhoneMissed,
  selectors: [["rux-icon-phone-missed"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPhoneMissed_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPhoneMissed = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPhoneMissed);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPhoneMissed, [{
    type: Component,
    args: [{
      selector: "rux-icon-phone-missed",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPhonePaused = class RuxIconPhonePaused2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPhonePaused.ɵfac = function RuxIconPhonePaused_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPhonePaused)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPhonePaused.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPhonePaused,
  selectors: [["rux-icon-phone-paused"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPhonePaused_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPhonePaused = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPhonePaused);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPhonePaused, [{
    type: Component,
    args: [{
      selector: "rux-icon-phone-paused",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPhonelink = class RuxIconPhonelink2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPhonelink.ɵfac = function RuxIconPhonelink_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPhonelink)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPhonelink.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPhonelink,
  selectors: [["rux-icon-phonelink"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPhonelink_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPhonelink = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPhonelink);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPhonelink, [{
    type: Component,
    args: [{
      selector: "rux-icon-phonelink",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPhonelinkErase = class RuxIconPhonelinkErase2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPhonelinkErase.ɵfac = function RuxIconPhonelinkErase_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPhonelinkErase)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPhonelinkErase.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPhonelinkErase,
  selectors: [["rux-icon-phonelink-erase"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPhonelinkErase_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPhonelinkErase = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPhonelinkErase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPhonelinkErase, [{
    type: Component,
    args: [{
      selector: "rux-icon-phonelink-erase",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPhonelinkLock = class RuxIconPhonelinkLock2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPhonelinkLock.ɵfac = function RuxIconPhonelinkLock_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPhonelinkLock)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPhonelinkLock.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPhonelinkLock,
  selectors: [["rux-icon-phonelink-lock"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPhonelinkLock_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPhonelinkLock = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPhonelinkLock);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPhonelinkLock, [{
    type: Component,
    args: [{
      selector: "rux-icon-phonelink-lock",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPhonelinkOff = class RuxIconPhonelinkOff2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPhonelinkOff.ɵfac = function RuxIconPhonelinkOff_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPhonelinkOff)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPhonelinkOff.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPhonelinkOff,
  selectors: [["rux-icon-phonelink-off"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPhonelinkOff_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPhonelinkOff = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPhonelinkOff);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPhonelinkOff, [{
    type: Component,
    args: [{
      selector: "rux-icon-phonelink-off",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPhonelinkRing = class RuxIconPhonelinkRing2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPhonelinkRing.ɵfac = function RuxIconPhonelinkRing_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPhonelinkRing)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPhonelinkRing.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPhonelinkRing,
  selectors: [["rux-icon-phonelink-ring"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPhonelinkRing_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPhonelinkRing = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPhonelinkRing);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPhonelinkRing, [{
    type: Component,
    args: [{
      selector: "rux-icon-phonelink-ring",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPhonelinkSetup = class RuxIconPhonelinkSetup2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPhonelinkSetup.ɵfac = function RuxIconPhonelinkSetup_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPhonelinkSetup)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPhonelinkSetup.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPhonelinkSetup,
  selectors: [["rux-icon-phonelink-setup"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPhonelinkSetup_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPhonelinkSetup = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPhonelinkSetup);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPhonelinkSetup, [{
    type: Component,
    args: [{
      selector: "rux-icon-phonelink-setup",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPhoto = class RuxIconPhoto2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPhoto.ɵfac = function RuxIconPhoto_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPhoto)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPhoto.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPhoto,
  selectors: [["rux-icon-photo"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPhoto_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPhoto = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPhoto);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPhoto, [{
    type: Component,
    args: [{
      selector: "rux-icon-photo",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPhotoAlbum = class RuxIconPhotoAlbum2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPhotoAlbum.ɵfac = function RuxIconPhotoAlbum_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPhotoAlbum)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPhotoAlbum.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPhotoAlbum,
  selectors: [["rux-icon-photo-album"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPhotoAlbum_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPhotoAlbum = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPhotoAlbum);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPhotoAlbum, [{
    type: Component,
    args: [{
      selector: "rux-icon-photo-album",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPhotoCamera = class RuxIconPhotoCamera2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPhotoCamera.ɵfac = function RuxIconPhotoCamera_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPhotoCamera)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPhotoCamera.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPhotoCamera,
  selectors: [["rux-icon-photo-camera"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPhotoCamera_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPhotoCamera = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPhotoCamera);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPhotoCamera, [{
    type: Component,
    args: [{
      selector: "rux-icon-photo-camera",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPhotoFilter = class RuxIconPhotoFilter2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPhotoFilter.ɵfac = function RuxIconPhotoFilter_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPhotoFilter)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPhotoFilter.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPhotoFilter,
  selectors: [["rux-icon-photo-filter"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPhotoFilter_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPhotoFilter = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPhotoFilter);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPhotoFilter, [{
    type: Component,
    args: [{
      selector: "rux-icon-photo-filter",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPhotoLibrary = class RuxIconPhotoLibrary2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPhotoLibrary.ɵfac = function RuxIconPhotoLibrary_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPhotoLibrary)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPhotoLibrary.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPhotoLibrary,
  selectors: [["rux-icon-photo-library"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPhotoLibrary_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPhotoLibrary = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPhotoLibrary);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPhotoLibrary, [{
    type: Component,
    args: [{
      selector: "rux-icon-photo-library",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPhotoSizeSelectActual = class RuxIconPhotoSizeSelectActual2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPhotoSizeSelectActual.ɵfac = function RuxIconPhotoSizeSelectActual_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPhotoSizeSelectActual)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPhotoSizeSelectActual.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPhotoSizeSelectActual,
  selectors: [["rux-icon-photo-size-select-actual"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPhotoSizeSelectActual_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPhotoSizeSelectActual = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPhotoSizeSelectActual);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPhotoSizeSelectActual, [{
    type: Component,
    args: [{
      selector: "rux-icon-photo-size-select-actual",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPhotoSizeSelectLarge = class RuxIconPhotoSizeSelectLarge2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPhotoSizeSelectLarge.ɵfac = function RuxIconPhotoSizeSelectLarge_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPhotoSizeSelectLarge)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPhotoSizeSelectLarge.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPhotoSizeSelectLarge,
  selectors: [["rux-icon-photo-size-select-large"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPhotoSizeSelectLarge_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPhotoSizeSelectLarge = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPhotoSizeSelectLarge);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPhotoSizeSelectLarge, [{
    type: Component,
    args: [{
      selector: "rux-icon-photo-size-select-large",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPhotoSizeSelectSmall = class RuxIconPhotoSizeSelectSmall2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPhotoSizeSelectSmall.ɵfac = function RuxIconPhotoSizeSelectSmall_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPhotoSizeSelectSmall)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPhotoSizeSelectSmall.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPhotoSizeSelectSmall,
  selectors: [["rux-icon-photo-size-select-small"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPhotoSizeSelectSmall_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPhotoSizeSelectSmall = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPhotoSizeSelectSmall);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPhotoSizeSelectSmall, [{
    type: Component,
    args: [{
      selector: "rux-icon-photo-size-select-small",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPictureAsPdf = class RuxIconPictureAsPdf2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPictureAsPdf.ɵfac = function RuxIconPictureAsPdf_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPictureAsPdf)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPictureAsPdf.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPictureAsPdf,
  selectors: [["rux-icon-picture-as-pdf"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPictureAsPdf_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPictureAsPdf = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPictureAsPdf);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPictureAsPdf, [{
    type: Component,
    args: [{
      selector: "rux-icon-picture-as-pdf",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPictureInPicture = class RuxIconPictureInPicture2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPictureInPicture.ɵfac = function RuxIconPictureInPicture_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPictureInPicture)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPictureInPicture.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPictureInPicture,
  selectors: [["rux-icon-picture-in-picture"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPictureInPicture_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPictureInPicture = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPictureInPicture);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPictureInPicture, [{
    type: Component,
    args: [{
      selector: "rux-icon-picture-in-picture",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPictureInPictureAlt = class RuxIconPictureInPictureAlt2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPictureInPictureAlt.ɵfac = function RuxIconPictureInPictureAlt_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPictureInPictureAlt)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPictureInPictureAlt.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPictureInPictureAlt,
  selectors: [["rux-icon-picture-in-picture-alt"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPictureInPictureAlt_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPictureInPictureAlt = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPictureInPictureAlt);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPictureInPictureAlt, [{
    type: Component,
    args: [{
      selector: "rux-icon-picture-in-picture-alt",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPieChart = class RuxIconPieChart2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPieChart.ɵfac = function RuxIconPieChart_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPieChart)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPieChart.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPieChart,
  selectors: [["rux-icon-pie-chart"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPieChart_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPieChart = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPieChart);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPieChart, [{
    type: Component,
    args: [{
      selector: "rux-icon-pie-chart",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPinDrop = class RuxIconPinDrop2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPinDrop.ɵfac = function RuxIconPinDrop_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPinDrop)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPinDrop.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPinDrop,
  selectors: [["rux-icon-pin-drop"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPinDrop_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPinDrop = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPinDrop);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPinDrop, [{
    type: Component,
    args: [{
      selector: "rux-icon-pin-drop",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPlace = class RuxIconPlace2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPlace.ɵfac = function RuxIconPlace_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPlace)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPlace.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPlace,
  selectors: [["rux-icon-place"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPlace_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPlace = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPlace);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPlace, [{
    type: Component,
    args: [{
      selector: "rux-icon-place",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPlayArrow = class RuxIconPlayArrow2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPlayArrow.ɵfac = function RuxIconPlayArrow_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPlayArrow)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPlayArrow.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPlayArrow,
  selectors: [["rux-icon-play-arrow"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPlayArrow_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPlayArrow = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPlayArrow);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPlayArrow, [{
    type: Component,
    args: [{
      selector: "rux-icon-play-arrow",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPlayCircleFilled = class RuxIconPlayCircleFilled2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPlayCircleFilled.ɵfac = function RuxIconPlayCircleFilled_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPlayCircleFilled)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPlayCircleFilled.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPlayCircleFilled,
  selectors: [["rux-icon-play-circle-filled"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPlayCircleFilled_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPlayCircleFilled = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPlayCircleFilled);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPlayCircleFilled, [{
    type: Component,
    args: [{
      selector: "rux-icon-play-circle-filled",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPlayCircleFilledWhite = class RuxIconPlayCircleFilledWhite2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPlayCircleFilledWhite.ɵfac = function RuxIconPlayCircleFilledWhite_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPlayCircleFilledWhite)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPlayCircleFilledWhite.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPlayCircleFilledWhite,
  selectors: [["rux-icon-play-circle-filled-white"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPlayCircleFilledWhite_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPlayCircleFilledWhite = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPlayCircleFilledWhite);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPlayCircleFilledWhite, [{
    type: Component,
    args: [{
      selector: "rux-icon-play-circle-filled-white",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPlayCircleOutline = class RuxIconPlayCircleOutline2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPlayCircleOutline.ɵfac = function RuxIconPlayCircleOutline_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPlayCircleOutline)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPlayCircleOutline.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPlayCircleOutline,
  selectors: [["rux-icon-play-circle-outline"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPlayCircleOutline_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPlayCircleOutline = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPlayCircleOutline);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPlayCircleOutline, [{
    type: Component,
    args: [{
      selector: "rux-icon-play-circle-outline",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPlayForWork = class RuxIconPlayForWork2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPlayForWork.ɵfac = function RuxIconPlayForWork_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPlayForWork)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPlayForWork.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPlayForWork,
  selectors: [["rux-icon-play-for-work"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPlayForWork_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPlayForWork = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPlayForWork);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPlayForWork, [{
    type: Component,
    args: [{
      selector: "rux-icon-play-for-work",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPlaylistAdd = class RuxIconPlaylistAdd2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPlaylistAdd.ɵfac = function RuxIconPlaylistAdd_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPlaylistAdd)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPlaylistAdd.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPlaylistAdd,
  selectors: [["rux-icon-playlist-add"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPlaylistAdd_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPlaylistAdd = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPlaylistAdd);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPlaylistAdd, [{
    type: Component,
    args: [{
      selector: "rux-icon-playlist-add",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPlaylistAddCheck = class RuxIconPlaylistAddCheck2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPlaylistAddCheck.ɵfac = function RuxIconPlaylistAddCheck_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPlaylistAddCheck)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPlaylistAddCheck.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPlaylistAddCheck,
  selectors: [["rux-icon-playlist-add-check"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPlaylistAddCheck_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPlaylistAddCheck = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPlaylistAddCheck);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPlaylistAddCheck, [{
    type: Component,
    args: [{
      selector: "rux-icon-playlist-add-check",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPlaylistPlay = class RuxIconPlaylistPlay2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPlaylistPlay.ɵfac = function RuxIconPlaylistPlay_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPlaylistPlay)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPlaylistPlay.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPlaylistPlay,
  selectors: [["rux-icon-playlist-play"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPlaylistPlay_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPlaylistPlay = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPlaylistPlay);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPlaylistPlay, [{
    type: Component,
    args: [{
      selector: "rux-icon-playlist-play",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPlusOne = class RuxIconPlusOne2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPlusOne.ɵfac = function RuxIconPlusOne_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPlusOne)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPlusOne.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPlusOne,
  selectors: [["rux-icon-plus-one"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPlusOne_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPlusOne = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPlusOne);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPlusOne, [{
    type: Component,
    args: [{
      selector: "rux-icon-plus-one",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPoll = class RuxIconPoll2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPoll.ɵfac = function RuxIconPoll_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPoll)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPoll.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPoll,
  selectors: [["rux-icon-poll"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPoll_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPoll = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPoll);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPoll, [{
    type: Component,
    args: [{
      selector: "rux-icon-poll",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPool = class RuxIconPool2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPool.ɵfac = function RuxIconPool_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPool)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPool.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPool,
  selectors: [["rux-icon-pool"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPool_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPool = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPool);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPool, [{
    type: Component,
    args: [{
      selector: "rux-icon-pool",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPortableWifiOff = class RuxIconPortableWifiOff2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPortableWifiOff.ɵfac = function RuxIconPortableWifiOff_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPortableWifiOff)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPortableWifiOff.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPortableWifiOff,
  selectors: [["rux-icon-portable-wifi-off"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPortableWifiOff_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPortableWifiOff = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPortableWifiOff);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPortableWifiOff, [{
    type: Component,
    args: [{
      selector: "rux-icon-portable-wifi-off",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPortrait = class RuxIconPortrait2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPortrait.ɵfac = function RuxIconPortrait_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPortrait)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPortrait.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPortrait,
  selectors: [["rux-icon-portrait"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPortrait_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPortrait = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPortrait);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPortrait, [{
    type: Component,
    args: [{
      selector: "rux-icon-portrait",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPower = class RuxIconPower2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPower.ɵfac = function RuxIconPower_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPower)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPower.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPower,
  selectors: [["rux-icon-power"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPower_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPower = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPower);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPower, [{
    type: Component,
    args: [{
      selector: "rux-icon-power",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPowerInput = class RuxIconPowerInput2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPowerInput.ɵfac = function RuxIconPowerInput_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPowerInput)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPowerInput.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPowerInput,
  selectors: [["rux-icon-power-input"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPowerInput_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPowerInput = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPowerInput);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPowerInput, [{
    type: Component,
    args: [{
      selector: "rux-icon-power-input",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPowerOff = class RuxIconPowerOff2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPowerOff.ɵfac = function RuxIconPowerOff_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPowerOff)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPowerOff.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPowerOff,
  selectors: [["rux-icon-power-off"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPowerOff_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPowerOff = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPowerOff);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPowerOff, [{
    type: Component,
    args: [{
      selector: "rux-icon-power-off",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPowerSettingsNew = class RuxIconPowerSettingsNew2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPowerSettingsNew.ɵfac = function RuxIconPowerSettingsNew_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPowerSettingsNew)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPowerSettingsNew.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPowerSettingsNew,
  selectors: [["rux-icon-power-settings-new"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPowerSettingsNew_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPowerSettingsNew = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPowerSettingsNew);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPowerSettingsNew, [{
    type: Component,
    args: [{
      selector: "rux-icon-power-settings-new",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPregnantWoman = class RuxIconPregnantWoman2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPregnantWoman.ɵfac = function RuxIconPregnantWoman_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPregnantWoman)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPregnantWoman.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPregnantWoman,
  selectors: [["rux-icon-pregnant-woman"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPregnantWoman_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPregnantWoman = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPregnantWoman);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPregnantWoman, [{
    type: Component,
    args: [{
      selector: "rux-icon-pregnant-woman",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPresentToAll = class RuxIconPresentToAll2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPresentToAll.ɵfac = function RuxIconPresentToAll_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPresentToAll)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPresentToAll.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPresentToAll,
  selectors: [["rux-icon-present-to-all"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPresentToAll_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPresentToAll = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPresentToAll);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPresentToAll, [{
    type: Component,
    args: [{
      selector: "rux-icon-present-to-all",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPrint = class RuxIconPrint2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPrint.ɵfac = function RuxIconPrint_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPrint)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPrint.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPrint,
  selectors: [["rux-icon-print"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPrint_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPrint = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPrint);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPrint, [{
    type: Component,
    args: [{
      selector: "rux-icon-print",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPrintDisabled = class RuxIconPrintDisabled2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPrintDisabled.ɵfac = function RuxIconPrintDisabled_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPrintDisabled)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPrintDisabled.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPrintDisabled,
  selectors: [["rux-icon-print-disabled"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPrintDisabled_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPrintDisabled = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPrintDisabled);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPrintDisabled, [{
    type: Component,
    args: [{
      selector: "rux-icon-print-disabled",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPriorityHigh = class RuxIconPriorityHigh2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPriorityHigh.ɵfac = function RuxIconPriorityHigh_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPriorityHigh)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPriorityHigh.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPriorityHigh,
  selectors: [["rux-icon-priority-high"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPriorityHigh_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPriorityHigh = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPriorityHigh);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPriorityHigh, [{
    type: Component,
    args: [{
      selector: "rux-icon-priority-high",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconProcessor = class RuxIconProcessor2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconProcessor.ɵfac = function RuxIconProcessor_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconProcessor)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconProcessor.ɵcmp = ɵɵdefineComponent({
  type: RuxIconProcessor,
  selectors: [["rux-icon-processor"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconProcessor_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconProcessor = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconProcessor);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconProcessor, [{
    type: Component,
    args: [{
      selector: "rux-icon-processor",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconProcessorAlt = class RuxIconProcessorAlt2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconProcessorAlt.ɵfac = function RuxIconProcessorAlt_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconProcessorAlt)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconProcessorAlt.ɵcmp = ɵɵdefineComponent({
  type: RuxIconProcessorAlt,
  selectors: [["rux-icon-processor-alt"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconProcessorAlt_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconProcessorAlt = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconProcessorAlt);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconProcessorAlt, [{
    type: Component,
    args: [{
      selector: "rux-icon-processor-alt",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPropulsionPower = class RuxIconPropulsionPower2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPropulsionPower.ɵfac = function RuxIconPropulsionPower_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPropulsionPower)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPropulsionPower.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPropulsionPower,
  selectors: [["rux-icon-propulsion-power"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPropulsionPower_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPropulsionPower = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPropulsionPower);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPropulsionPower, [{
    type: Component,
    args: [{
      selector: "rux-icon-propulsion-power",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPublic = class RuxIconPublic2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPublic.ɵfac = function RuxIconPublic_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPublic)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPublic.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPublic,
  selectors: [["rux-icon-public"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPublic_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPublic = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPublic);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPublic, [{
    type: Component,
    args: [{
      selector: "rux-icon-public",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconPublish = class RuxIconPublish2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconPublish.ɵfac = function RuxIconPublish_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconPublish)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconPublish.ɵcmp = ɵɵdefineComponent({
  type: RuxIconPublish,
  selectors: [["rux-icon-publish"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconPublish_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconPublish = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconPublish);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconPublish, [{
    type: Component,
    args: [{
      selector: "rux-icon-publish",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconQueryBuilder = class RuxIconQueryBuilder2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconQueryBuilder.ɵfac = function RuxIconQueryBuilder_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconQueryBuilder)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconQueryBuilder.ɵcmp = ɵɵdefineComponent({
  type: RuxIconQueryBuilder,
  selectors: [["rux-icon-query-builder"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconQueryBuilder_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconQueryBuilder = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconQueryBuilder);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconQueryBuilder, [{
    type: Component,
    args: [{
      selector: "rux-icon-query-builder",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconQuestionAnswer = class RuxIconQuestionAnswer2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconQuestionAnswer.ɵfac = function RuxIconQuestionAnswer_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconQuestionAnswer)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconQuestionAnswer.ɵcmp = ɵɵdefineComponent({
  type: RuxIconQuestionAnswer,
  selectors: [["rux-icon-question-answer"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconQuestionAnswer_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconQuestionAnswer = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconQuestionAnswer);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconQuestionAnswer, [{
    type: Component,
    args: [{
      selector: "rux-icon-question-answer",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconQueue = class RuxIconQueue2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconQueue.ɵfac = function RuxIconQueue_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconQueue)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconQueue.ɵcmp = ɵɵdefineComponent({
  type: RuxIconQueue,
  selectors: [["rux-icon-queue"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconQueue_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconQueue = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconQueue);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconQueue, [{
    type: Component,
    args: [{
      selector: "rux-icon-queue",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconQueueMusic = class RuxIconQueueMusic2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconQueueMusic.ɵfac = function RuxIconQueueMusic_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconQueueMusic)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconQueueMusic.ɵcmp = ɵɵdefineComponent({
  type: RuxIconQueueMusic,
  selectors: [["rux-icon-queue-music"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconQueueMusic_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconQueueMusic = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconQueueMusic);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconQueueMusic, [{
    type: Component,
    args: [{
      selector: "rux-icon-queue-music",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconQueuePlayNext = class RuxIconQueuePlayNext2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconQueuePlayNext.ɵfac = function RuxIconQueuePlayNext_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconQueuePlayNext)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconQueuePlayNext.ɵcmp = ɵɵdefineComponent({
  type: RuxIconQueuePlayNext,
  selectors: [["rux-icon-queue-play-next"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconQueuePlayNext_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconQueuePlayNext = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconQueuePlayNext);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconQueuePlayNext, [{
    type: Component,
    args: [{
      selector: "rux-icon-queue-play-next",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconRadio = class RuxIconRadio2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconRadio.ɵfac = function RuxIconRadio_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconRadio)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconRadio.ɵcmp = ɵɵdefineComponent({
  type: RuxIconRadio,
  selectors: [["rux-icon-radio"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconRadio_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconRadio = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconRadio);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconRadio, [{
    type: Component,
    args: [{
      selector: "rux-icon-radio",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconRadioButtonChecked = class RuxIconRadioButtonChecked2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconRadioButtonChecked.ɵfac = function RuxIconRadioButtonChecked_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconRadioButtonChecked)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconRadioButtonChecked.ɵcmp = ɵɵdefineComponent({
  type: RuxIconRadioButtonChecked,
  selectors: [["rux-icon-radio-button-checked"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconRadioButtonChecked_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconRadioButtonChecked = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconRadioButtonChecked);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconRadioButtonChecked, [{
    type: Component,
    args: [{
      selector: "rux-icon-radio-button-checked",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconRadioButtonUnchecked = class RuxIconRadioButtonUnchecked2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconRadioButtonUnchecked.ɵfac = function RuxIconRadioButtonUnchecked_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconRadioButtonUnchecked)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconRadioButtonUnchecked.ɵcmp = ɵɵdefineComponent({
  type: RuxIconRadioButtonUnchecked,
  selectors: [["rux-icon-radio-button-unchecked"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconRadioButtonUnchecked_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconRadioButtonUnchecked = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconRadioButtonUnchecked);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconRadioButtonUnchecked, [{
    type: Component,
    args: [{
      selector: "rux-icon-radio-button-unchecked",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconRateReview = class RuxIconRateReview2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconRateReview.ɵfac = function RuxIconRateReview_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconRateReview)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconRateReview.ɵcmp = ɵɵdefineComponent({
  type: RuxIconRateReview,
  selectors: [["rux-icon-rate-review"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconRateReview_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconRateReview = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconRateReview);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconRateReview, [{
    type: Component,
    args: [{
      selector: "rux-icon-rate-review",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconReceipt = class RuxIconReceipt2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconReceipt.ɵfac = function RuxIconReceipt_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconReceipt)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconReceipt.ɵcmp = ɵɵdefineComponent({
  type: RuxIconReceipt,
  selectors: [["rux-icon-receipt"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconReceipt_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconReceipt = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconReceipt);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconReceipt, [{
    type: Component,
    args: [{
      selector: "rux-icon-receipt",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconRecentActors = class RuxIconRecentActors2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconRecentActors.ɵfac = function RuxIconRecentActors_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconRecentActors)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconRecentActors.ɵcmp = ɵɵdefineComponent({
  type: RuxIconRecentActors,
  selectors: [["rux-icon-recent-actors"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconRecentActors_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconRecentActors = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconRecentActors);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconRecentActors, [{
    type: Component,
    args: [{
      selector: "rux-icon-recent-actors",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconRecordVoiceOver = class RuxIconRecordVoiceOver2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconRecordVoiceOver.ɵfac = function RuxIconRecordVoiceOver_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconRecordVoiceOver)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconRecordVoiceOver.ɵcmp = ɵɵdefineComponent({
  type: RuxIconRecordVoiceOver,
  selectors: [["rux-icon-record-voice-over"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconRecordVoiceOver_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconRecordVoiceOver = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconRecordVoiceOver);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconRecordVoiceOver, [{
    type: Component,
    args: [{
      selector: "rux-icon-record-voice-over",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconRedeem = class RuxIconRedeem2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconRedeem.ɵfac = function RuxIconRedeem_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconRedeem)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconRedeem.ɵcmp = ɵɵdefineComponent({
  type: RuxIconRedeem,
  selectors: [["rux-icon-redeem"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconRedeem_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconRedeem = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconRedeem);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconRedeem, [{
    type: Component,
    args: [{
      selector: "rux-icon-redeem",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconRedo = class RuxIconRedo2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconRedo.ɵfac = function RuxIconRedo_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconRedo)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconRedo.ɵcmp = ɵɵdefineComponent({
  type: RuxIconRedo,
  selectors: [["rux-icon-redo"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconRedo_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconRedo = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconRedo);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconRedo, [{
    type: Component,
    args: [{
      selector: "rux-icon-redo",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconRefresh = class RuxIconRefresh2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconRefresh.ɵfac = function RuxIconRefresh_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconRefresh)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconRefresh.ɵcmp = ɵɵdefineComponent({
  type: RuxIconRefresh,
  selectors: [["rux-icon-refresh"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconRefresh_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconRefresh = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconRefresh);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconRefresh, [{
    type: Component,
    args: [{
      selector: "rux-icon-refresh",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconRelease = class RuxIconRelease2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconRelease.ɵfac = function RuxIconRelease_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconRelease)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconRelease.ɵcmp = ɵɵdefineComponent({
  type: RuxIconRelease,
  selectors: [["rux-icon-release"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconRelease_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconRelease = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconRelease);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconRelease, [{
    type: Component,
    args: [{
      selector: "rux-icon-release",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconRemove = class RuxIconRemove2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconRemove.ɵfac = function RuxIconRemove_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconRemove)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconRemove.ɵcmp = ɵɵdefineComponent({
  type: RuxIconRemove,
  selectors: [["rux-icon-remove"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconRemove_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconRemove = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconRemove);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconRemove, [{
    type: Component,
    args: [{
      selector: "rux-icon-remove",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconRemoveCircle = class RuxIconRemoveCircle2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconRemoveCircle.ɵfac = function RuxIconRemoveCircle_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconRemoveCircle)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconRemoveCircle.ɵcmp = ɵɵdefineComponent({
  type: RuxIconRemoveCircle,
  selectors: [["rux-icon-remove-circle"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconRemoveCircle_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconRemoveCircle = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconRemoveCircle);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconRemoveCircle, [{
    type: Component,
    args: [{
      selector: "rux-icon-remove-circle",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconRemoveCircleOutline = class RuxIconRemoveCircleOutline2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconRemoveCircleOutline.ɵfac = function RuxIconRemoveCircleOutline_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconRemoveCircleOutline)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconRemoveCircleOutline.ɵcmp = ɵɵdefineComponent({
  type: RuxIconRemoveCircleOutline,
  selectors: [["rux-icon-remove-circle-outline"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconRemoveCircleOutline_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconRemoveCircleOutline = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconRemoveCircleOutline);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconRemoveCircleOutline, [{
    type: Component,
    args: [{
      selector: "rux-icon-remove-circle-outline",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconRemoveFromQueue = class RuxIconRemoveFromQueue2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconRemoveFromQueue.ɵfac = function RuxIconRemoveFromQueue_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconRemoveFromQueue)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconRemoveFromQueue.ɵcmp = ɵɵdefineComponent({
  type: RuxIconRemoveFromQueue,
  selectors: [["rux-icon-remove-from-queue"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconRemoveFromQueue_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconRemoveFromQueue = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconRemoveFromQueue);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconRemoveFromQueue, [{
    type: Component,
    args: [{
      selector: "rux-icon-remove-from-queue",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconRemoveRedEye = class RuxIconRemoveRedEye2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconRemoveRedEye.ɵfac = function RuxIconRemoveRedEye_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconRemoveRedEye)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconRemoveRedEye.ɵcmp = ɵɵdefineComponent({
  type: RuxIconRemoveRedEye,
  selectors: [["rux-icon-remove-red-eye"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconRemoveRedEye_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconRemoveRedEye = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconRemoveRedEye);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconRemoveRedEye, [{
    type: Component,
    args: [{
      selector: "rux-icon-remove-red-eye",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconRemoveShoppingCart = class RuxIconRemoveShoppingCart2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconRemoveShoppingCart.ɵfac = function RuxIconRemoveShoppingCart_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconRemoveShoppingCart)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconRemoveShoppingCart.ɵcmp = ɵɵdefineComponent({
  type: RuxIconRemoveShoppingCart,
  selectors: [["rux-icon-remove-shopping-cart"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconRemoveShoppingCart_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconRemoveShoppingCart = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconRemoveShoppingCart);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconRemoveShoppingCart, [{
    type: Component,
    args: [{
      selector: "rux-icon-remove-shopping-cart",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconReorder = class RuxIconReorder2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconReorder.ɵfac = function RuxIconReorder_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconReorder)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconReorder.ɵcmp = ɵɵdefineComponent({
  type: RuxIconReorder,
  selectors: [["rux-icon-reorder"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconReorder_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconReorder = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconReorder);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconReorder, [{
    type: Component,
    args: [{
      selector: "rux-icon-reorder",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconRepeat = class RuxIconRepeat2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconRepeat.ɵfac = function RuxIconRepeat_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconRepeat)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconRepeat.ɵcmp = ɵɵdefineComponent({
  type: RuxIconRepeat,
  selectors: [["rux-icon-repeat"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconRepeat_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconRepeat = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconRepeat);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconRepeat, [{
    type: Component,
    args: [{
      selector: "rux-icon-repeat",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconRepeatOne = class RuxIconRepeatOne2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconRepeatOne.ɵfac = function RuxIconRepeatOne_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconRepeatOne)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconRepeatOne.ɵcmp = ɵɵdefineComponent({
  type: RuxIconRepeatOne,
  selectors: [["rux-icon-repeat-one"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconRepeatOne_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconRepeatOne = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconRepeatOne);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconRepeatOne, [{
    type: Component,
    args: [{
      selector: "rux-icon-repeat-one",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconReplay = class RuxIconReplay2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconReplay.ɵfac = function RuxIconReplay_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconReplay)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconReplay.ɵcmp = ɵɵdefineComponent({
  type: RuxIconReplay,
  selectors: [["rux-icon-replay"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconReplay_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconReplay = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconReplay);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconReplay, [{
    type: Component,
    args: [{
      selector: "rux-icon-replay",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconReplay10 = class RuxIconReplay102 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconReplay10.ɵfac = function RuxIconReplay10_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconReplay10)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconReplay10.ɵcmp = ɵɵdefineComponent({
  type: RuxIconReplay10,
  selectors: [["rux-icon-replay-10"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconReplay10_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconReplay10 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconReplay10);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconReplay10, [{
    type: Component,
    args: [{
      selector: "rux-icon-replay-10",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconReplay30 = class RuxIconReplay302 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconReplay30.ɵfac = function RuxIconReplay30_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconReplay30)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconReplay30.ɵcmp = ɵɵdefineComponent({
  type: RuxIconReplay30,
  selectors: [["rux-icon-replay-30"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconReplay30_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconReplay30 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconReplay30);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconReplay30, [{
    type: Component,
    args: [{
      selector: "rux-icon-replay-30",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconReplay5 = class RuxIconReplay52 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconReplay5.ɵfac = function RuxIconReplay5_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconReplay5)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconReplay5.ɵcmp = ɵɵdefineComponent({
  type: RuxIconReplay5,
  selectors: [["rux-icon-replay-5"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconReplay5_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconReplay5 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconReplay5);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconReplay5, [{
    type: Component,
    args: [{
      selector: "rux-icon-replay-5",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconReply = class RuxIconReply2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconReply.ɵfac = function RuxIconReply_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconReply)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconReply.ɵcmp = ɵɵdefineComponent({
  type: RuxIconReply,
  selectors: [["rux-icon-reply"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconReply_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconReply = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconReply);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconReply, [{
    type: Component,
    args: [{
      selector: "rux-icon-reply",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconReplyAll = class RuxIconReplyAll2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconReplyAll.ɵfac = function RuxIconReplyAll_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconReplyAll)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconReplyAll.ɵcmp = ɵɵdefineComponent({
  type: RuxIconReplyAll,
  selectors: [["rux-icon-reply-all"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconReplyAll_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconReplyAll = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconReplyAll);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconReplyAll, [{
    type: Component,
    args: [{
      selector: "rux-icon-reply-all",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconReport = class RuxIconReport2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconReport.ɵfac = function RuxIconReport_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconReport)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconReport.ɵcmp = ɵɵdefineComponent({
  type: RuxIconReport,
  selectors: [["rux-icon-report"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconReport_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconReport = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconReport);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconReport, [{
    type: Component,
    args: [{
      selector: "rux-icon-report",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconReportOff = class RuxIconReportOff2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconReportOff.ɵfac = function RuxIconReportOff_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconReportOff)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconReportOff.ɵcmp = ɵɵdefineComponent({
  type: RuxIconReportOff,
  selectors: [["rux-icon-report-off"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconReportOff_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconReportOff = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconReportOff);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconReportOff, [{
    type: Component,
    args: [{
      selector: "rux-icon-report-off",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconReportProblem = class RuxIconReportProblem2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconReportProblem.ɵfac = function RuxIconReportProblem_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconReportProblem)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconReportProblem.ɵcmp = ɵɵdefineComponent({
  type: RuxIconReportProblem,
  selectors: [["rux-icon-report-problem"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconReportProblem_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconReportProblem = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconReportProblem);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconReportProblem, [{
    type: Component,
    args: [{
      selector: "rux-icon-report-problem",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconRestaurant = class RuxIconRestaurant2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconRestaurant.ɵfac = function RuxIconRestaurant_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconRestaurant)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconRestaurant.ɵcmp = ɵɵdefineComponent({
  type: RuxIconRestaurant,
  selectors: [["rux-icon-restaurant"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconRestaurant_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconRestaurant = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconRestaurant);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconRestaurant, [{
    type: Component,
    args: [{
      selector: "rux-icon-restaurant",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconRestaurantMenu = class RuxIconRestaurantMenu2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconRestaurantMenu.ɵfac = function RuxIconRestaurantMenu_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconRestaurantMenu)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconRestaurantMenu.ɵcmp = ɵɵdefineComponent({
  type: RuxIconRestaurantMenu,
  selectors: [["rux-icon-restaurant-menu"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconRestaurantMenu_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconRestaurantMenu = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconRestaurantMenu);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconRestaurantMenu, [{
    type: Component,
    args: [{
      selector: "rux-icon-restaurant-menu",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconRestore = class RuxIconRestore2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconRestore.ɵfac = function RuxIconRestore_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconRestore)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconRestore.ɵcmp = ɵɵdefineComponent({
  type: RuxIconRestore,
  selectors: [["rux-icon-restore"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconRestore_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconRestore = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconRestore);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconRestore, [{
    type: Component,
    args: [{
      selector: "rux-icon-restore",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconRestoreFromTrash = class RuxIconRestoreFromTrash2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconRestoreFromTrash.ɵfac = function RuxIconRestoreFromTrash_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconRestoreFromTrash)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconRestoreFromTrash.ɵcmp = ɵɵdefineComponent({
  type: RuxIconRestoreFromTrash,
  selectors: [["rux-icon-restore-from-trash"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconRestoreFromTrash_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconRestoreFromTrash = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconRestoreFromTrash);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconRestoreFromTrash, [{
    type: Component,
    args: [{
      selector: "rux-icon-restore-from-trash",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconRestorePage = class RuxIconRestorePage2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconRestorePage.ɵfac = function RuxIconRestorePage_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconRestorePage)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconRestorePage.ɵcmp = ɵɵdefineComponent({
  type: RuxIconRestorePage,
  selectors: [["rux-icon-restore-page"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconRestorePage_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconRestorePage = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconRestorePage);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconRestorePage, [{
    type: Component,
    args: [{
      selector: "rux-icon-restore-page",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconRingVolume = class RuxIconRingVolume2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconRingVolume.ɵfac = function RuxIconRingVolume_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconRingVolume)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconRingVolume.ɵcmp = ɵɵdefineComponent({
  type: RuxIconRingVolume,
  selectors: [["rux-icon-ring-volume"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconRingVolume_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconRingVolume = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconRingVolume);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconRingVolume, [{
    type: Component,
    args: [{
      selector: "rux-icon-ring-volume",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconRoom = class RuxIconRoom2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconRoom.ɵfac = function RuxIconRoom_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconRoom)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconRoom.ɵcmp = ɵɵdefineComponent({
  type: RuxIconRoom,
  selectors: [["rux-icon-room"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconRoom_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconRoom = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconRoom);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconRoom, [{
    type: Component,
    args: [{
      selector: "rux-icon-room",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconRoomService = class RuxIconRoomService2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconRoomService.ɵfac = function RuxIconRoomService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconRoomService)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconRoomService.ɵcmp = ɵɵdefineComponent({
  type: RuxIconRoomService,
  selectors: [["rux-icon-room-service"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconRoomService_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconRoomService = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconRoomService);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconRoomService, [{
    type: Component,
    args: [{
      selector: "rux-icon-room-service",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconRotate90DegreesCc = class RuxIconRotate90DegreesCc2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconRotate90DegreesCc.ɵfac = function RuxIconRotate90DegreesCc_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconRotate90DegreesCc)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconRotate90DegreesCc.ɵcmp = ɵɵdefineComponent({
  type: RuxIconRotate90DegreesCc,
  selectors: [["rux-icon-rotate-90-degrees-cc"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconRotate90DegreesCc_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconRotate90DegreesCc = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconRotate90DegreesCc);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconRotate90DegreesCc, [{
    type: Component,
    args: [{
      selector: "rux-icon-rotate-90-degrees-cc",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconRotateLeft = class RuxIconRotateLeft2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconRotateLeft.ɵfac = function RuxIconRotateLeft_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconRotateLeft)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconRotateLeft.ɵcmp = ɵɵdefineComponent({
  type: RuxIconRotateLeft,
  selectors: [["rux-icon-rotate-left"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconRotateLeft_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconRotateLeft = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconRotateLeft);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconRotateLeft, [{
    type: Component,
    args: [{
      selector: "rux-icon-rotate-left",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconRotateRight = class RuxIconRotateRight2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconRotateRight.ɵfac = function RuxIconRotateRight_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconRotateRight)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconRotateRight.ɵcmp = ɵɵdefineComponent({
  type: RuxIconRotateRight,
  selectors: [["rux-icon-rotate-right"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconRotateRight_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconRotateRight = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconRotateRight);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconRotateRight, [{
    type: Component,
    args: [{
      selector: "rux-icon-rotate-right",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconRoundedCorner = class RuxIconRoundedCorner2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconRoundedCorner.ɵfac = function RuxIconRoundedCorner_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconRoundedCorner)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconRoundedCorner.ɵcmp = ɵɵdefineComponent({
  type: RuxIconRoundedCorner,
  selectors: [["rux-icon-rounded-corner"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconRoundedCorner_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconRoundedCorner = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconRoundedCorner);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconRoundedCorner, [{
    type: Component,
    args: [{
      selector: "rux-icon-rounded-corner",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconRouter = class RuxIconRouter2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconRouter.ɵfac = function RuxIconRouter_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconRouter)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconRouter.ɵcmp = ɵɵdefineComponent({
  type: RuxIconRouter,
  selectors: [["rux-icon-router"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconRouter_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconRouter = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconRouter);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconRouter, [{
    type: Component,
    args: [{
      selector: "rux-icon-router",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconRowing = class RuxIconRowing2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconRowing.ɵfac = function RuxIconRowing_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconRowing)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconRowing.ɵcmp = ɵɵdefineComponent({
  type: RuxIconRowing,
  selectors: [["rux-icon-rowing"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconRowing_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconRowing = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconRowing);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconRowing, [{
    type: Component,
    args: [{
      selector: "rux-icon-rowing",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconRssFeed = class RuxIconRssFeed2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconRssFeed.ɵfac = function RuxIconRssFeed_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconRssFeed)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconRssFeed.ɵcmp = ɵɵdefineComponent({
  type: RuxIconRssFeed,
  selectors: [["rux-icon-rss-feed"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconRssFeed_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconRssFeed = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconRssFeed);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconRssFeed, [{
    type: Component,
    args: [{
      selector: "rux-icon-rss-feed",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconRvHookup = class RuxIconRvHookup2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconRvHookup.ɵfac = function RuxIconRvHookup_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconRvHookup)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconRvHookup.ɵcmp = ɵɵdefineComponent({
  type: RuxIconRvHookup,
  selectors: [["rux-icon-rv-hookup"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconRvHookup_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconRvHookup = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconRvHookup);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconRvHookup, [{
    type: Component,
    args: [{
      selector: "rux-icon-rv-hookup",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSatellite = class RuxIconSatellite2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSatellite.ɵfac = function RuxIconSatellite_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSatellite)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSatellite.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSatellite,
  selectors: [["rux-icon-satellite"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSatellite_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSatellite = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSatellite);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSatellite, [{
    type: Component,
    args: [{
      selector: "rux-icon-satellite",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSatelliteOff = class RuxIconSatelliteOff2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSatelliteOff.ɵfac = function RuxIconSatelliteOff_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSatelliteOff)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSatelliteOff.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSatelliteOff,
  selectors: [["rux-icon-satellite-off"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSatelliteOff_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSatelliteOff = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSatelliteOff);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSatelliteOff, [{
    type: Component,
    args: [{
      selector: "rux-icon-satellite-off",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSatelliteReceive = class RuxIconSatelliteReceive2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSatelliteReceive.ɵfac = function RuxIconSatelliteReceive_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSatelliteReceive)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSatelliteReceive.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSatelliteReceive,
  selectors: [["rux-icon-satellite-receive"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSatelliteReceive_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSatelliteReceive = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSatelliteReceive);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSatelliteReceive, [{
    type: Component,
    args: [{
      selector: "rux-icon-satellite-receive",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSatelliteTransmit = class RuxIconSatelliteTransmit2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSatelliteTransmit.ɵfac = function RuxIconSatelliteTransmit_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSatelliteTransmit)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSatelliteTransmit.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSatelliteTransmit,
  selectors: [["rux-icon-satellite-transmit"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSatelliteTransmit_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSatelliteTransmit = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSatelliteTransmit);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSatelliteTransmit, [{
    type: Component,
    args: [{
      selector: "rux-icon-satellite-transmit",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSave = class RuxIconSave2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSave.ɵfac = function RuxIconSave_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSave)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSave.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSave,
  selectors: [["rux-icon-save"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSave_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSave = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSave);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSave, [{
    type: Component,
    args: [{
      selector: "rux-icon-save",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSaveAlt = class RuxIconSaveAlt2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSaveAlt.ɵfac = function RuxIconSaveAlt_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSaveAlt)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSaveAlt.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSaveAlt,
  selectors: [["rux-icon-save-alt"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSaveAlt_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSaveAlt = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSaveAlt);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSaveAlt, [{
    type: Component,
    args: [{
      selector: "rux-icon-save-alt",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconScanner = class RuxIconScanner2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconScanner.ɵfac = function RuxIconScanner_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconScanner)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconScanner.ɵcmp = ɵɵdefineComponent({
  type: RuxIconScanner,
  selectors: [["rux-icon-scanner"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconScanner_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconScanner = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconScanner);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconScanner, [{
    type: Component,
    args: [{
      selector: "rux-icon-scanner",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconScatterPlot = class RuxIconScatterPlot2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconScatterPlot.ɵfac = function RuxIconScatterPlot_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconScatterPlot)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconScatterPlot.ɵcmp = ɵɵdefineComponent({
  type: RuxIconScatterPlot,
  selectors: [["rux-icon-scatter-plot"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconScatterPlot_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconScatterPlot = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconScatterPlot);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconScatterPlot, [{
    type: Component,
    args: [{
      selector: "rux-icon-scatter-plot",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSchedule = class RuxIconSchedule2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSchedule.ɵfac = function RuxIconSchedule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSchedule)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSchedule.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSchedule,
  selectors: [["rux-icon-schedule"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSchedule_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSchedule = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSchedule);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSchedule, [{
    type: Component,
    args: [{
      selector: "rux-icon-schedule",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSchool = class RuxIconSchool2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSchool.ɵfac = function RuxIconSchool_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSchool)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSchool.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSchool,
  selectors: [["rux-icon-school"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSchool_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSchool = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSchool);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSchool, [{
    type: Component,
    args: [{
      selector: "rux-icon-school",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconScore = class RuxIconScore2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconScore.ɵfac = function RuxIconScore_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconScore)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconScore.ɵcmp = ɵɵdefineComponent({
  type: RuxIconScore,
  selectors: [["rux-icon-score"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconScore_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconScore = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconScore);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconScore, [{
    type: Component,
    args: [{
      selector: "rux-icon-score",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconScreenLockLandscape = class RuxIconScreenLockLandscape2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconScreenLockLandscape.ɵfac = function RuxIconScreenLockLandscape_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconScreenLockLandscape)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconScreenLockLandscape.ɵcmp = ɵɵdefineComponent({
  type: RuxIconScreenLockLandscape,
  selectors: [["rux-icon-screen-lock-landscape"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconScreenLockLandscape_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconScreenLockLandscape = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconScreenLockLandscape);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconScreenLockLandscape, [{
    type: Component,
    args: [{
      selector: "rux-icon-screen-lock-landscape",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconScreenLockPortrait = class RuxIconScreenLockPortrait2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconScreenLockPortrait.ɵfac = function RuxIconScreenLockPortrait_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconScreenLockPortrait)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconScreenLockPortrait.ɵcmp = ɵɵdefineComponent({
  type: RuxIconScreenLockPortrait,
  selectors: [["rux-icon-screen-lock-portrait"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconScreenLockPortrait_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconScreenLockPortrait = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconScreenLockPortrait);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconScreenLockPortrait, [{
    type: Component,
    args: [{
      selector: "rux-icon-screen-lock-portrait",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconScreenLockRotation = class RuxIconScreenLockRotation2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconScreenLockRotation.ɵfac = function RuxIconScreenLockRotation_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconScreenLockRotation)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconScreenLockRotation.ɵcmp = ɵɵdefineComponent({
  type: RuxIconScreenLockRotation,
  selectors: [["rux-icon-screen-lock-rotation"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconScreenLockRotation_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconScreenLockRotation = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconScreenLockRotation);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconScreenLockRotation, [{
    type: Component,
    args: [{
      selector: "rux-icon-screen-lock-rotation",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconScreenRotation = class RuxIconScreenRotation2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconScreenRotation.ɵfac = function RuxIconScreenRotation_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconScreenRotation)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconScreenRotation.ɵcmp = ɵɵdefineComponent({
  type: RuxIconScreenRotation,
  selectors: [["rux-icon-screen-rotation"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconScreenRotation_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconScreenRotation = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconScreenRotation);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconScreenRotation, [{
    type: Component,
    args: [{
      selector: "rux-icon-screen-rotation",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconScreenShare = class RuxIconScreenShare2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconScreenShare.ɵfac = function RuxIconScreenShare_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconScreenShare)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconScreenShare.ɵcmp = ɵɵdefineComponent({
  type: RuxIconScreenShare,
  selectors: [["rux-icon-screen-share"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconScreenShare_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconScreenShare = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconScreenShare);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconScreenShare, [{
    type: Component,
    args: [{
      selector: "rux-icon-screen-share",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSdCard = class RuxIconSdCard2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSdCard.ɵfac = function RuxIconSdCard_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSdCard)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSdCard.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSdCard,
  selectors: [["rux-icon-sd-card"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSdCard_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSdCard = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSdCard);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSdCard, [{
    type: Component,
    args: [{
      selector: "rux-icon-sd-card",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSdStorage = class RuxIconSdStorage2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSdStorage.ɵfac = function RuxIconSdStorage_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSdStorage)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSdStorage.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSdStorage,
  selectors: [["rux-icon-sd-storage"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSdStorage_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSdStorage = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSdStorage);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSdStorage, [{
    type: Component,
    args: [{
      selector: "rux-icon-sd-storage",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSearch = class RuxIconSearch2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSearch.ɵfac = function RuxIconSearch_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSearch)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSearch.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSearch,
  selectors: [["rux-icon-search"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSearch_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSearch = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSearch);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSearch, [{
    type: Component,
    args: [{
      selector: "rux-icon-search",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSeat = class RuxIconSeat2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSeat.ɵfac = function RuxIconSeat_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSeat)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSeat.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSeat,
  selectors: [["rux-icon-seat"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSeat_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSeat = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSeat);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSeat, [{
    type: Component,
    args: [{
      selector: "rux-icon-seat",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSecurity = class RuxIconSecurity2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSecurity.ɵfac = function RuxIconSecurity_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSecurity)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSecurity.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSecurity,
  selectors: [["rux-icon-security"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSecurity_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSecurity = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSecurity);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSecurity, [{
    type: Component,
    args: [{
      selector: "rux-icon-security",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSelectAll = class RuxIconSelectAll2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSelectAll.ɵfac = function RuxIconSelectAll_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSelectAll)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSelectAll.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSelectAll,
  selectors: [["rux-icon-select-all"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSelectAll_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSelectAll = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSelectAll);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSelectAll, [{
    type: Component,
    args: [{
      selector: "rux-icon-select-all",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSend = class RuxIconSend2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSend.ɵfac = function RuxIconSend_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSend)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSend.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSend,
  selectors: [["rux-icon-send"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSend_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSend = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSend);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSend, [{
    type: Component,
    args: [{
      selector: "rux-icon-send",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSentimentDissatisfied = class RuxIconSentimentDissatisfied2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSentimentDissatisfied.ɵfac = function RuxIconSentimentDissatisfied_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSentimentDissatisfied)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSentimentDissatisfied.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSentimentDissatisfied,
  selectors: [["rux-icon-sentiment-dissatisfied"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSentimentDissatisfied_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSentimentDissatisfied = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSentimentDissatisfied);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSentimentDissatisfied, [{
    type: Component,
    args: [{
      selector: "rux-icon-sentiment-dissatisfied",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSentimentSatisfied = class RuxIconSentimentSatisfied2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSentimentSatisfied.ɵfac = function RuxIconSentimentSatisfied_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSentimentSatisfied)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSentimentSatisfied.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSentimentSatisfied,
  selectors: [["rux-icon-sentiment-satisfied"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSentimentSatisfied_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSentimentSatisfied = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSentimentSatisfied);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSentimentSatisfied, [{
    type: Component,
    args: [{
      selector: "rux-icon-sentiment-satisfied",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSentimentSatisfiedAlt = class RuxIconSentimentSatisfiedAlt2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSentimentSatisfiedAlt.ɵfac = function RuxIconSentimentSatisfiedAlt_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSentimentSatisfiedAlt)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSentimentSatisfiedAlt.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSentimentSatisfiedAlt,
  selectors: [["rux-icon-sentiment-satisfied-alt"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSentimentSatisfiedAlt_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSentimentSatisfiedAlt = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSentimentSatisfiedAlt);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSentimentSatisfiedAlt, [{
    type: Component,
    args: [{
      selector: "rux-icon-sentiment-satisfied-alt",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSentimentVeryDissatisfied = class RuxIconSentimentVeryDissatisfied2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSentimentVeryDissatisfied.ɵfac = function RuxIconSentimentVeryDissatisfied_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSentimentVeryDissatisfied)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSentimentVeryDissatisfied.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSentimentVeryDissatisfied,
  selectors: [["rux-icon-sentiment-very-dissatisfied"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSentimentVeryDissatisfied_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSentimentVeryDissatisfied = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSentimentVeryDissatisfied);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSentimentVeryDissatisfied, [{
    type: Component,
    args: [{
      selector: "rux-icon-sentiment-very-dissatisfied",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSentimentVerySatisfied = class RuxIconSentimentVerySatisfied2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSentimentVerySatisfied.ɵfac = function RuxIconSentimentVerySatisfied_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSentimentVerySatisfied)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSentimentVerySatisfied.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSentimentVerySatisfied,
  selectors: [["rux-icon-sentiment-very-satisfied"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSentimentVerySatisfied_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSentimentVerySatisfied = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSentimentVerySatisfied);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSentimentVerySatisfied, [{
    type: Component,
    args: [{
      selector: "rux-icon-sentiment-very-satisfied",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSetPower = class RuxIconSetPower2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSetPower.ɵfac = function RuxIconSetPower_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSetPower)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSetPower.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSetPower,
  selectors: [["rux-icon-set-power"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSetPower_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSetPower = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSetPower);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSetPower, [{
    type: Component,
    args: [{
      selector: "rux-icon-set-power",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSettings = class RuxIconSettings2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSettings.ɵfac = function RuxIconSettings_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSettings)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSettings.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSettings,
  selectors: [["rux-icon-settings"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSettings_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSettings = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSettings);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSettings, [{
    type: Component,
    args: [{
      selector: "rux-icon-settings",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSettingsApplications = class RuxIconSettingsApplications2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSettingsApplications.ɵfac = function RuxIconSettingsApplications_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSettingsApplications)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSettingsApplications.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSettingsApplications,
  selectors: [["rux-icon-settings-applications"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSettingsApplications_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSettingsApplications = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSettingsApplications);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSettingsApplications, [{
    type: Component,
    args: [{
      selector: "rux-icon-settings-applications",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSettingsBackupRestore = class RuxIconSettingsBackupRestore2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSettingsBackupRestore.ɵfac = function RuxIconSettingsBackupRestore_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSettingsBackupRestore)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSettingsBackupRestore.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSettingsBackupRestore,
  selectors: [["rux-icon-settings-backup-restore"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSettingsBackupRestore_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSettingsBackupRestore = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSettingsBackupRestore);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSettingsBackupRestore, [{
    type: Component,
    args: [{
      selector: "rux-icon-settings-backup-restore",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSettingsBluetooth = class RuxIconSettingsBluetooth2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSettingsBluetooth.ɵfac = function RuxIconSettingsBluetooth_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSettingsBluetooth)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSettingsBluetooth.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSettingsBluetooth,
  selectors: [["rux-icon-settings-bluetooth"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSettingsBluetooth_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSettingsBluetooth = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSettingsBluetooth);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSettingsBluetooth, [{
    type: Component,
    args: [{
      selector: "rux-icon-settings-bluetooth",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSettingsBrightness = class RuxIconSettingsBrightness2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSettingsBrightness.ɵfac = function RuxIconSettingsBrightness_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSettingsBrightness)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSettingsBrightness.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSettingsBrightness,
  selectors: [["rux-icon-settings-brightness"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSettingsBrightness_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSettingsBrightness = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSettingsBrightness);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSettingsBrightness, [{
    type: Component,
    args: [{
      selector: "rux-icon-settings-brightness",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSettingsCell = class RuxIconSettingsCell2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSettingsCell.ɵfac = function RuxIconSettingsCell_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSettingsCell)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSettingsCell.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSettingsCell,
  selectors: [["rux-icon-settings-cell"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSettingsCell_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSettingsCell = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSettingsCell);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSettingsCell, [{
    type: Component,
    args: [{
      selector: "rux-icon-settings-cell",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSettingsEthernet = class RuxIconSettingsEthernet2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSettingsEthernet.ɵfac = function RuxIconSettingsEthernet_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSettingsEthernet)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSettingsEthernet.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSettingsEthernet,
  selectors: [["rux-icon-settings-ethernet"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSettingsEthernet_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSettingsEthernet = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSettingsEthernet);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSettingsEthernet, [{
    type: Component,
    args: [{
      selector: "rux-icon-settings-ethernet",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSettingsInputAntenna = class RuxIconSettingsInputAntenna2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSettingsInputAntenna.ɵfac = function RuxIconSettingsInputAntenna_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSettingsInputAntenna)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSettingsInputAntenna.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSettingsInputAntenna,
  selectors: [["rux-icon-settings-input-antenna"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSettingsInputAntenna_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSettingsInputAntenna = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSettingsInputAntenna);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSettingsInputAntenna, [{
    type: Component,
    args: [{
      selector: "rux-icon-settings-input-antenna",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSettingsInputComponent = class RuxIconSettingsInputComponent2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSettingsInputComponent.ɵfac = function RuxIconSettingsInputComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSettingsInputComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSettingsInputComponent.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSettingsInputComponent,
  selectors: [["rux-icon-settings-input-component"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSettingsInputComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSettingsInputComponent = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSettingsInputComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSettingsInputComponent, [{
    type: Component,
    args: [{
      selector: "rux-icon-settings-input-component",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSettingsInputComposite = class RuxIconSettingsInputComposite2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSettingsInputComposite.ɵfac = function RuxIconSettingsInputComposite_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSettingsInputComposite)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSettingsInputComposite.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSettingsInputComposite,
  selectors: [["rux-icon-settings-input-composite"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSettingsInputComposite_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSettingsInputComposite = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSettingsInputComposite);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSettingsInputComposite, [{
    type: Component,
    args: [{
      selector: "rux-icon-settings-input-composite",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSettingsInputHdmi = class RuxIconSettingsInputHdmi2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSettingsInputHdmi.ɵfac = function RuxIconSettingsInputHdmi_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSettingsInputHdmi)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSettingsInputHdmi.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSettingsInputHdmi,
  selectors: [["rux-icon-settings-input-hdmi"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSettingsInputHdmi_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSettingsInputHdmi = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSettingsInputHdmi);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSettingsInputHdmi, [{
    type: Component,
    args: [{
      selector: "rux-icon-settings-input-hdmi",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSettingsInputSvideo = class RuxIconSettingsInputSvideo2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSettingsInputSvideo.ɵfac = function RuxIconSettingsInputSvideo_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSettingsInputSvideo)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSettingsInputSvideo.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSettingsInputSvideo,
  selectors: [["rux-icon-settings-input-svideo"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSettingsInputSvideo_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSettingsInputSvideo = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSettingsInputSvideo);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSettingsInputSvideo, [{
    type: Component,
    args: [{
      selector: "rux-icon-settings-input-svideo",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSettingsOverscan = class RuxIconSettingsOverscan2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSettingsOverscan.ɵfac = function RuxIconSettingsOverscan_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSettingsOverscan)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSettingsOverscan.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSettingsOverscan,
  selectors: [["rux-icon-settings-overscan"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSettingsOverscan_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSettingsOverscan = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSettingsOverscan);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSettingsOverscan, [{
    type: Component,
    args: [{
      selector: "rux-icon-settings-overscan",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSettingsPhone = class RuxIconSettingsPhone2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSettingsPhone.ɵfac = function RuxIconSettingsPhone_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSettingsPhone)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSettingsPhone.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSettingsPhone,
  selectors: [["rux-icon-settings-phone"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSettingsPhone_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSettingsPhone = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSettingsPhone);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSettingsPhone, [{
    type: Component,
    args: [{
      selector: "rux-icon-settings-phone",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSettingsPower = class RuxIconSettingsPower2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSettingsPower.ɵfac = function RuxIconSettingsPower_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSettingsPower)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSettingsPower.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSettingsPower,
  selectors: [["rux-icon-settings-power"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSettingsPower_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSettingsPower = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSettingsPower);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSettingsPower, [{
    type: Component,
    args: [{
      selector: "rux-icon-settings-power",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSettingsRemote = class RuxIconSettingsRemote2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSettingsRemote.ɵfac = function RuxIconSettingsRemote_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSettingsRemote)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSettingsRemote.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSettingsRemote,
  selectors: [["rux-icon-settings-remote"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSettingsRemote_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSettingsRemote = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSettingsRemote);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSettingsRemote, [{
    type: Component,
    args: [{
      selector: "rux-icon-settings-remote",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSettingsSystemDaydream = class RuxIconSettingsSystemDaydream2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSettingsSystemDaydream.ɵfac = function RuxIconSettingsSystemDaydream_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSettingsSystemDaydream)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSettingsSystemDaydream.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSettingsSystemDaydream,
  selectors: [["rux-icon-settings-system-daydream"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSettingsSystemDaydream_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSettingsSystemDaydream = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSettingsSystemDaydream);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSettingsSystemDaydream, [{
    type: Component,
    args: [{
      selector: "rux-icon-settings-system-daydream",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSettingsVoice = class RuxIconSettingsVoice2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSettingsVoice.ɵfac = function RuxIconSettingsVoice_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSettingsVoice)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSettingsVoice.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSettingsVoice,
  selectors: [["rux-icon-settings-voice"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSettingsVoice_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSettingsVoice = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSettingsVoice);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSettingsVoice, [{
    type: Component,
    args: [{
      selector: "rux-icon-settings-voice",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconShare = class RuxIconShare2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconShare.ɵfac = function RuxIconShare_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconShare)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconShare.ɵcmp = ɵɵdefineComponent({
  type: RuxIconShare,
  selectors: [["rux-icon-share"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconShare_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconShare = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconShare);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconShare, [{
    type: Component,
    args: [{
      selector: "rux-icon-share",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconShop = class RuxIconShop2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconShop.ɵfac = function RuxIconShop_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconShop)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconShop.ɵcmp = ɵɵdefineComponent({
  type: RuxIconShop,
  selectors: [["rux-icon-shop"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconShop_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconShop = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconShop);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconShop, [{
    type: Component,
    args: [{
      selector: "rux-icon-shop",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconShopTwo = class RuxIconShopTwo2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconShopTwo.ɵfac = function RuxIconShopTwo_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconShopTwo)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconShopTwo.ɵcmp = ɵɵdefineComponent({
  type: RuxIconShopTwo,
  selectors: [["rux-icon-shop-two"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconShopTwo_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconShopTwo = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconShopTwo);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconShopTwo, [{
    type: Component,
    args: [{
      selector: "rux-icon-shop-two",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconShoppingBasket = class RuxIconShoppingBasket2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconShoppingBasket.ɵfac = function RuxIconShoppingBasket_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconShoppingBasket)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconShoppingBasket.ɵcmp = ɵɵdefineComponent({
  type: RuxIconShoppingBasket,
  selectors: [["rux-icon-shopping-basket"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconShoppingBasket_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconShoppingBasket = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconShoppingBasket);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconShoppingBasket, [{
    type: Component,
    args: [{
      selector: "rux-icon-shopping-basket",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconShoppingCart = class RuxIconShoppingCart2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconShoppingCart.ɵfac = function RuxIconShoppingCart_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconShoppingCart)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconShoppingCart.ɵcmp = ɵɵdefineComponent({
  type: RuxIconShoppingCart,
  selectors: [["rux-icon-shopping-cart"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconShoppingCart_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconShoppingCart = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconShoppingCart);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconShoppingCart, [{
    type: Component,
    args: [{
      selector: "rux-icon-shopping-cart",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconShortText = class RuxIconShortText2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconShortText.ɵfac = function RuxIconShortText_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconShortText)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconShortText.ɵcmp = ɵɵdefineComponent({
  type: RuxIconShortText,
  selectors: [["rux-icon-short-text"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconShortText_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconShortText = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconShortText);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconShortText, [{
    type: Component,
    args: [{
      selector: "rux-icon-short-text",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconShowChart = class RuxIconShowChart2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconShowChart.ɵfac = function RuxIconShowChart_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconShowChart)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconShowChart.ɵcmp = ɵɵdefineComponent({
  type: RuxIconShowChart,
  selectors: [["rux-icon-show-chart"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconShowChart_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconShowChart = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconShowChart);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconShowChart, [{
    type: Component,
    args: [{
      selector: "rux-icon-show-chart",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconShuffle = class RuxIconShuffle2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconShuffle.ɵfac = function RuxIconShuffle_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconShuffle)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconShuffle.ɵcmp = ɵɵdefineComponent({
  type: RuxIconShuffle,
  selectors: [["rux-icon-shuffle"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconShuffle_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconShuffle = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconShuffle);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconShuffle, [{
    type: Component,
    args: [{
      selector: "rux-icon-shuffle",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconShutterSpeed = class RuxIconShutterSpeed2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconShutterSpeed.ɵfac = function RuxIconShutterSpeed_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconShutterSpeed)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconShutterSpeed.ɵcmp = ɵɵdefineComponent({
  type: RuxIconShutterSpeed,
  selectors: [["rux-icon-shutter-speed"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconShutterSpeed_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconShutterSpeed = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconShutterSpeed);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconShutterSpeed, [{
    type: Component,
    args: [{
      selector: "rux-icon-shutter-speed",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSignalCellular0Bar = class RuxIconSignalCellular0Bar2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSignalCellular0Bar.ɵfac = function RuxIconSignalCellular0Bar_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSignalCellular0Bar)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSignalCellular0Bar.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSignalCellular0Bar,
  selectors: [["rux-icon-signal-cellular-0-bar"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSignalCellular0Bar_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSignalCellular0Bar = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSignalCellular0Bar);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSignalCellular0Bar, [{
    type: Component,
    args: [{
      selector: "rux-icon-signal-cellular-0-bar",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSignalCellular1Bar = class RuxIconSignalCellular1Bar2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSignalCellular1Bar.ɵfac = function RuxIconSignalCellular1Bar_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSignalCellular1Bar)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSignalCellular1Bar.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSignalCellular1Bar,
  selectors: [["rux-icon-signal-cellular-1-bar"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSignalCellular1Bar_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSignalCellular1Bar = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSignalCellular1Bar);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSignalCellular1Bar, [{
    type: Component,
    args: [{
      selector: "rux-icon-signal-cellular-1-bar",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSignalCellular2Bar = class RuxIconSignalCellular2Bar2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSignalCellular2Bar.ɵfac = function RuxIconSignalCellular2Bar_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSignalCellular2Bar)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSignalCellular2Bar.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSignalCellular2Bar,
  selectors: [["rux-icon-signal-cellular-2-bar"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSignalCellular2Bar_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSignalCellular2Bar = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSignalCellular2Bar);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSignalCellular2Bar, [{
    type: Component,
    args: [{
      selector: "rux-icon-signal-cellular-2-bar",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSignalCellular3Bar = class RuxIconSignalCellular3Bar2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSignalCellular3Bar.ɵfac = function RuxIconSignalCellular3Bar_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSignalCellular3Bar)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSignalCellular3Bar.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSignalCellular3Bar,
  selectors: [["rux-icon-signal-cellular-3-bar"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSignalCellular3Bar_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSignalCellular3Bar = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSignalCellular3Bar);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSignalCellular3Bar, [{
    type: Component,
    args: [{
      selector: "rux-icon-signal-cellular-3-bar",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSignalCellular4Bar = class RuxIconSignalCellular4Bar2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSignalCellular4Bar.ɵfac = function RuxIconSignalCellular4Bar_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSignalCellular4Bar)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSignalCellular4Bar.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSignalCellular4Bar,
  selectors: [["rux-icon-signal-cellular-4-bar"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSignalCellular4Bar_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSignalCellular4Bar = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSignalCellular4Bar);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSignalCellular4Bar, [{
    type: Component,
    args: [{
      selector: "rux-icon-signal-cellular-4-bar",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSignalCellularAlt = class RuxIconSignalCellularAlt2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSignalCellularAlt.ɵfac = function RuxIconSignalCellularAlt_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSignalCellularAlt)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSignalCellularAlt.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSignalCellularAlt,
  selectors: [["rux-icon-signal-cellular-alt"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSignalCellularAlt_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSignalCellularAlt = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSignalCellularAlt);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSignalCellularAlt, [{
    type: Component,
    args: [{
      selector: "rux-icon-signal-cellular-alt",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSignalCellularConnectedNoInternet0Bar = class RuxIconSignalCellularConnectedNoInternet0Bar2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSignalCellularConnectedNoInternet0Bar.ɵfac = function RuxIconSignalCellularConnectedNoInternet0Bar_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSignalCellularConnectedNoInternet0Bar)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSignalCellularConnectedNoInternet0Bar.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSignalCellularConnectedNoInternet0Bar,
  selectors: [["rux-icon-signal-cellular-connected-no-internet-0-bar"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSignalCellularConnectedNoInternet0Bar_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSignalCellularConnectedNoInternet0Bar = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSignalCellularConnectedNoInternet0Bar);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSignalCellularConnectedNoInternet0Bar, [{
    type: Component,
    args: [{
      selector: "rux-icon-signal-cellular-connected-no-internet-0-bar",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSignalCellularConnectedNoInternet1Bar = class RuxIconSignalCellularConnectedNoInternet1Bar2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSignalCellularConnectedNoInternet1Bar.ɵfac = function RuxIconSignalCellularConnectedNoInternet1Bar_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSignalCellularConnectedNoInternet1Bar)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSignalCellularConnectedNoInternet1Bar.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSignalCellularConnectedNoInternet1Bar,
  selectors: [["rux-icon-signal-cellular-connected-no-internet-1-bar"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSignalCellularConnectedNoInternet1Bar_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSignalCellularConnectedNoInternet1Bar = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSignalCellularConnectedNoInternet1Bar);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSignalCellularConnectedNoInternet1Bar, [{
    type: Component,
    args: [{
      selector: "rux-icon-signal-cellular-connected-no-internet-1-bar",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSignalCellularConnectedNoInternet2Bar = class RuxIconSignalCellularConnectedNoInternet2Bar2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSignalCellularConnectedNoInternet2Bar.ɵfac = function RuxIconSignalCellularConnectedNoInternet2Bar_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSignalCellularConnectedNoInternet2Bar)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSignalCellularConnectedNoInternet2Bar.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSignalCellularConnectedNoInternet2Bar,
  selectors: [["rux-icon-signal-cellular-connected-no-internet-2-bar"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSignalCellularConnectedNoInternet2Bar_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSignalCellularConnectedNoInternet2Bar = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSignalCellularConnectedNoInternet2Bar);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSignalCellularConnectedNoInternet2Bar, [{
    type: Component,
    args: [{
      selector: "rux-icon-signal-cellular-connected-no-internet-2-bar",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSignalCellularConnectedNoInternet3Bar = class RuxIconSignalCellularConnectedNoInternet3Bar2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSignalCellularConnectedNoInternet3Bar.ɵfac = function RuxIconSignalCellularConnectedNoInternet3Bar_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSignalCellularConnectedNoInternet3Bar)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSignalCellularConnectedNoInternet3Bar.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSignalCellularConnectedNoInternet3Bar,
  selectors: [["rux-icon-signal-cellular-connected-no-internet-3-bar"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSignalCellularConnectedNoInternet3Bar_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSignalCellularConnectedNoInternet3Bar = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSignalCellularConnectedNoInternet3Bar);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSignalCellularConnectedNoInternet3Bar, [{
    type: Component,
    args: [{
      selector: "rux-icon-signal-cellular-connected-no-internet-3-bar",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSignalCellularConnectedNoInternet4Bar = class RuxIconSignalCellularConnectedNoInternet4Bar2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSignalCellularConnectedNoInternet4Bar.ɵfac = function RuxIconSignalCellularConnectedNoInternet4Bar_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSignalCellularConnectedNoInternet4Bar)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSignalCellularConnectedNoInternet4Bar.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSignalCellularConnectedNoInternet4Bar,
  selectors: [["rux-icon-signal-cellular-connected-no-internet-4-bar"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSignalCellularConnectedNoInternet4Bar_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSignalCellularConnectedNoInternet4Bar = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSignalCellularConnectedNoInternet4Bar);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSignalCellularConnectedNoInternet4Bar, [{
    type: Component,
    args: [{
      selector: "rux-icon-signal-cellular-connected-no-internet-4-bar",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSignalCellularNoSim = class RuxIconSignalCellularNoSim2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSignalCellularNoSim.ɵfac = function RuxIconSignalCellularNoSim_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSignalCellularNoSim)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSignalCellularNoSim.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSignalCellularNoSim,
  selectors: [["rux-icon-signal-cellular-no-sim"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSignalCellularNoSim_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSignalCellularNoSim = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSignalCellularNoSim);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSignalCellularNoSim, [{
    type: Component,
    args: [{
      selector: "rux-icon-signal-cellular-no-sim",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSignalCellularNull = class RuxIconSignalCellularNull2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSignalCellularNull.ɵfac = function RuxIconSignalCellularNull_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSignalCellularNull)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSignalCellularNull.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSignalCellularNull,
  selectors: [["rux-icon-signal-cellular-null"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSignalCellularNull_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSignalCellularNull = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSignalCellularNull);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSignalCellularNull, [{
    type: Component,
    args: [{
      selector: "rux-icon-signal-cellular-null",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSignalCellularOff = class RuxIconSignalCellularOff2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSignalCellularOff.ɵfac = function RuxIconSignalCellularOff_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSignalCellularOff)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSignalCellularOff.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSignalCellularOff,
  selectors: [["rux-icon-signal-cellular-off"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSignalCellularOff_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSignalCellularOff = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSignalCellularOff);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSignalCellularOff, [{
    type: Component,
    args: [{
      selector: "rux-icon-signal-cellular-off",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSignalWifi0Bar = class RuxIconSignalWifi0Bar2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSignalWifi0Bar.ɵfac = function RuxIconSignalWifi0Bar_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSignalWifi0Bar)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSignalWifi0Bar.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSignalWifi0Bar,
  selectors: [["rux-icon-signal-wifi-0-bar"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSignalWifi0Bar_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSignalWifi0Bar = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSignalWifi0Bar);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSignalWifi0Bar, [{
    type: Component,
    args: [{
      selector: "rux-icon-signal-wifi-0-bar",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSignalWifi1Bar = class RuxIconSignalWifi1Bar2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSignalWifi1Bar.ɵfac = function RuxIconSignalWifi1Bar_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSignalWifi1Bar)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSignalWifi1Bar.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSignalWifi1Bar,
  selectors: [["rux-icon-signal-wifi-1-bar"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSignalWifi1Bar_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSignalWifi1Bar = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSignalWifi1Bar);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSignalWifi1Bar, [{
    type: Component,
    args: [{
      selector: "rux-icon-signal-wifi-1-bar",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSignalWifi1BarLock = class RuxIconSignalWifi1BarLock2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSignalWifi1BarLock.ɵfac = function RuxIconSignalWifi1BarLock_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSignalWifi1BarLock)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSignalWifi1BarLock.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSignalWifi1BarLock,
  selectors: [["rux-icon-signal-wifi-1-bar-lock"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSignalWifi1BarLock_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSignalWifi1BarLock = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSignalWifi1BarLock);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSignalWifi1BarLock, [{
    type: Component,
    args: [{
      selector: "rux-icon-signal-wifi-1-bar-lock",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSignalWifi2Bar = class RuxIconSignalWifi2Bar2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSignalWifi2Bar.ɵfac = function RuxIconSignalWifi2Bar_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSignalWifi2Bar)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSignalWifi2Bar.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSignalWifi2Bar,
  selectors: [["rux-icon-signal-wifi-2-bar"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSignalWifi2Bar_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSignalWifi2Bar = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSignalWifi2Bar);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSignalWifi2Bar, [{
    type: Component,
    args: [{
      selector: "rux-icon-signal-wifi-2-bar",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSignalWifi2BarLock = class RuxIconSignalWifi2BarLock2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSignalWifi2BarLock.ɵfac = function RuxIconSignalWifi2BarLock_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSignalWifi2BarLock)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSignalWifi2BarLock.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSignalWifi2BarLock,
  selectors: [["rux-icon-signal-wifi-2-bar-lock"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSignalWifi2BarLock_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSignalWifi2BarLock = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSignalWifi2BarLock);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSignalWifi2BarLock, [{
    type: Component,
    args: [{
      selector: "rux-icon-signal-wifi-2-bar-lock",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSignalWifi3Bar = class RuxIconSignalWifi3Bar2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSignalWifi3Bar.ɵfac = function RuxIconSignalWifi3Bar_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSignalWifi3Bar)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSignalWifi3Bar.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSignalWifi3Bar,
  selectors: [["rux-icon-signal-wifi-3-bar"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSignalWifi3Bar_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSignalWifi3Bar = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSignalWifi3Bar);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSignalWifi3Bar, [{
    type: Component,
    args: [{
      selector: "rux-icon-signal-wifi-3-bar",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSignalWifi3BarLock = class RuxIconSignalWifi3BarLock2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSignalWifi3BarLock.ɵfac = function RuxIconSignalWifi3BarLock_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSignalWifi3BarLock)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSignalWifi3BarLock.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSignalWifi3BarLock,
  selectors: [["rux-icon-signal-wifi-3-bar-lock"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSignalWifi3BarLock_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSignalWifi3BarLock = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSignalWifi3BarLock);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSignalWifi3BarLock, [{
    type: Component,
    args: [{
      selector: "rux-icon-signal-wifi-3-bar-lock",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSignalWifi4Bar = class RuxIconSignalWifi4Bar2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSignalWifi4Bar.ɵfac = function RuxIconSignalWifi4Bar_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSignalWifi4Bar)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSignalWifi4Bar.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSignalWifi4Bar,
  selectors: [["rux-icon-signal-wifi-4-bar"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSignalWifi4Bar_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSignalWifi4Bar = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSignalWifi4Bar);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSignalWifi4Bar, [{
    type: Component,
    args: [{
      selector: "rux-icon-signal-wifi-4-bar",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSignalWifi4BarLock = class RuxIconSignalWifi4BarLock2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSignalWifi4BarLock.ɵfac = function RuxIconSignalWifi4BarLock_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSignalWifi4BarLock)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSignalWifi4BarLock.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSignalWifi4BarLock,
  selectors: [["rux-icon-signal-wifi-4-bar-lock"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSignalWifi4BarLock_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSignalWifi4BarLock = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSignalWifi4BarLock);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSignalWifi4BarLock, [{
    type: Component,
    args: [{
      selector: "rux-icon-signal-wifi-4-bar-lock",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSignalWifiOff = class RuxIconSignalWifiOff2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSignalWifiOff.ɵfac = function RuxIconSignalWifiOff_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSignalWifiOff)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSignalWifiOff.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSignalWifiOff,
  selectors: [["rux-icon-signal-wifi-off"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSignalWifiOff_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSignalWifiOff = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSignalWifiOff);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSignalWifiOff, [{
    type: Component,
    args: [{
      selector: "rux-icon-signal-wifi-off",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSimCard = class RuxIconSimCard2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSimCard.ɵfac = function RuxIconSimCard_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSimCard)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSimCard.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSimCard,
  selectors: [["rux-icon-sim-card"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSimCard_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSimCard = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSimCard);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSimCard, [{
    type: Component,
    args: [{
      selector: "rux-icon-sim-card",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSkipNext = class RuxIconSkipNext2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSkipNext.ɵfac = function RuxIconSkipNext_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSkipNext)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSkipNext.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSkipNext,
  selectors: [["rux-icon-skip-next"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSkipNext_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSkipNext = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSkipNext);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSkipNext, [{
    type: Component,
    args: [{
      selector: "rux-icon-skip-next",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSkipPrevious = class RuxIconSkipPrevious2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSkipPrevious.ɵfac = function RuxIconSkipPrevious_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSkipPrevious)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSkipPrevious.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSkipPrevious,
  selectors: [["rux-icon-skip-previous"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSkipPrevious_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSkipPrevious = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSkipPrevious);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSkipPrevious, [{
    type: Component,
    args: [{
      selector: "rux-icon-skip-previous",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSlideshow = class RuxIconSlideshow2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSlideshow.ɵfac = function RuxIconSlideshow_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSlideshow)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSlideshow.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSlideshow,
  selectors: [["rux-icon-slideshow"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSlideshow_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSlideshow = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSlideshow);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSlideshow, [{
    type: Component,
    args: [{
      selector: "rux-icon-slideshow",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSlowMotionVideo = class RuxIconSlowMotionVideo2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSlowMotionVideo.ɵfac = function RuxIconSlowMotionVideo_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSlowMotionVideo)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSlowMotionVideo.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSlowMotionVideo,
  selectors: [["rux-icon-slow-motion-video"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSlowMotionVideo_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSlowMotionVideo = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSlowMotionVideo);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSlowMotionVideo, [{
    type: Component,
    args: [{
      selector: "rux-icon-slow-motion-video",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSmartphone = class RuxIconSmartphone2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSmartphone.ɵfac = function RuxIconSmartphone_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSmartphone)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSmartphone.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSmartphone,
  selectors: [["rux-icon-smartphone"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSmartphone_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSmartphone = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSmartphone);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSmartphone, [{
    type: Component,
    args: [{
      selector: "rux-icon-smartphone",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSmokeFree = class RuxIconSmokeFree2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSmokeFree.ɵfac = function RuxIconSmokeFree_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSmokeFree)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSmokeFree.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSmokeFree,
  selectors: [["rux-icon-smoke-free"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSmokeFree_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSmokeFree = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSmokeFree);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSmokeFree, [{
    type: Component,
    args: [{
      selector: "rux-icon-smoke-free",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSmokingRooms = class RuxIconSmokingRooms2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSmokingRooms.ɵfac = function RuxIconSmokingRooms_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSmokingRooms)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSmokingRooms.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSmokingRooms,
  selectors: [["rux-icon-smoking-rooms"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSmokingRooms_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSmokingRooms = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSmokingRooms);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSmokingRooms, [{
    type: Component,
    args: [{
      selector: "rux-icon-smoking-rooms",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSms = class RuxIconSms2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSms.ɵfac = function RuxIconSms_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSms)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSms.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSms,
  selectors: [["rux-icon-sms"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSms_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSms = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSms);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSms, [{
    type: Component,
    args: [{
      selector: "rux-icon-sms",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSmsFailed = class RuxIconSmsFailed2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSmsFailed.ɵfac = function RuxIconSmsFailed_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSmsFailed)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSmsFailed.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSmsFailed,
  selectors: [["rux-icon-sms-failed"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSmsFailed_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSmsFailed = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSmsFailed);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSmsFailed, [{
    type: Component,
    args: [{
      selector: "rux-icon-sms-failed",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSnooze = class RuxIconSnooze2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSnooze.ɵfac = function RuxIconSnooze_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSnooze)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSnooze.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSnooze,
  selectors: [["rux-icon-snooze"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSnooze_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSnooze = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSnooze);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSnooze, [{
    type: Component,
    args: [{
      selector: "rux-icon-snooze",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSolar = class RuxIconSolar2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSolar.ɵfac = function RuxIconSolar_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSolar)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSolar.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSolar,
  selectors: [["rux-icon-solar"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSolar_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSolar = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSolar);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSolar, [{
    type: Component,
    args: [{
      selector: "rux-icon-solar",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSort = class RuxIconSort2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSort.ɵfac = function RuxIconSort_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSort)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSort.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSort,
  selectors: [["rux-icon-sort"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSort_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSort = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSort);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSort, [{
    type: Component,
    args: [{
      selector: "rux-icon-sort",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSortByAlpha = class RuxIconSortByAlpha2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSortByAlpha.ɵfac = function RuxIconSortByAlpha_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSortByAlpha)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSortByAlpha.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSortByAlpha,
  selectors: [["rux-icon-sort-by-alpha"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSortByAlpha_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSortByAlpha = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSortByAlpha);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSortByAlpha, [{
    type: Component,
    args: [{
      selector: "rux-icon-sort-by-alpha",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSpa = class RuxIconSpa2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSpa.ɵfac = function RuxIconSpa_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSpa)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSpa.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSpa,
  selectors: [["rux-icon-spa"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSpa_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSpa = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSpa);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSpa, [{
    type: Component,
    args: [{
      selector: "rux-icon-spa",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSpaceBar = class RuxIconSpaceBar2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSpaceBar.ɵfac = function RuxIconSpaceBar_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSpaceBar)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSpaceBar.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSpaceBar,
  selectors: [["rux-icon-space-bar"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSpaceBar_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSpaceBar = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSpaceBar);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSpaceBar, [{
    type: Component,
    args: [{
      selector: "rux-icon-space-bar",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSpeaker = class RuxIconSpeaker2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSpeaker.ɵfac = function RuxIconSpeaker_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSpeaker)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSpeaker.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSpeaker,
  selectors: [["rux-icon-speaker"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSpeaker_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSpeaker = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSpeaker);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSpeaker, [{
    type: Component,
    args: [{
      selector: "rux-icon-speaker",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSpeakerGroup = class RuxIconSpeakerGroup2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSpeakerGroup.ɵfac = function RuxIconSpeakerGroup_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSpeakerGroup)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSpeakerGroup.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSpeakerGroup,
  selectors: [["rux-icon-speaker-group"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSpeakerGroup_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSpeakerGroup = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSpeakerGroup);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSpeakerGroup, [{
    type: Component,
    args: [{
      selector: "rux-icon-speaker-group",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSpeakerNotes = class RuxIconSpeakerNotes2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSpeakerNotes.ɵfac = function RuxIconSpeakerNotes_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSpeakerNotes)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSpeakerNotes.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSpeakerNotes,
  selectors: [["rux-icon-speaker-notes"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSpeakerNotes_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSpeakerNotes = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSpeakerNotes);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSpeakerNotes, [{
    type: Component,
    args: [{
      selector: "rux-icon-speaker-notes",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSpeakerNotesOff = class RuxIconSpeakerNotesOff2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSpeakerNotesOff.ɵfac = function RuxIconSpeakerNotesOff_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSpeakerNotesOff)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSpeakerNotesOff.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSpeakerNotesOff,
  selectors: [["rux-icon-speaker-notes-off"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSpeakerNotesOff_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSpeakerNotesOff = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSpeakerNotesOff);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSpeakerNotesOff, [{
    type: Component,
    args: [{
      selector: "rux-icon-speaker-notes-off",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSpeakerPhone = class RuxIconSpeakerPhone2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSpeakerPhone.ɵfac = function RuxIconSpeakerPhone_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSpeakerPhone)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSpeakerPhone.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSpeakerPhone,
  selectors: [["rux-icon-speaker-phone"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSpeakerPhone_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSpeakerPhone = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSpeakerPhone);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSpeakerPhone, [{
    type: Component,
    args: [{
      selector: "rux-icon-speaker-phone",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSpellcheck = class RuxIconSpellcheck2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSpellcheck.ɵfac = function RuxIconSpellcheck_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSpellcheck)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSpellcheck.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSpellcheck,
  selectors: [["rux-icon-spellcheck"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSpellcheck_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSpellcheck = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSpellcheck);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSpellcheck, [{
    type: Component,
    args: [{
      selector: "rux-icon-spellcheck",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconStar = class RuxIconStar2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconStar.ɵfac = function RuxIconStar_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconStar)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconStar.ɵcmp = ɵɵdefineComponent({
  type: RuxIconStar,
  selectors: [["rux-icon-star"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconStar_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconStar = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconStar);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconStar, [{
    type: Component,
    args: [{
      selector: "rux-icon-star",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconStarBorder = class RuxIconStarBorder2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconStarBorder.ɵfac = function RuxIconStarBorder_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconStarBorder)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconStarBorder.ɵcmp = ɵɵdefineComponent({
  type: RuxIconStarBorder,
  selectors: [["rux-icon-star-border"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconStarBorder_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconStarBorder = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconStarBorder);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconStarBorder, [{
    type: Component,
    args: [{
      selector: "rux-icon-star-border",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconStarHalf = class RuxIconStarHalf2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconStarHalf.ɵfac = function RuxIconStarHalf_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconStarHalf)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconStarHalf.ɵcmp = ɵɵdefineComponent({
  type: RuxIconStarHalf,
  selectors: [["rux-icon-star-half"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconStarHalf_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconStarHalf = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconStarHalf);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconStarHalf, [{
    type: Component,
    args: [{
      selector: "rux-icon-star-half",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconStarRate = class RuxIconStarRate2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconStarRate.ɵfac = function RuxIconStarRate_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconStarRate)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconStarRate.ɵcmp = ɵɵdefineComponent({
  type: RuxIconStarRate,
  selectors: [["rux-icon-star-rate"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconStarRate_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconStarRate = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconStarRate);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconStarRate, [{
    type: Component,
    args: [{
      selector: "rux-icon-star-rate",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconStars = class RuxIconStars2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconStars.ɵfac = function RuxIconStars_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconStars)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconStars.ɵcmp = ɵɵdefineComponent({
  type: RuxIconStars,
  selectors: [["rux-icon-stars"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconStars_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconStars = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconStars);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconStars, [{
    type: Component,
    args: [{
      selector: "rux-icon-stars",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconStayCurrentLandscape = class RuxIconStayCurrentLandscape2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconStayCurrentLandscape.ɵfac = function RuxIconStayCurrentLandscape_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconStayCurrentLandscape)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconStayCurrentLandscape.ɵcmp = ɵɵdefineComponent({
  type: RuxIconStayCurrentLandscape,
  selectors: [["rux-icon-stay-current-landscape"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconStayCurrentLandscape_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconStayCurrentLandscape = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconStayCurrentLandscape);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconStayCurrentLandscape, [{
    type: Component,
    args: [{
      selector: "rux-icon-stay-current-landscape",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconStayCurrentPortrait = class RuxIconStayCurrentPortrait2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconStayCurrentPortrait.ɵfac = function RuxIconStayCurrentPortrait_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconStayCurrentPortrait)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconStayCurrentPortrait.ɵcmp = ɵɵdefineComponent({
  type: RuxIconStayCurrentPortrait,
  selectors: [["rux-icon-stay-current-portrait"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconStayCurrentPortrait_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconStayCurrentPortrait = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconStayCurrentPortrait);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconStayCurrentPortrait, [{
    type: Component,
    args: [{
      selector: "rux-icon-stay-current-portrait",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconStayPrimaryLandscape = class RuxIconStayPrimaryLandscape2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconStayPrimaryLandscape.ɵfac = function RuxIconStayPrimaryLandscape_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconStayPrimaryLandscape)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconStayPrimaryLandscape.ɵcmp = ɵɵdefineComponent({
  type: RuxIconStayPrimaryLandscape,
  selectors: [["rux-icon-stay-primary-landscape"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconStayPrimaryLandscape_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconStayPrimaryLandscape = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconStayPrimaryLandscape);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconStayPrimaryLandscape, [{
    type: Component,
    args: [{
      selector: "rux-icon-stay-primary-landscape",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconStayPrimaryPortrait = class RuxIconStayPrimaryPortrait2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconStayPrimaryPortrait.ɵfac = function RuxIconStayPrimaryPortrait_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconStayPrimaryPortrait)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconStayPrimaryPortrait.ɵcmp = ɵɵdefineComponent({
  type: RuxIconStayPrimaryPortrait,
  selectors: [["rux-icon-stay-primary-portrait"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconStayPrimaryPortrait_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconStayPrimaryPortrait = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconStayPrimaryPortrait);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconStayPrimaryPortrait, [{
    type: Component,
    args: [{
      selector: "rux-icon-stay-primary-portrait",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconStop = class RuxIconStop2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconStop.ɵfac = function RuxIconStop_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconStop)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconStop.ɵcmp = ɵɵdefineComponent({
  type: RuxIconStop,
  selectors: [["rux-icon-stop"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconStop_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconStop = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconStop);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconStop, [{
    type: Component,
    args: [{
      selector: "rux-icon-stop",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconStopScreenShare = class RuxIconStopScreenShare2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconStopScreenShare.ɵfac = function RuxIconStopScreenShare_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconStopScreenShare)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconStopScreenShare.ɵcmp = ɵɵdefineComponent({
  type: RuxIconStopScreenShare,
  selectors: [["rux-icon-stop-screen-share"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconStopScreenShare_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconStopScreenShare = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconStopScreenShare);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconStopScreenShare, [{
    type: Component,
    args: [{
      selector: "rux-icon-stop-screen-share",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconStorage = class RuxIconStorage2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconStorage.ɵfac = function RuxIconStorage_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconStorage)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconStorage.ɵcmp = ɵɵdefineComponent({
  type: RuxIconStorage,
  selectors: [["rux-icon-storage"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconStorage_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconStorage = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconStorage);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconStorage, [{
    type: Component,
    args: [{
      selector: "rux-icon-storage",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconStore = class RuxIconStore2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconStore.ɵfac = function RuxIconStore_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconStore)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconStore.ɵcmp = ɵɵdefineComponent({
  type: RuxIconStore,
  selectors: [["rux-icon-store"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconStore_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconStore = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconStore);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconStore, [{
    type: Component,
    args: [{
      selector: "rux-icon-store",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconStoreMallDirectory = class RuxIconStoreMallDirectory2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconStoreMallDirectory.ɵfac = function RuxIconStoreMallDirectory_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconStoreMallDirectory)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconStoreMallDirectory.ɵcmp = ɵɵdefineComponent({
  type: RuxIconStoreMallDirectory,
  selectors: [["rux-icon-store-mall-directory"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconStoreMallDirectory_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconStoreMallDirectory = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconStoreMallDirectory);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconStoreMallDirectory, [{
    type: Component,
    args: [{
      selector: "rux-icon-store-mall-directory",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconStraighten = class RuxIconStraighten2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconStraighten.ɵfac = function RuxIconStraighten_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconStraighten)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconStraighten.ɵcmp = ɵɵdefineComponent({
  type: RuxIconStraighten,
  selectors: [["rux-icon-straighten"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconStraighten_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconStraighten = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconStraighten);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconStraighten, [{
    type: Component,
    args: [{
      selector: "rux-icon-straighten",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconStreetview = class RuxIconStreetview2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconStreetview.ɵfac = function RuxIconStreetview_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconStreetview)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconStreetview.ɵcmp = ɵɵdefineComponent({
  type: RuxIconStreetview,
  selectors: [["rux-icon-streetview"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconStreetview_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconStreetview = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconStreetview);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconStreetview, [{
    type: Component,
    args: [{
      selector: "rux-icon-streetview",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconStrikethroughS = class RuxIconStrikethroughS2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconStrikethroughS.ɵfac = function RuxIconStrikethroughS_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconStrikethroughS)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconStrikethroughS.ɵcmp = ɵɵdefineComponent({
  type: RuxIconStrikethroughS,
  selectors: [["rux-icon-strikethrough-s"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconStrikethroughS_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconStrikethroughS = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconStrikethroughS);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconStrikethroughS, [{
    type: Component,
    args: [{
      selector: "rux-icon-strikethrough-s",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconStyle = class RuxIconStyle2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconStyle.ɵfac = function RuxIconStyle_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconStyle)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconStyle.ɵcmp = ɵɵdefineComponent({
  type: RuxIconStyle,
  selectors: [["rux-icon-style"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconStyle_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconStyle = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconStyle);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconStyle, [{
    type: Component,
    args: [{
      selector: "rux-icon-style",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSubdirectoryArrowLeft = class RuxIconSubdirectoryArrowLeft2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSubdirectoryArrowLeft.ɵfac = function RuxIconSubdirectoryArrowLeft_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSubdirectoryArrowLeft)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSubdirectoryArrowLeft.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSubdirectoryArrowLeft,
  selectors: [["rux-icon-subdirectory-arrow-left"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSubdirectoryArrowLeft_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSubdirectoryArrowLeft = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSubdirectoryArrowLeft);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSubdirectoryArrowLeft, [{
    type: Component,
    args: [{
      selector: "rux-icon-subdirectory-arrow-left",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSubdirectoryArrowRight = class RuxIconSubdirectoryArrowRight2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSubdirectoryArrowRight.ɵfac = function RuxIconSubdirectoryArrowRight_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSubdirectoryArrowRight)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSubdirectoryArrowRight.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSubdirectoryArrowRight,
  selectors: [["rux-icon-subdirectory-arrow-right"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSubdirectoryArrowRight_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSubdirectoryArrowRight = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSubdirectoryArrowRight);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSubdirectoryArrowRight, [{
    type: Component,
    args: [{
      selector: "rux-icon-subdirectory-arrow-right",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSubject = class RuxIconSubject2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSubject.ɵfac = function RuxIconSubject_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSubject)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSubject.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSubject,
  selectors: [["rux-icon-subject"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSubject_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSubject = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSubject);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSubject, [{
    type: Component,
    args: [{
      selector: "rux-icon-subject",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSubscriptions = class RuxIconSubscriptions2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSubscriptions.ɵfac = function RuxIconSubscriptions_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSubscriptions)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSubscriptions.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSubscriptions,
  selectors: [["rux-icon-subscriptions"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSubscriptions_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSubscriptions = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSubscriptions);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSubscriptions, [{
    type: Component,
    args: [{
      selector: "rux-icon-subscriptions",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSubtitles = class RuxIconSubtitles2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSubtitles.ɵfac = function RuxIconSubtitles_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSubtitles)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSubtitles.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSubtitles,
  selectors: [["rux-icon-subtitles"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSubtitles_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSubtitles = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSubtitles);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSubtitles, [{
    type: Component,
    args: [{
      selector: "rux-icon-subtitles",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSubway = class RuxIconSubway2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSubway.ɵfac = function RuxIconSubway_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSubway)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSubway.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSubway,
  selectors: [["rux-icon-subway"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSubway_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSubway = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSubway);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSubway, [{
    type: Component,
    args: [{
      selector: "rux-icon-subway",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSupervisedUserCircle = class RuxIconSupervisedUserCircle2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSupervisedUserCircle.ɵfac = function RuxIconSupervisedUserCircle_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSupervisedUserCircle)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSupervisedUserCircle.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSupervisedUserCircle,
  selectors: [["rux-icon-supervised-user-circle"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSupervisedUserCircle_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSupervisedUserCircle = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSupervisedUserCircle);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSupervisedUserCircle, [{
    type: Component,
    args: [{
      selector: "rux-icon-supervised-user-circle",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSupervisorAccount = class RuxIconSupervisorAccount2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSupervisorAccount.ɵfac = function RuxIconSupervisorAccount_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSupervisorAccount)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSupervisorAccount.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSupervisorAccount,
  selectors: [["rux-icon-supervisor-account"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSupervisorAccount_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSupervisorAccount = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSupervisorAccount);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSupervisorAccount, [{
    type: Component,
    args: [{
      selector: "rux-icon-supervisor-account",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSurroundSound = class RuxIconSurroundSound2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSurroundSound.ɵfac = function RuxIconSurroundSound_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSurroundSound)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSurroundSound.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSurroundSound,
  selectors: [["rux-icon-surround-sound"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSurroundSound_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSurroundSound = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSurroundSound);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSurroundSound, [{
    type: Component,
    args: [{
      selector: "rux-icon-surround-sound",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSwapCalls = class RuxIconSwapCalls2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSwapCalls.ɵfac = function RuxIconSwapCalls_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSwapCalls)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSwapCalls.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSwapCalls,
  selectors: [["rux-icon-swap-calls"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSwapCalls_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSwapCalls = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSwapCalls);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSwapCalls, [{
    type: Component,
    args: [{
      selector: "rux-icon-swap-calls",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSwapHoriz = class RuxIconSwapHoriz2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSwapHoriz.ɵfac = function RuxIconSwapHoriz_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSwapHoriz)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSwapHoriz.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSwapHoriz,
  selectors: [["rux-icon-swap-horiz"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSwapHoriz_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSwapHoriz = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSwapHoriz);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSwapHoriz, [{
    type: Component,
    args: [{
      selector: "rux-icon-swap-horiz",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSwapHorizontalCircle = class RuxIconSwapHorizontalCircle2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSwapHorizontalCircle.ɵfac = function RuxIconSwapHorizontalCircle_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSwapHorizontalCircle)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSwapHorizontalCircle.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSwapHorizontalCircle,
  selectors: [["rux-icon-swap-horizontal-circle"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSwapHorizontalCircle_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSwapHorizontalCircle = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSwapHorizontalCircle);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSwapHorizontalCircle, [{
    type: Component,
    args: [{
      selector: "rux-icon-swap-horizontal-circle",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSwapVert = class RuxIconSwapVert2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSwapVert.ɵfac = function RuxIconSwapVert_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSwapVert)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSwapVert.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSwapVert,
  selectors: [["rux-icon-swap-vert"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSwapVert_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSwapVert = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSwapVert);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSwapVert, [{
    type: Component,
    args: [{
      selector: "rux-icon-swap-vert",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSwapVerticalCircle = class RuxIconSwapVerticalCircle2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSwapVerticalCircle.ɵfac = function RuxIconSwapVerticalCircle_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSwapVerticalCircle)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSwapVerticalCircle.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSwapVerticalCircle,
  selectors: [["rux-icon-swap-vertical-circle"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSwapVerticalCircle_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSwapVerticalCircle = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSwapVerticalCircle);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSwapVerticalCircle, [{
    type: Component,
    args: [{
      selector: "rux-icon-swap-vertical-circle",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSwitchCamera = class RuxIconSwitchCamera2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSwitchCamera.ɵfac = function RuxIconSwitchCamera_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSwitchCamera)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSwitchCamera.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSwitchCamera,
  selectors: [["rux-icon-switch-camera"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSwitchCamera_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSwitchCamera = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSwitchCamera);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSwitchCamera, [{
    type: Component,
    args: [{
      selector: "rux-icon-switch-camera",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSwitchVideo = class RuxIconSwitchVideo2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSwitchVideo.ɵfac = function RuxIconSwitchVideo_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSwitchVideo)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSwitchVideo.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSwitchVideo,
  selectors: [["rux-icon-switch-video"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSwitchVideo_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSwitchVideo = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSwitchVideo);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSwitchVideo, [{
    type: Component,
    args: [{
      selector: "rux-icon-switch-video",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSync = class RuxIconSync2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSync.ɵfac = function RuxIconSync_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSync)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSync.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSync,
  selectors: [["rux-icon-sync"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSync_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSync = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSync);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSync, [{
    type: Component,
    args: [{
      selector: "rux-icon-sync",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSyncDisabled = class RuxIconSyncDisabled2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSyncDisabled.ɵfac = function RuxIconSyncDisabled_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSyncDisabled)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSyncDisabled.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSyncDisabled,
  selectors: [["rux-icon-sync-disabled"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSyncDisabled_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSyncDisabled = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSyncDisabled);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSyncDisabled, [{
    type: Component,
    args: [{
      selector: "rux-icon-sync-disabled",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSyncProblem = class RuxIconSyncProblem2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSyncProblem.ɵfac = function RuxIconSyncProblem_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSyncProblem)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSyncProblem.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSyncProblem,
  selectors: [["rux-icon-sync-problem"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSyncProblem_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSyncProblem = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSyncProblem);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSyncProblem, [{
    type: Component,
    args: [{
      selector: "rux-icon-sync-problem",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconSystemUpdate = class RuxIconSystemUpdate2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconSystemUpdate.ɵfac = function RuxIconSystemUpdate_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconSystemUpdate)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconSystemUpdate.ɵcmp = ɵɵdefineComponent({
  type: RuxIconSystemUpdate,
  selectors: [["rux-icon-system-update"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconSystemUpdate_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconSystemUpdate = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconSystemUpdate);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconSystemUpdate, [{
    type: Component,
    args: [{
      selector: "rux-icon-system-update",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTab = class RuxIconTab2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTab.ɵfac = function RuxIconTab_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTab)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTab.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTab,
  selectors: [["rux-icon-tab"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTab_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTab = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTab);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTab, [{
    type: Component,
    args: [{
      selector: "rux-icon-tab",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTabUnselected = class RuxIconTabUnselected2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTabUnselected.ɵfac = function RuxIconTabUnselected_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTabUnselected)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTabUnselected.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTabUnselected,
  selectors: [["rux-icon-tab-unselected"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTabUnselected_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTabUnselected = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTabUnselected);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTabUnselected, [{
    type: Component,
    args: [{
      selector: "rux-icon-tab-unselected",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTableChart = class RuxIconTableChart2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTableChart.ɵfac = function RuxIconTableChart_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTableChart)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTableChart.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTableChart,
  selectors: [["rux-icon-table-chart"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTableChart_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTableChart = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTableChart);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTableChart, [{
    type: Component,
    args: [{
      selector: "rux-icon-table-chart",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTablet = class RuxIconTablet2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTablet.ɵfac = function RuxIconTablet_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTablet)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTablet.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTablet,
  selectors: [["rux-icon-tablet"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTablet_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTablet = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTablet);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTablet, [{
    type: Component,
    args: [{
      selector: "rux-icon-tablet",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTabletAndroid = class RuxIconTabletAndroid2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTabletAndroid.ɵfac = function RuxIconTabletAndroid_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTabletAndroid)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTabletAndroid.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTabletAndroid,
  selectors: [["rux-icon-tablet-android"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTabletAndroid_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTabletAndroid = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTabletAndroid);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTabletAndroid, [{
    type: Component,
    args: [{
      selector: "rux-icon-tablet-android",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTabletMac = class RuxIconTabletMac2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTabletMac.ɵfac = function RuxIconTabletMac_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTabletMac)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTabletMac.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTabletMac,
  selectors: [["rux-icon-tablet-mac"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTabletMac_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTabletMac = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTabletMac);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTabletMac, [{
    type: Component,
    args: [{
      selector: "rux-icon-tablet-mac",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTagFaces = class RuxIconTagFaces2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTagFaces.ɵfac = function RuxIconTagFaces_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTagFaces)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTagFaces.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTagFaces,
  selectors: [["rux-icon-tag-faces"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTagFaces_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTagFaces = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTagFaces);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTagFaces, [{
    type: Component,
    args: [{
      selector: "rux-icon-tag-faces",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTapAndPlay = class RuxIconTapAndPlay2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTapAndPlay.ɵfac = function RuxIconTapAndPlay_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTapAndPlay)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTapAndPlay.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTapAndPlay,
  selectors: [["rux-icon-tap-and-play"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTapAndPlay_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTapAndPlay = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTapAndPlay);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTapAndPlay, [{
    type: Component,
    args: [{
      selector: "rux-icon-tap-and-play",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTerrain = class RuxIconTerrain2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTerrain.ɵfac = function RuxIconTerrain_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTerrain)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTerrain.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTerrain,
  selectors: [["rux-icon-terrain"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTerrain_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTerrain = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTerrain);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTerrain, [{
    type: Component,
    args: [{
      selector: "rux-icon-terrain",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTextFields = class RuxIconTextFields2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTextFields.ɵfac = function RuxIconTextFields_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTextFields)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTextFields.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTextFields,
  selectors: [["rux-icon-text-fields"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTextFields_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTextFields = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTextFields);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTextFields, [{
    type: Component,
    args: [{
      selector: "rux-icon-text-fields",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTextFormat = class RuxIconTextFormat2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTextFormat.ɵfac = function RuxIconTextFormat_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTextFormat)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTextFormat.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTextFormat,
  selectors: [["rux-icon-text-format"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTextFormat_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTextFormat = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTextFormat);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTextFormat, [{
    type: Component,
    args: [{
      selector: "rux-icon-text-format",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTextRotateUp = class RuxIconTextRotateUp2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTextRotateUp.ɵfac = function RuxIconTextRotateUp_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTextRotateUp)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTextRotateUp.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTextRotateUp,
  selectors: [["rux-icon-text-rotate-up"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTextRotateUp_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTextRotateUp = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTextRotateUp);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTextRotateUp, [{
    type: Component,
    args: [{
      selector: "rux-icon-text-rotate-up",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTextRotateVertical = class RuxIconTextRotateVertical2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTextRotateVertical.ɵfac = function RuxIconTextRotateVertical_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTextRotateVertical)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTextRotateVertical.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTextRotateVertical,
  selectors: [["rux-icon-text-rotate-vertical"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTextRotateVertical_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTextRotateVertical = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTextRotateVertical);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTextRotateVertical, [{
    type: Component,
    args: [{
      selector: "rux-icon-text-rotate-vertical",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTextRotationNone = class RuxIconTextRotationNone2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTextRotationNone.ɵfac = function RuxIconTextRotationNone_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTextRotationNone)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTextRotationNone.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTextRotationNone,
  selectors: [["rux-icon-text-rotation-none"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTextRotationNone_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTextRotationNone = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTextRotationNone);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTextRotationNone, [{
    type: Component,
    args: [{
      selector: "rux-icon-text-rotation-none",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTextsms = class RuxIconTextsms2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTextsms.ɵfac = function RuxIconTextsms_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTextsms)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTextsms.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTextsms,
  selectors: [["rux-icon-textsms"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTextsms_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTextsms = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTextsms);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTextsms, [{
    type: Component,
    args: [{
      selector: "rux-icon-textsms",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTexture = class RuxIconTexture2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTexture.ɵfac = function RuxIconTexture_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTexture)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTexture.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTexture,
  selectors: [["rux-icon-texture"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTexture_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTexture = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTexture);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTexture, [{
    type: Component,
    args: [{
      selector: "rux-icon-texture",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTheaters = class RuxIconTheaters2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTheaters.ɵfac = function RuxIconTheaters_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTheaters)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTheaters.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTheaters,
  selectors: [["rux-icon-theaters"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTheaters_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTheaters = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTheaters);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTheaters, [{
    type: Component,
    args: [{
      selector: "rux-icon-theaters",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconThermal = class RuxIconThermal2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconThermal.ɵfac = function RuxIconThermal_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconThermal)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconThermal.ɵcmp = ɵɵdefineComponent({
  type: RuxIconThermal,
  selectors: [["rux-icon-thermal"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconThermal_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconThermal = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconThermal);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconThermal, [{
    type: Component,
    args: [{
      selector: "rux-icon-thermal",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconThumbDown = class RuxIconThumbDown2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconThumbDown.ɵfac = function RuxIconThumbDown_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconThumbDown)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconThumbDown.ɵcmp = ɵɵdefineComponent({
  type: RuxIconThumbDown,
  selectors: [["rux-icon-thumb-down"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconThumbDown_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconThumbDown = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconThumbDown);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconThumbDown, [{
    type: Component,
    args: [{
      selector: "rux-icon-thumb-down",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconThumbDownAlt = class RuxIconThumbDownAlt2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconThumbDownAlt.ɵfac = function RuxIconThumbDownAlt_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconThumbDownAlt)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconThumbDownAlt.ɵcmp = ɵɵdefineComponent({
  type: RuxIconThumbDownAlt,
  selectors: [["rux-icon-thumb-down-alt"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconThumbDownAlt_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconThumbDownAlt = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconThumbDownAlt);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconThumbDownAlt, [{
    type: Component,
    args: [{
      selector: "rux-icon-thumb-down-alt",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconThumbUp = class RuxIconThumbUp2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconThumbUp.ɵfac = function RuxIconThumbUp_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconThumbUp)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconThumbUp.ɵcmp = ɵɵdefineComponent({
  type: RuxIconThumbUp,
  selectors: [["rux-icon-thumb-up"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconThumbUp_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconThumbUp = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconThumbUp);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconThumbUp, [{
    type: Component,
    args: [{
      selector: "rux-icon-thumb-up",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconThumbUpAlt = class RuxIconThumbUpAlt2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconThumbUpAlt.ɵfac = function RuxIconThumbUpAlt_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconThumbUpAlt)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconThumbUpAlt.ɵcmp = ɵɵdefineComponent({
  type: RuxIconThumbUpAlt,
  selectors: [["rux-icon-thumb-up-alt"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconThumbUpAlt_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconThumbUpAlt = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconThumbUpAlt);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconThumbUpAlt, [{
    type: Component,
    args: [{
      selector: "rux-icon-thumb-up-alt",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconThumbsUpDown = class RuxIconThumbsUpDown2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconThumbsUpDown.ɵfac = function RuxIconThumbsUpDown_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconThumbsUpDown)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconThumbsUpDown.ɵcmp = ɵɵdefineComponent({
  type: RuxIconThumbsUpDown,
  selectors: [["rux-icon-thumbs-up-down"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconThumbsUpDown_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconThumbsUpDown = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconThumbsUpDown);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconThumbsUpDown, [{
    type: Component,
    args: [{
      selector: "rux-icon-thumbs-up-down",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTimeToLeave = class RuxIconTimeToLeave2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTimeToLeave.ɵfac = function RuxIconTimeToLeave_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTimeToLeave)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTimeToLeave.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTimeToLeave,
  selectors: [["rux-icon-time-to-leave"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTimeToLeave_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTimeToLeave = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTimeToLeave);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTimeToLeave, [{
    type: Component,
    args: [{
      selector: "rux-icon-time-to-leave",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTimelapse = class RuxIconTimelapse2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTimelapse.ɵfac = function RuxIconTimelapse_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTimelapse)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTimelapse.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTimelapse,
  selectors: [["rux-icon-timelapse"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTimelapse_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTimelapse = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTimelapse);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTimelapse, [{
    type: Component,
    args: [{
      selector: "rux-icon-timelapse",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTimeline = class RuxIconTimeline2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTimeline.ɵfac = function RuxIconTimeline_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTimeline)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTimeline.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTimeline,
  selectors: [["rux-icon-timeline"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTimeline_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTimeline = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTimeline);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTimeline, [{
    type: Component,
    args: [{
      selector: "rux-icon-timeline",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTimer = class RuxIconTimer2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTimer.ɵfac = function RuxIconTimer_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTimer)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTimer.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTimer,
  selectors: [["rux-icon-timer"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTimer_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTimer = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTimer);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTimer, [{
    type: Component,
    args: [{
      selector: "rux-icon-timer",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTimer10 = class RuxIconTimer102 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTimer10.ɵfac = function RuxIconTimer10_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTimer10)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTimer10.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTimer10,
  selectors: [["rux-icon-timer-10"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTimer10_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTimer10 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTimer10);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTimer10, [{
    type: Component,
    args: [{
      selector: "rux-icon-timer-10",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTimer3 = class RuxIconTimer32 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTimer3.ɵfac = function RuxIconTimer3_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTimer3)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTimer3.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTimer3,
  selectors: [["rux-icon-timer-3"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTimer3_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTimer3 = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTimer3);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTimer3, [{
    type: Component,
    args: [{
      selector: "rux-icon-timer-3",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTimerOff = class RuxIconTimerOff2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTimerOff.ɵfac = function RuxIconTimerOff_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTimerOff)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTimerOff.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTimerOff,
  selectors: [["rux-icon-timer-off"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTimerOff_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTimerOff = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTimerOff);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTimerOff, [{
    type: Component,
    args: [{
      selector: "rux-icon-timer-off",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTitle = class RuxIconTitle2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTitle.ɵfac = function RuxIconTitle_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTitle)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTitle.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTitle,
  selectors: [["rux-icon-title"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTitle_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTitle = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTitle);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTitle, [{
    type: Component,
    args: [{
      selector: "rux-icon-title",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconToc = class RuxIconToc2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconToc.ɵfac = function RuxIconToc_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconToc)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconToc.ɵcmp = ɵɵdefineComponent({
  type: RuxIconToc,
  selectors: [["rux-icon-toc"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconToc_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconToc = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconToc);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconToc, [{
    type: Component,
    args: [{
      selector: "rux-icon-toc",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconToday = class RuxIconToday2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconToday.ɵfac = function RuxIconToday_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconToday)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconToday.ɵcmp = ɵɵdefineComponent({
  type: RuxIconToday,
  selectors: [["rux-icon-today"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconToday_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconToday = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconToday);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconToday, [{
    type: Component,
    args: [{
      selector: "rux-icon-today",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconToggleOff = class RuxIconToggleOff2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconToggleOff.ɵfac = function RuxIconToggleOff_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconToggleOff)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconToggleOff.ɵcmp = ɵɵdefineComponent({
  type: RuxIconToggleOff,
  selectors: [["rux-icon-toggle-off"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconToggleOff_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconToggleOff = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconToggleOff);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconToggleOff, [{
    type: Component,
    args: [{
      selector: "rux-icon-toggle-off",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconToggleOn = class RuxIconToggleOn2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconToggleOn.ɵfac = function RuxIconToggleOn_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconToggleOn)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconToggleOn.ɵcmp = ɵɵdefineComponent({
  type: RuxIconToggleOn,
  selectors: [["rux-icon-toggle-on"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconToggleOn_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconToggleOn = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconToggleOn);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconToggleOn, [{
    type: Component,
    args: [{
      selector: "rux-icon-toggle-on",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconToll = class RuxIconToll2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconToll.ɵfac = function RuxIconToll_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconToll)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconToll.ɵcmp = ɵɵdefineComponent({
  type: RuxIconToll,
  selectors: [["rux-icon-toll"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconToll_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconToll = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconToll);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconToll, [{
    type: Component,
    args: [{
      selector: "rux-icon-toll",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTonality = class RuxIconTonality2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTonality.ɵfac = function RuxIconTonality_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTonality)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTonality.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTonality,
  selectors: [["rux-icon-tonality"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTonality_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTonality = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTonality);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTonality, [{
    type: Component,
    args: [{
      selector: "rux-icon-tonality",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTouchApp = class RuxIconTouchApp2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTouchApp.ɵfac = function RuxIconTouchApp_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTouchApp)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTouchApp.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTouchApp,
  selectors: [["rux-icon-touch-app"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTouchApp_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTouchApp = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTouchApp);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTouchApp, [{
    type: Component,
    args: [{
      selector: "rux-icon-touch-app",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconToys = class RuxIconToys2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconToys.ɵfac = function RuxIconToys_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconToys)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconToys.ɵcmp = ɵɵdefineComponent({
  type: RuxIconToys,
  selectors: [["rux-icon-toys"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconToys_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconToys = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconToys);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconToys, [{
    type: Component,
    args: [{
      selector: "rux-icon-toys",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTrackChanges = class RuxIconTrackChanges2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTrackChanges.ɵfac = function RuxIconTrackChanges_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTrackChanges)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTrackChanges.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTrackChanges,
  selectors: [["rux-icon-track-changes"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTrackChanges_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTrackChanges = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTrackChanges);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTrackChanges, [{
    type: Component,
    args: [{
      selector: "rux-icon-track-changes",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTraffic = class RuxIconTraffic2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTraffic.ɵfac = function RuxIconTraffic_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTraffic)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTraffic.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTraffic,
  selectors: [["rux-icon-traffic"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTraffic_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTraffic = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTraffic);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTraffic, [{
    type: Component,
    args: [{
      selector: "rux-icon-traffic",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTrain = class RuxIconTrain2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTrain.ɵfac = function RuxIconTrain_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTrain)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTrain.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTrain,
  selectors: [["rux-icon-train"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTrain_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTrain = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTrain);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTrain, [{
    type: Component,
    args: [{
      selector: "rux-icon-train",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTram = class RuxIconTram2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTram.ɵfac = function RuxIconTram_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTram)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTram.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTram,
  selectors: [["rux-icon-tram"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTram_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTram = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTram);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTram, [{
    type: Component,
    args: [{
      selector: "rux-icon-tram",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTransferWithinAStation = class RuxIconTransferWithinAStation2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTransferWithinAStation.ɵfac = function RuxIconTransferWithinAStation_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTransferWithinAStation)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTransferWithinAStation.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTransferWithinAStation,
  selectors: [["rux-icon-transfer-within-a-station"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTransferWithinAStation_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTransferWithinAStation = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTransferWithinAStation);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTransferWithinAStation, [{
    type: Component,
    args: [{
      selector: "rux-icon-transfer-within-a-station",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTransform = class RuxIconTransform2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTransform.ɵfac = function RuxIconTransform_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTransform)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTransform.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTransform,
  selectors: [["rux-icon-transform"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTransform_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTransform = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTransform);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTransform, [{
    type: Component,
    args: [{
      selector: "rux-icon-transform",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTransitEnterexit = class RuxIconTransitEnterexit2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTransitEnterexit.ɵfac = function RuxIconTransitEnterexit_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTransitEnterexit)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTransitEnterexit.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTransitEnterexit,
  selectors: [["rux-icon-transit-enterexit"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTransitEnterexit_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTransitEnterexit = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTransitEnterexit);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTransitEnterexit, [{
    type: Component,
    args: [{
      selector: "rux-icon-transit-enterexit",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTranslate = class RuxIconTranslate2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTranslate.ɵfac = function RuxIconTranslate_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTranslate)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTranslate.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTranslate,
  selectors: [["rux-icon-translate"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTranslate_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTranslate = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTranslate);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTranslate, [{
    type: Component,
    args: [{
      selector: "rux-icon-translate",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTrendingDown = class RuxIconTrendingDown2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTrendingDown.ɵfac = function RuxIconTrendingDown_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTrendingDown)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTrendingDown.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTrendingDown,
  selectors: [["rux-icon-trending-down"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTrendingDown_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTrendingDown = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTrendingDown);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTrendingDown, [{
    type: Component,
    args: [{
      selector: "rux-icon-trending-down",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTrendingFlat = class RuxIconTrendingFlat2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTrendingFlat.ɵfac = function RuxIconTrendingFlat_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTrendingFlat)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTrendingFlat.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTrendingFlat,
  selectors: [["rux-icon-trending-flat"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTrendingFlat_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTrendingFlat = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTrendingFlat);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTrendingFlat, [{
    type: Component,
    args: [{
      selector: "rux-icon-trending-flat",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTrendingUp = class RuxIconTrendingUp2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTrendingUp.ɵfac = function RuxIconTrendingUp_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTrendingUp)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTrendingUp.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTrendingUp,
  selectors: [["rux-icon-trending-up"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTrendingUp_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTrendingUp = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTrendingUp);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTrendingUp, [{
    type: Component,
    args: [{
      selector: "rux-icon-trending-up",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTripOrigin = class RuxIconTripOrigin2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTripOrigin.ɵfac = function RuxIconTripOrigin_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTripOrigin)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTripOrigin.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTripOrigin,
  selectors: [["rux-icon-trip-origin"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTripOrigin_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTripOrigin = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTripOrigin);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTripOrigin, [{
    type: Component,
    args: [{
      selector: "rux-icon-trip-origin",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTune = class RuxIconTune2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTune.ɵfac = function RuxIconTune_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTune)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTune.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTune,
  selectors: [["rux-icon-tune"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTune_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTune = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTune);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTune, [{
    type: Component,
    args: [{
      selector: "rux-icon-tune",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTurnedIn = class RuxIconTurnedIn2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTurnedIn.ɵfac = function RuxIconTurnedIn_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTurnedIn)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTurnedIn.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTurnedIn,
  selectors: [["rux-icon-turned-in"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTurnedIn_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTurnedIn = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTurnedIn);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTurnedIn, [{
    type: Component,
    args: [{
      selector: "rux-icon-turned-in",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTurnedInNot = class RuxIconTurnedInNot2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTurnedInNot.ɵfac = function RuxIconTurnedInNot_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTurnedInNot)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTurnedInNot.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTurnedInNot,
  selectors: [["rux-icon-turned-in-not"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTurnedInNot_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTurnedInNot = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTurnedInNot);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTurnedInNot, [{
    type: Component,
    args: [{
      selector: "rux-icon-turned-in-not",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTv = class RuxIconTv2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTv.ɵfac = function RuxIconTv_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTv)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTv.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTv,
  selectors: [["rux-icon-tv"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTv_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTv = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTv);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTv, [{
    type: Component,
    args: [{
      selector: "rux-icon-tv",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconTvOff = class RuxIconTvOff2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconTvOff.ɵfac = function RuxIconTvOff_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconTvOff)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconTvOff.ɵcmp = ɵɵdefineComponent({
  type: RuxIconTvOff,
  selectors: [["rux-icon-tv-off"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconTvOff_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconTvOff = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconTvOff);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconTvOff, [{
    type: Component,
    args: [{
      selector: "rux-icon-tv-off",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconUnarchive = class RuxIconUnarchive2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconUnarchive.ɵfac = function RuxIconUnarchive_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconUnarchive)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconUnarchive.ɵcmp = ɵɵdefineComponent({
  type: RuxIconUnarchive,
  selectors: [["rux-icon-unarchive"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconUnarchive_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconUnarchive = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconUnarchive);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconUnarchive, [{
    type: Component,
    args: [{
      selector: "rux-icon-unarchive",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconUndo = class RuxIconUndo2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconUndo.ɵfac = function RuxIconUndo_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconUndo)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconUndo.ɵcmp = ɵɵdefineComponent({
  type: RuxIconUndo,
  selectors: [["rux-icon-undo"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconUndo_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconUndo = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconUndo);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconUndo, [{
    type: Component,
    args: [{
      selector: "rux-icon-undo",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconUnfoldLess = class RuxIconUnfoldLess2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconUnfoldLess.ɵfac = function RuxIconUnfoldLess_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconUnfoldLess)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconUnfoldLess.ɵcmp = ɵɵdefineComponent({
  type: RuxIconUnfoldLess,
  selectors: [["rux-icon-unfold-less"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconUnfoldLess_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconUnfoldLess = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconUnfoldLess);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconUnfoldLess, [{
    type: Component,
    args: [{
      selector: "rux-icon-unfold-less",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconUnfoldMore = class RuxIconUnfoldMore2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconUnfoldMore.ɵfac = function RuxIconUnfoldMore_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconUnfoldMore)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconUnfoldMore.ɵcmp = ɵɵdefineComponent({
  type: RuxIconUnfoldMore,
  selectors: [["rux-icon-unfold-more"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconUnfoldMore_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconUnfoldMore = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconUnfoldMore);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconUnfoldMore, [{
    type: Component,
    args: [{
      selector: "rux-icon-unfold-more",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconUnsubscribe = class RuxIconUnsubscribe2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconUnsubscribe.ɵfac = function RuxIconUnsubscribe_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconUnsubscribe)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconUnsubscribe.ɵcmp = ɵɵdefineComponent({
  type: RuxIconUnsubscribe,
  selectors: [["rux-icon-unsubscribe"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconUnsubscribe_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconUnsubscribe = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconUnsubscribe);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconUnsubscribe, [{
    type: Component,
    args: [{
      selector: "rux-icon-unsubscribe",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconUpdate = class RuxIconUpdate2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconUpdate.ɵfac = function RuxIconUpdate_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconUpdate)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconUpdate.ɵcmp = ɵɵdefineComponent({
  type: RuxIconUpdate,
  selectors: [["rux-icon-update"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconUpdate_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconUpdate = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconUpdate);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconUpdate, [{
    type: Component,
    args: [{
      selector: "rux-icon-update",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconUsb = class RuxIconUsb2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconUsb.ɵfac = function RuxIconUsb_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconUsb)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconUsb.ɵcmp = ɵɵdefineComponent({
  type: RuxIconUsb,
  selectors: [["rux-icon-usb"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconUsb_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconUsb = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconUsb);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconUsb, [{
    type: Component,
    args: [{
      selector: "rux-icon-usb",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconVerifiedUser = class RuxIconVerifiedUser2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconVerifiedUser.ɵfac = function RuxIconVerifiedUser_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconVerifiedUser)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconVerifiedUser.ɵcmp = ɵɵdefineComponent({
  type: RuxIconVerifiedUser,
  selectors: [["rux-icon-verified-user"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconVerifiedUser_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconVerifiedUser = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconVerifiedUser);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconVerifiedUser, [{
    type: Component,
    args: [{
      selector: "rux-icon-verified-user",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconVerticalAlignBottom = class RuxIconVerticalAlignBottom2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconVerticalAlignBottom.ɵfac = function RuxIconVerticalAlignBottom_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconVerticalAlignBottom)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconVerticalAlignBottom.ɵcmp = ɵɵdefineComponent({
  type: RuxIconVerticalAlignBottom,
  selectors: [["rux-icon-vertical-align-bottom"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconVerticalAlignBottom_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconVerticalAlignBottom = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconVerticalAlignBottom);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconVerticalAlignBottom, [{
    type: Component,
    args: [{
      selector: "rux-icon-vertical-align-bottom",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconVerticalAlignCenter = class RuxIconVerticalAlignCenter2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconVerticalAlignCenter.ɵfac = function RuxIconVerticalAlignCenter_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconVerticalAlignCenter)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconVerticalAlignCenter.ɵcmp = ɵɵdefineComponent({
  type: RuxIconVerticalAlignCenter,
  selectors: [["rux-icon-vertical-align-center"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconVerticalAlignCenter_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconVerticalAlignCenter = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconVerticalAlignCenter);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconVerticalAlignCenter, [{
    type: Component,
    args: [{
      selector: "rux-icon-vertical-align-center",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconVerticalAlignTop = class RuxIconVerticalAlignTop2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconVerticalAlignTop.ɵfac = function RuxIconVerticalAlignTop_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconVerticalAlignTop)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconVerticalAlignTop.ɵcmp = ɵɵdefineComponent({
  type: RuxIconVerticalAlignTop,
  selectors: [["rux-icon-vertical-align-top"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconVerticalAlignTop_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconVerticalAlignTop = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconVerticalAlignTop);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconVerticalAlignTop, [{
    type: Component,
    args: [{
      selector: "rux-icon-vertical-align-top",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconVerticalSplit = class RuxIconVerticalSplit2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconVerticalSplit.ɵfac = function RuxIconVerticalSplit_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconVerticalSplit)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconVerticalSplit.ɵcmp = ɵɵdefineComponent({
  type: RuxIconVerticalSplit,
  selectors: [["rux-icon-vertical-split"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconVerticalSplit_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconVerticalSplit = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconVerticalSplit);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconVerticalSplit, [{
    type: Component,
    args: [{
      selector: "rux-icon-vertical-split",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconVibration = class RuxIconVibration2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconVibration.ɵfac = function RuxIconVibration_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconVibration)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconVibration.ɵcmp = ɵɵdefineComponent({
  type: RuxIconVibration,
  selectors: [["rux-icon-vibration"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconVibration_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconVibration = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconVibration);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconVibration, [{
    type: Component,
    args: [{
      selector: "rux-icon-vibration",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconVideoCall = class RuxIconVideoCall2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconVideoCall.ɵfac = function RuxIconVideoCall_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconVideoCall)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconVideoCall.ɵcmp = ɵɵdefineComponent({
  type: RuxIconVideoCall,
  selectors: [["rux-icon-video-call"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconVideoCall_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconVideoCall = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconVideoCall);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconVideoCall, [{
    type: Component,
    args: [{
      selector: "rux-icon-video-call",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconVideoLabel = class RuxIconVideoLabel2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconVideoLabel.ɵfac = function RuxIconVideoLabel_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconVideoLabel)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconVideoLabel.ɵcmp = ɵɵdefineComponent({
  type: RuxIconVideoLabel,
  selectors: [["rux-icon-video-label"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconVideoLabel_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconVideoLabel = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconVideoLabel);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconVideoLabel, [{
    type: Component,
    args: [{
      selector: "rux-icon-video-label",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconVideoLibrary = class RuxIconVideoLibrary2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconVideoLibrary.ɵfac = function RuxIconVideoLibrary_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconVideoLibrary)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconVideoLibrary.ɵcmp = ɵɵdefineComponent({
  type: RuxIconVideoLibrary,
  selectors: [["rux-icon-video-library"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconVideoLibrary_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconVideoLibrary = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconVideoLibrary);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconVideoLibrary, [{
    type: Component,
    args: [{
      selector: "rux-icon-video-library",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconVideocam = class RuxIconVideocam2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconVideocam.ɵfac = function RuxIconVideocam_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconVideocam)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconVideocam.ɵcmp = ɵɵdefineComponent({
  type: RuxIconVideocam,
  selectors: [["rux-icon-videocam"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconVideocam_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconVideocam = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconVideocam);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconVideocam, [{
    type: Component,
    args: [{
      selector: "rux-icon-videocam",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconVideocamOff = class RuxIconVideocamOff2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconVideocamOff.ɵfac = function RuxIconVideocamOff_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconVideocamOff)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconVideocamOff.ɵcmp = ɵɵdefineComponent({
  type: RuxIconVideocamOff,
  selectors: [["rux-icon-videocam-off"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconVideocamOff_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconVideocamOff = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconVideocamOff);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconVideocamOff, [{
    type: Component,
    args: [{
      selector: "rux-icon-videocam-off",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconVideogameAsset = class RuxIconVideogameAsset2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconVideogameAsset.ɵfac = function RuxIconVideogameAsset_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconVideogameAsset)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconVideogameAsset.ɵcmp = ɵɵdefineComponent({
  type: RuxIconVideogameAsset,
  selectors: [["rux-icon-videogame-asset"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconVideogameAsset_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconVideogameAsset = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconVideogameAsset);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconVideogameAsset, [{
    type: Component,
    args: [{
      selector: "rux-icon-videogame-asset",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconViewAgenda = class RuxIconViewAgenda2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconViewAgenda.ɵfac = function RuxIconViewAgenda_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconViewAgenda)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconViewAgenda.ɵcmp = ɵɵdefineComponent({
  type: RuxIconViewAgenda,
  selectors: [["rux-icon-view-agenda"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconViewAgenda_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconViewAgenda = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconViewAgenda);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconViewAgenda, [{
    type: Component,
    args: [{
      selector: "rux-icon-view-agenda",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconViewArray = class RuxIconViewArray2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconViewArray.ɵfac = function RuxIconViewArray_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconViewArray)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconViewArray.ɵcmp = ɵɵdefineComponent({
  type: RuxIconViewArray,
  selectors: [["rux-icon-view-array"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconViewArray_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconViewArray = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconViewArray);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconViewArray, [{
    type: Component,
    args: [{
      selector: "rux-icon-view-array",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconViewCarousel = class RuxIconViewCarousel2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconViewCarousel.ɵfac = function RuxIconViewCarousel_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconViewCarousel)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconViewCarousel.ɵcmp = ɵɵdefineComponent({
  type: RuxIconViewCarousel,
  selectors: [["rux-icon-view-carousel"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconViewCarousel_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconViewCarousel = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconViewCarousel);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconViewCarousel, [{
    type: Component,
    args: [{
      selector: "rux-icon-view-carousel",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconViewColumn = class RuxIconViewColumn2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconViewColumn.ɵfac = function RuxIconViewColumn_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconViewColumn)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconViewColumn.ɵcmp = ɵɵdefineComponent({
  type: RuxIconViewColumn,
  selectors: [["rux-icon-view-column"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconViewColumn_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconViewColumn = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconViewColumn);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconViewColumn, [{
    type: Component,
    args: [{
      selector: "rux-icon-view-column",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconViewComfy = class RuxIconViewComfy2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconViewComfy.ɵfac = function RuxIconViewComfy_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconViewComfy)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconViewComfy.ɵcmp = ɵɵdefineComponent({
  type: RuxIconViewComfy,
  selectors: [["rux-icon-view-comfy"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconViewComfy_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconViewComfy = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconViewComfy);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconViewComfy, [{
    type: Component,
    args: [{
      selector: "rux-icon-view-comfy",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconViewCompact = class RuxIconViewCompact2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconViewCompact.ɵfac = function RuxIconViewCompact_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconViewCompact)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconViewCompact.ɵcmp = ɵɵdefineComponent({
  type: RuxIconViewCompact,
  selectors: [["rux-icon-view-compact"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconViewCompact_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconViewCompact = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconViewCompact);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconViewCompact, [{
    type: Component,
    args: [{
      selector: "rux-icon-view-compact",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconViewDay = class RuxIconViewDay2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconViewDay.ɵfac = function RuxIconViewDay_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconViewDay)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconViewDay.ɵcmp = ɵɵdefineComponent({
  type: RuxIconViewDay,
  selectors: [["rux-icon-view-day"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconViewDay_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconViewDay = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconViewDay);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconViewDay, [{
    type: Component,
    args: [{
      selector: "rux-icon-view-day",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconViewHeadline = class RuxIconViewHeadline2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconViewHeadline.ɵfac = function RuxIconViewHeadline_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconViewHeadline)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconViewHeadline.ɵcmp = ɵɵdefineComponent({
  type: RuxIconViewHeadline,
  selectors: [["rux-icon-view-headline"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconViewHeadline_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconViewHeadline = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconViewHeadline);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconViewHeadline, [{
    type: Component,
    args: [{
      selector: "rux-icon-view-headline",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconViewList = class RuxIconViewList2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconViewList.ɵfac = function RuxIconViewList_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconViewList)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconViewList.ɵcmp = ɵɵdefineComponent({
  type: RuxIconViewList,
  selectors: [["rux-icon-view-list"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconViewList_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconViewList = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconViewList);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconViewList, [{
    type: Component,
    args: [{
      selector: "rux-icon-view-list",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconViewModule = class RuxIconViewModule2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconViewModule.ɵfac = function RuxIconViewModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconViewModule)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconViewModule.ɵcmp = ɵɵdefineComponent({
  type: RuxIconViewModule,
  selectors: [["rux-icon-view-module"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconViewModule_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconViewModule = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconViewModule);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconViewModule, [{
    type: Component,
    args: [{
      selector: "rux-icon-view-module",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconViewQuilt = class RuxIconViewQuilt2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconViewQuilt.ɵfac = function RuxIconViewQuilt_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconViewQuilt)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconViewQuilt.ɵcmp = ɵɵdefineComponent({
  type: RuxIconViewQuilt,
  selectors: [["rux-icon-view-quilt"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconViewQuilt_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconViewQuilt = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconViewQuilt);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconViewQuilt, [{
    type: Component,
    args: [{
      selector: "rux-icon-view-quilt",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconViewStream = class RuxIconViewStream2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconViewStream.ɵfac = function RuxIconViewStream_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconViewStream)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconViewStream.ɵcmp = ɵɵdefineComponent({
  type: RuxIconViewStream,
  selectors: [["rux-icon-view-stream"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconViewStream_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconViewStream = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconViewStream);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconViewStream, [{
    type: Component,
    args: [{
      selector: "rux-icon-view-stream",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconViewWeek = class RuxIconViewWeek2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconViewWeek.ɵfac = function RuxIconViewWeek_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconViewWeek)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconViewWeek.ɵcmp = ɵɵdefineComponent({
  type: RuxIconViewWeek,
  selectors: [["rux-icon-view-week"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconViewWeek_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconViewWeek = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconViewWeek);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconViewWeek, [{
    type: Component,
    args: [{
      selector: "rux-icon-view-week",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconVignette = class RuxIconVignette2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconVignette.ɵfac = function RuxIconVignette_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconVignette)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconVignette.ɵcmp = ɵɵdefineComponent({
  type: RuxIconVignette,
  selectors: [["rux-icon-vignette"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconVignette_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconVignette = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconVignette);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconVignette, [{
    type: Component,
    args: [{
      selector: "rux-icon-vignette",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconVisibility = class RuxIconVisibility2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconVisibility.ɵfac = function RuxIconVisibility_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconVisibility)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconVisibility.ɵcmp = ɵɵdefineComponent({
  type: RuxIconVisibility,
  selectors: [["rux-icon-visibility"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconVisibility_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconVisibility = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconVisibility);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconVisibility, [{
    type: Component,
    args: [{
      selector: "rux-icon-visibility",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconVisibilityOff = class RuxIconVisibilityOff2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconVisibilityOff.ɵfac = function RuxIconVisibilityOff_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconVisibilityOff)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconVisibilityOff.ɵcmp = ɵɵdefineComponent({
  type: RuxIconVisibilityOff,
  selectors: [["rux-icon-visibility-off"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconVisibilityOff_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconVisibilityOff = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconVisibilityOff);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconVisibilityOff, [{
    type: Component,
    args: [{
      selector: "rux-icon-visibility-off",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconVoiceChat = class RuxIconVoiceChat2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconVoiceChat.ɵfac = function RuxIconVoiceChat_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconVoiceChat)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconVoiceChat.ɵcmp = ɵɵdefineComponent({
  type: RuxIconVoiceChat,
  selectors: [["rux-icon-voice-chat"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconVoiceChat_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconVoiceChat = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconVoiceChat);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconVoiceChat, [{
    type: Component,
    args: [{
      selector: "rux-icon-voice-chat",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconVoiceOverOff = class RuxIconVoiceOverOff2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconVoiceOverOff.ɵfac = function RuxIconVoiceOverOff_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconVoiceOverOff)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconVoiceOverOff.ɵcmp = ɵɵdefineComponent({
  type: RuxIconVoiceOverOff,
  selectors: [["rux-icon-voice-over-off"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconVoiceOverOff_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconVoiceOverOff = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconVoiceOverOff);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconVoiceOverOff, [{
    type: Component,
    args: [{
      selector: "rux-icon-voice-over-off",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconVoicemail = class RuxIconVoicemail2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconVoicemail.ɵfac = function RuxIconVoicemail_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconVoicemail)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconVoicemail.ɵcmp = ɵɵdefineComponent({
  type: RuxIconVoicemail,
  selectors: [["rux-icon-voicemail"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconVoicemail_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconVoicemail = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconVoicemail);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconVoicemail, [{
    type: Component,
    args: [{
      selector: "rux-icon-voicemail",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconVolumeDown = class RuxIconVolumeDown2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconVolumeDown.ɵfac = function RuxIconVolumeDown_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconVolumeDown)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconVolumeDown.ɵcmp = ɵɵdefineComponent({
  type: RuxIconVolumeDown,
  selectors: [["rux-icon-volume-down"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconVolumeDown_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconVolumeDown = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconVolumeDown);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconVolumeDown, [{
    type: Component,
    args: [{
      selector: "rux-icon-volume-down",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconVolumeMute = class RuxIconVolumeMute2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconVolumeMute.ɵfac = function RuxIconVolumeMute_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconVolumeMute)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconVolumeMute.ɵcmp = ɵɵdefineComponent({
  type: RuxIconVolumeMute,
  selectors: [["rux-icon-volume-mute"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconVolumeMute_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconVolumeMute = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconVolumeMute);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconVolumeMute, [{
    type: Component,
    args: [{
      selector: "rux-icon-volume-mute",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconVolumeOff = class RuxIconVolumeOff2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconVolumeOff.ɵfac = function RuxIconVolumeOff_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconVolumeOff)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconVolumeOff.ɵcmp = ɵɵdefineComponent({
  type: RuxIconVolumeOff,
  selectors: [["rux-icon-volume-off"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconVolumeOff_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconVolumeOff = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconVolumeOff);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconVolumeOff, [{
    type: Component,
    args: [{
      selector: "rux-icon-volume-off",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconVolumeUp = class RuxIconVolumeUp2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconVolumeUp.ɵfac = function RuxIconVolumeUp_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconVolumeUp)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconVolumeUp.ɵcmp = ɵɵdefineComponent({
  type: RuxIconVolumeUp,
  selectors: [["rux-icon-volume-up"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconVolumeUp_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconVolumeUp = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconVolumeUp);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconVolumeUp, [{
    type: Component,
    args: [{
      selector: "rux-icon-volume-up",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconVpnKey = class RuxIconVpnKey2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconVpnKey.ɵfac = function RuxIconVpnKey_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconVpnKey)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconVpnKey.ɵcmp = ɵɵdefineComponent({
  type: RuxIconVpnKey,
  selectors: [["rux-icon-vpn-key"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconVpnKey_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconVpnKey = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconVpnKey);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconVpnKey, [{
    type: Component,
    args: [{
      selector: "rux-icon-vpn-key",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconVpnLock = class RuxIconVpnLock2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconVpnLock.ɵfac = function RuxIconVpnLock_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconVpnLock)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconVpnLock.ɵcmp = ɵɵdefineComponent({
  type: RuxIconVpnLock,
  selectors: [["rux-icon-vpn-lock"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconVpnLock_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconVpnLock = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconVpnLock);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconVpnLock, [{
    type: Component,
    args: [{
      selector: "rux-icon-vpn-lock",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconWallpaper = class RuxIconWallpaper2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconWallpaper.ɵfac = function RuxIconWallpaper_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconWallpaper)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconWallpaper.ɵcmp = ɵɵdefineComponent({
  type: RuxIconWallpaper,
  selectors: [["rux-icon-wallpaper"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconWallpaper_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconWallpaper = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconWallpaper);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconWallpaper, [{
    type: Component,
    args: [{
      selector: "rux-icon-wallpaper",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconWarning = class RuxIconWarning2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconWarning.ɵfac = function RuxIconWarning_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconWarning)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconWarning.ɵcmp = ɵɵdefineComponent({
  type: RuxIconWarning,
  selectors: [["rux-icon-warning"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconWarning_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconWarning = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconWarning);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconWarning, [{
    type: Component,
    args: [{
      selector: "rux-icon-warning",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconWatch = class RuxIconWatch2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconWatch.ɵfac = function RuxIconWatch_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconWatch)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconWatch.ɵcmp = ɵɵdefineComponent({
  type: RuxIconWatch,
  selectors: [["rux-icon-watch"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconWatch_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconWatch = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconWatch);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconWatch, [{
    type: Component,
    args: [{
      selector: "rux-icon-watch",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconWatchLater = class RuxIconWatchLater2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconWatchLater.ɵfac = function RuxIconWatchLater_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconWatchLater)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconWatchLater.ɵcmp = ɵɵdefineComponent({
  type: RuxIconWatchLater,
  selectors: [["rux-icon-watch-later"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconWatchLater_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconWatchLater = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconWatchLater);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconWatchLater, [{
    type: Component,
    args: [{
      selector: "rux-icon-watch-later",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconWaves = class RuxIconWaves2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconWaves.ɵfac = function RuxIconWaves_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconWaves)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconWaves.ɵcmp = ɵɵdefineComponent({
  type: RuxIconWaves,
  selectors: [["rux-icon-waves"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconWaves_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconWaves = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconWaves);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconWaves, [{
    type: Component,
    args: [{
      selector: "rux-icon-waves",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconWbAuto = class RuxIconWbAuto2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconWbAuto.ɵfac = function RuxIconWbAuto_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconWbAuto)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconWbAuto.ɵcmp = ɵɵdefineComponent({
  type: RuxIconWbAuto,
  selectors: [["rux-icon-wb-auto"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconWbAuto_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconWbAuto = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconWbAuto);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconWbAuto, [{
    type: Component,
    args: [{
      selector: "rux-icon-wb-auto",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconWbCloudy = class RuxIconWbCloudy2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconWbCloudy.ɵfac = function RuxIconWbCloudy_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconWbCloudy)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconWbCloudy.ɵcmp = ɵɵdefineComponent({
  type: RuxIconWbCloudy,
  selectors: [["rux-icon-wb-cloudy"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconWbCloudy_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconWbCloudy = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconWbCloudy);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconWbCloudy, [{
    type: Component,
    args: [{
      selector: "rux-icon-wb-cloudy",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconWbIncandescent = class RuxIconWbIncandescent2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconWbIncandescent.ɵfac = function RuxIconWbIncandescent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconWbIncandescent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconWbIncandescent.ɵcmp = ɵɵdefineComponent({
  type: RuxIconWbIncandescent,
  selectors: [["rux-icon-wb-incandescent"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconWbIncandescent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconWbIncandescent = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconWbIncandescent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconWbIncandescent, [{
    type: Component,
    args: [{
      selector: "rux-icon-wb-incandescent",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconWbIridescent = class RuxIconWbIridescent2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconWbIridescent.ɵfac = function RuxIconWbIridescent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconWbIridescent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconWbIridescent.ɵcmp = ɵɵdefineComponent({
  type: RuxIconWbIridescent,
  selectors: [["rux-icon-wb-iridescent"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconWbIridescent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconWbIridescent = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconWbIridescent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconWbIridescent, [{
    type: Component,
    args: [{
      selector: "rux-icon-wb-iridescent",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconWbSunny = class RuxIconWbSunny2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconWbSunny.ɵfac = function RuxIconWbSunny_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconWbSunny)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconWbSunny.ɵcmp = ɵɵdefineComponent({
  type: RuxIconWbSunny,
  selectors: [["rux-icon-wb-sunny"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconWbSunny_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconWbSunny = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconWbSunny);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconWbSunny, [{
    type: Component,
    args: [{
      selector: "rux-icon-wb-sunny",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconWc = class RuxIconWc2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconWc.ɵfac = function RuxIconWc_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconWc)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconWc.ɵcmp = ɵɵdefineComponent({
  type: RuxIconWc,
  selectors: [["rux-icon-wc"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconWc_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconWc = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconWc);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconWc, [{
    type: Component,
    args: [{
      selector: "rux-icon-wc",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconWeb = class RuxIconWeb2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconWeb.ɵfac = function RuxIconWeb_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconWeb)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconWeb.ɵcmp = ɵɵdefineComponent({
  type: RuxIconWeb,
  selectors: [["rux-icon-web"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconWeb_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconWeb = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconWeb);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconWeb, [{
    type: Component,
    args: [{
      selector: "rux-icon-web",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconWebAsset = class RuxIconWebAsset2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconWebAsset.ɵfac = function RuxIconWebAsset_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconWebAsset)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconWebAsset.ɵcmp = ɵɵdefineComponent({
  type: RuxIconWebAsset,
  selectors: [["rux-icon-web-asset"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconWebAsset_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconWebAsset = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconWebAsset);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconWebAsset, [{
    type: Component,
    args: [{
      selector: "rux-icon-web-asset",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconWeekend = class RuxIconWeekend2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconWeekend.ɵfac = function RuxIconWeekend_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconWeekend)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconWeekend.ɵcmp = ɵɵdefineComponent({
  type: RuxIconWeekend,
  selectors: [["rux-icon-weekend"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconWeekend_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconWeekend = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconWeekend);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconWeekend, [{
    type: Component,
    args: [{
      selector: "rux-icon-weekend",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconWhatshot = class RuxIconWhatshot2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconWhatshot.ɵfac = function RuxIconWhatshot_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconWhatshot)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconWhatshot.ɵcmp = ɵɵdefineComponent({
  type: RuxIconWhatshot,
  selectors: [["rux-icon-whatshot"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconWhatshot_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconWhatshot = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconWhatshot);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconWhatshot, [{
    type: Component,
    args: [{
      selector: "rux-icon-whatshot",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconWhereToVote = class RuxIconWhereToVote2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconWhereToVote.ɵfac = function RuxIconWhereToVote_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconWhereToVote)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconWhereToVote.ɵcmp = ɵɵdefineComponent({
  type: RuxIconWhereToVote,
  selectors: [["rux-icon-where-to-vote"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconWhereToVote_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconWhereToVote = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconWhereToVote);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconWhereToVote, [{
    type: Component,
    args: [{
      selector: "rux-icon-where-to-vote",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconWidgets = class RuxIconWidgets2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconWidgets.ɵfac = function RuxIconWidgets_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconWidgets)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconWidgets.ɵcmp = ɵɵdefineComponent({
  type: RuxIconWidgets,
  selectors: [["rux-icon-widgets"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconWidgets_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconWidgets = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconWidgets);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconWidgets, [{
    type: Component,
    args: [{
      selector: "rux-icon-widgets",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconWifi = class RuxIconWifi2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconWifi.ɵfac = function RuxIconWifi_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconWifi)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconWifi.ɵcmp = ɵɵdefineComponent({
  type: RuxIconWifi,
  selectors: [["rux-icon-wifi"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconWifi_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconWifi = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconWifi);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconWifi, [{
    type: Component,
    args: [{
      selector: "rux-icon-wifi",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconWifiLock = class RuxIconWifiLock2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconWifiLock.ɵfac = function RuxIconWifiLock_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconWifiLock)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconWifiLock.ɵcmp = ɵɵdefineComponent({
  type: RuxIconWifiLock,
  selectors: [["rux-icon-wifi-lock"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconWifiLock_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconWifiLock = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconWifiLock);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconWifiLock, [{
    type: Component,
    args: [{
      selector: "rux-icon-wifi-lock",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconWifiOff = class RuxIconWifiOff2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconWifiOff.ɵfac = function RuxIconWifiOff_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconWifiOff)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconWifiOff.ɵcmp = ɵɵdefineComponent({
  type: RuxIconWifiOff,
  selectors: [["rux-icon-wifi-off"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconWifiOff_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconWifiOff = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconWifiOff);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconWifiOff, [{
    type: Component,
    args: [{
      selector: "rux-icon-wifi-off",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconWifiTethering = class RuxIconWifiTethering2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconWifiTethering.ɵfac = function RuxIconWifiTethering_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconWifiTethering)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconWifiTethering.ɵcmp = ɵɵdefineComponent({
  type: RuxIconWifiTethering,
  selectors: [["rux-icon-wifi-tethering"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconWifiTethering_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconWifiTethering = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconWifiTethering);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconWifiTethering, [{
    type: Component,
    args: [{
      selector: "rux-icon-wifi-tethering",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconWork = class RuxIconWork2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconWork.ɵfac = function RuxIconWork_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconWork)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconWork.ɵcmp = ɵɵdefineComponent({
  type: RuxIconWork,
  selectors: [["rux-icon-work"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconWork_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconWork = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconWork);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconWork, [{
    type: Component,
    args: [{
      selector: "rux-icon-work",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconWorkOff = class RuxIconWorkOff2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconWorkOff.ɵfac = function RuxIconWorkOff_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconWorkOff)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconWorkOff.ɵcmp = ɵɵdefineComponent({
  type: RuxIconWorkOff,
  selectors: [["rux-icon-work-off"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconWorkOff_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconWorkOff = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconWorkOff);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconWorkOff, [{
    type: Component,
    args: [{
      selector: "rux-icon-work-off",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconWorkOutline = class RuxIconWorkOutline2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconWorkOutline.ɵfac = function RuxIconWorkOutline_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconWorkOutline)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconWorkOutline.ɵcmp = ɵɵdefineComponent({
  type: RuxIconWorkOutline,
  selectors: [["rux-icon-work-outline"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconWorkOutline_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconWorkOutline = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconWorkOutline);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconWorkOutline, [{
    type: Component,
    args: [{
      selector: "rux-icon-work-outline",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconWrapText = class RuxIconWrapText2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconWrapText.ɵfac = function RuxIconWrapText_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconWrapText)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconWrapText.ɵcmp = ɵɵdefineComponent({
  type: RuxIconWrapText,
  selectors: [["rux-icon-wrap-text"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconWrapText_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconWrapText = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconWrapText);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconWrapText, [{
    type: Component,
    args: [{
      selector: "rux-icon-wrap-text",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconYoutubeSearchedFor = class RuxIconYoutubeSearchedFor2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconYoutubeSearchedFor.ɵfac = function RuxIconYoutubeSearchedFor_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconYoutubeSearchedFor)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconYoutubeSearchedFor.ɵcmp = ɵɵdefineComponent({
  type: RuxIconYoutubeSearchedFor,
  selectors: [["rux-icon-youtube-searched-for"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconYoutubeSearchedFor_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconYoutubeSearchedFor = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconYoutubeSearchedFor);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconYoutubeSearchedFor, [{
    type: Component,
    args: [{
      selector: "rux-icon-youtube-searched-for",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconZoomIn = class RuxIconZoomIn2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconZoomIn.ɵfac = function RuxIconZoomIn_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconZoomIn)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconZoomIn.ɵcmp = ɵɵdefineComponent({
  type: RuxIconZoomIn,
  selectors: [["rux-icon-zoom-in"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconZoomIn_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconZoomIn = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconZoomIn);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconZoomIn, [{
    type: Component,
    args: [{
      selector: "rux-icon-zoom-in",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconZoomInMap = class RuxIconZoomInMap2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconZoomInMap.ɵfac = function RuxIconZoomInMap_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconZoomInMap)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconZoomInMap.ɵcmp = ɵɵdefineComponent({
  type: RuxIconZoomInMap,
  selectors: [["rux-icon-zoom-in-map"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconZoomInMap_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconZoomInMap = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconZoomInMap);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconZoomInMap, [{
    type: Component,
    args: [{
      selector: "rux-icon-zoom-in-map",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconZoomOut = class RuxIconZoomOut2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconZoomOut.ɵfac = function RuxIconZoomOut_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconZoomOut)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconZoomOut.ɵcmp = ɵɵdefineComponent({
  type: RuxIconZoomOut,
  selectors: [["rux-icon-zoom-out"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconZoomOut_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconZoomOut = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconZoomOut);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconZoomOut, [{
    type: Component,
    args: [{
      selector: "rux-icon-zoom-out",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIconZoomOutMap = class RuxIconZoomOutMap2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIconZoomOutMap.ɵfac = function RuxIconZoomOutMap_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIconZoomOutMap)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIconZoomOutMap.ɵcmp = ɵɵdefineComponent({
  type: RuxIconZoomOutMap,
  selectors: [["rux-icon-zoom-out-map"]],
  inputs: {
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIconZoomOutMap_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIconZoomOutMap = __decorate([ProxyCmp({
  inputs: ["size"]
})], RuxIconZoomOutMap);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIconZoomOutMap, [{
    type: Component,
    args: [{
      selector: "rux-icon-zoom-out-map",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxIndeterminateProgress = class RuxIndeterminateProgress2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxIndeterminateProgress.ɵfac = function RuxIndeterminateProgress_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxIndeterminateProgress)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxIndeterminateProgress.ɵcmp = ɵɵdefineComponent({
  type: RuxIndeterminateProgress,
  selectors: [["rux-indeterminate-progress"]],
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxIndeterminateProgress_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxIndeterminateProgress = __decorate([ProxyCmp({})], RuxIndeterminateProgress);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxIndeterminateProgress, [{
    type: Component,
    args: [{
      selector: "rux-indeterminate-progress",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: []
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxInput = class RuxInput2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
    proxyOutputs(this, this.el, ["ruxchange", "ruxinput", "ruxblur", "ruxfocus"]);
  }
};
RuxInput.ɵfac = function RuxInput_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxInput)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxInput.ɵcmp = ɵɵdefineComponent({
  type: RuxInput,
  selectors: [["rux-input"]],
  inputs: {
    autocomplete: "autocomplete",
    disabled: "disabled",
    errorText: "errorText",
    helpText: "helpText",
    invalid: "invalid",
    label: "label",
    max: "max",
    min: "min",
    name: "name",
    placeholder: "placeholder",
    readonly: "readonly",
    required: "required",
    size: "size",
    spellcheck: "spellcheck",
    step: "step",
    type: "type",
    value: "value"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxInput_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxInput = __decorate([ProxyCmp({
  inputs: ["autocomplete", "disabled", "errorText", "helpText", "invalid", "label", "max", "min", "name", "placeholder", "readonly", "required", "size", "spellcheck", "step", "type", "value"],
  methods: ["setFocus", "getInput"]
})], RuxInput);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxInput, [{
    type: Component,
    args: [{
      selector: "rux-input",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["autocomplete", "disabled", "errorText", "helpText", "invalid", "label", "max", "min", "name", "placeholder", "readonly", "required", "size", "spellcheck", "step", "type", "value"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxLog = class RuxLog2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxLog.ɵfac = function RuxLog_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxLog)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxLog.ɵcmp = ɵɵdefineComponent({
  type: RuxLog,
  selectors: [["rux-log"]],
  inputs: {
    data: "data",
    filter: "filter",
    timezone: "timezone"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxLog_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxLog = __decorate([ProxyCmp({
  inputs: ["data", "filter", "timezone"]
})], RuxLog);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxLog, [{
    type: Component,
    args: [{
      selector: "rux-log",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["data", "filter", "timezone"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxMenu = class RuxMenu2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
    proxyOutputs(this, this.el, ["ruxmenuselected"]);
  }
};
RuxMenu.ɵfac = function RuxMenu_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxMenu)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxMenu.ɵcmp = ɵɵdefineComponent({
  type: RuxMenu,
  selectors: [["rux-menu"]],
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxMenu_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxMenu = __decorate([ProxyCmp({})], RuxMenu);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxMenu, [{
    type: Component,
    args: [{
      selector: "rux-menu",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: []
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxMenuItem = class RuxMenuItem2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxMenuItem.ɵfac = function RuxMenuItem_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxMenuItem)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxMenuItem.ɵcmp = ɵɵdefineComponent({
  type: RuxMenuItem,
  selectors: [["rux-menu-item"]],
  inputs: {
    disabled: "disabled",
    download: "download",
    href: "href",
    rel: "rel",
    selected: "selected",
    target: "target",
    value: "value"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxMenuItem_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxMenuItem = __decorate([ProxyCmp({
  inputs: ["disabled", "download", "href", "rel", "selected", "target", "value"]
})], RuxMenuItem);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxMenuItem, [{
    type: Component,
    args: [{
      selector: "rux-menu-item",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["disabled", "download", "href", "rel", "selected", "target", "value"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxMenuItemDivider = class RuxMenuItemDivider2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxMenuItemDivider.ɵfac = function RuxMenuItemDivider_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxMenuItemDivider)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxMenuItemDivider.ɵcmp = ɵɵdefineComponent({
  type: RuxMenuItemDivider,
  selectors: [["rux-menu-item-divider"]],
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxMenuItemDivider_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxMenuItemDivider = __decorate([ProxyCmp({})], RuxMenuItemDivider);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxMenuItemDivider, [{
    type: Component,
    args: [{
      selector: "rux-menu-item-divider",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: []
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxMonitoringIcon = class RuxMonitoringIcon2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxMonitoringIcon.ɵfac = function RuxMonitoringIcon_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxMonitoringIcon)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxMonitoringIcon.ɵcmp = ɵɵdefineComponent({
  type: RuxMonitoringIcon,
  selectors: [["rux-monitoring-icon"]],
  inputs: {
    icon: "icon",
    label: "label",
    notifications: "notifications",
    size: "size",
    status: "status",
    sublabel: "sublabel"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxMonitoringIcon_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxMonitoringIcon = __decorate([ProxyCmp({
  inputs: ["icon", "label", "notifications", "size", "status", "sublabel"]
})], RuxMonitoringIcon);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxMonitoringIcon, [{
    type: Component,
    args: [{
      selector: "rux-monitoring-icon",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["icon", "label", "notifications", "size", "status", "sublabel"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxMonitoringProgressIcon = class RuxMonitoringProgressIcon2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxMonitoringProgressIcon.ɵfac = function RuxMonitoringProgressIcon_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxMonitoringProgressIcon)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxMonitoringProgressIcon.ɵcmp = ɵɵdefineComponent({
  type: RuxMonitoringProgressIcon,
  selectors: [["rux-monitoring-progress-icon"]],
  inputs: {
    label: "label",
    max: "max",
    min: "min",
    notifications: "notifications",
    progress: "progress",
    range: "range",
    sublabel: "sublabel"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxMonitoringProgressIcon_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxMonitoringProgressIcon = __decorate([ProxyCmp({
  inputs: ["label", "max", "min", "notifications", "progress", "range", "sublabel"]
})], RuxMonitoringProgressIcon);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxMonitoringProgressIcon, [{
    type: Component,
    args: [{
      selector: "rux-monitoring-progress-icon",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["label", "max", "min", "notifications", "progress", "range", "sublabel"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxNotification = class RuxNotification2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
    proxyOutputs(this, this.el, ["ruxclosed"]);
  }
};
RuxNotification.ɵfac = function RuxNotification_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxNotification)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxNotification.ɵcmp = ɵɵdefineComponent({
  type: RuxNotification,
  selectors: [["rux-notification"]],
  inputs: {
    closeAfter: "closeAfter",
    hideClose: "hideClose",
    message: "message",
    open: "open",
    small: "small",
    status: "status"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxNotification_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxNotification = __decorate([ProxyCmp({
  inputs: ["closeAfter", "hideClose", "message", "open", "small", "status"]
})], RuxNotification);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxNotification, [{
    type: Component,
    args: [{
      selector: "rux-notification",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["closeAfter", "hideClose", "message", "open", "small", "status"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxOption = class RuxOption2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxOption.ɵfac = function RuxOption_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxOption)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxOption.ɵcmp = ɵɵdefineComponent({
  type: RuxOption,
  selectors: [["rux-option"]],
  inputs: {
    disabled: "disabled",
    label: "label",
    value: "value"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxOption_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxOption = __decorate([ProxyCmp({
  inputs: ["disabled", "label", "value"]
})], RuxOption);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxOption, [{
    type: Component,
    args: [{
      selector: "rux-option",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["disabled", "label", "value"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxOptionGroup = class RuxOptionGroup2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxOptionGroup.ɵfac = function RuxOptionGroup_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxOptionGroup)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxOptionGroup.ɵcmp = ɵɵdefineComponent({
  type: RuxOptionGroup,
  selectors: [["rux-option-group"]],
  inputs: {
    label: "label"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxOptionGroup_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxOptionGroup = __decorate([ProxyCmp({
  inputs: ["label"]
})], RuxOptionGroup);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxOptionGroup, [{
    type: Component,
    args: [{
      selector: "rux-option-group",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["label"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxPopUp = class RuxPopUp2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
    proxyOutputs(this, this.el, ["ruxpopupopened", "ruxpopupclosed"]);
  }
};
RuxPopUp.ɵfac = function RuxPopUp_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxPopUp)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxPopUp.ɵcmp = ɵɵdefineComponent({
  type: RuxPopUp,
  selectors: [["rux-pop-up"]],
  inputs: {
    closeOnSelect: "closeOnSelect",
    disableAutoUpdate: "disableAutoUpdate",
    enableAnimationFrame: "enableAnimationFrame",
    open: "open",
    placement: "placement",
    strategy: "strategy"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxPopUp_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxPopUp = __decorate([ProxyCmp({
  inputs: ["closeOnSelect", "disableAutoUpdate", "enableAnimationFrame", "open", "placement", "strategy"],
  methods: ["show", "hide"]
})], RuxPopUp);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxPopUp, [{
    type: Component,
    args: [{
      selector: "rux-pop-up",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["closeOnSelect", "disableAutoUpdate", "enableAnimationFrame", "open", "placement", "strategy"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxProgress = class RuxProgress2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxProgress.ɵfac = function RuxProgress_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxProgress)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxProgress.ɵcmp = ɵɵdefineComponent({
  type: RuxProgress,
  selectors: [["rux-progress"]],
  inputs: {
    hideLabel: "hideLabel",
    max: "max",
    value: "value"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxProgress_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxProgress = __decorate([ProxyCmp({
  inputs: ["hideLabel", "max", "value"]
})], RuxProgress);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxProgress, [{
    type: Component,
    args: [{
      selector: "rux-progress",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["hideLabel", "max", "value"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxPushButton = class RuxPushButton2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
    proxyOutputs(this, this.el, ["ruxchange", "ruxblur"]);
  }
};
RuxPushButton.ɵfac = function RuxPushButton_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxPushButton)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxPushButton.ɵcmp = ɵɵdefineComponent({
  type: RuxPushButton,
  selectors: [["rux-push-button"]],
  inputs: {
    checked: "checked",
    disabled: "disabled",
    icon: "icon",
    iconOnly: "iconOnly",
    label: "label",
    name: "name",
    size: "size",
    value: "value"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxPushButton_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxPushButton = __decorate([ProxyCmp({
  inputs: ["checked", "disabled", "icon", "iconOnly", "label", "name", "size", "value"]
})], RuxPushButton);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxPushButton, [{
    type: Component,
    args: [{
      selector: "rux-push-button",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["checked", "disabled", "icon", "iconOnly", "label", "name", "size", "value"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxRadio = class RuxRadio2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
    proxyOutputs(this, this.el, ["ruxblur"]);
  }
};
RuxRadio.ɵfac = function RuxRadio_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxRadio)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxRadio.ɵcmp = ɵɵdefineComponent({
  type: RuxRadio,
  selectors: [["rux-radio"]],
  inputs: {
    checked: "checked",
    disabled: "disabled",
    label: "label",
    name: "name",
    value: "value"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxRadio_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxRadio = __decorate([ProxyCmp({
  inputs: ["checked", "disabled", "label", "name", "value"]
})], RuxRadio);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxRadio, [{
    type: Component,
    args: [{
      selector: "rux-radio",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["checked", "disabled", "label", "name", "value"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxRadioGroup = class RuxRadioGroup2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
    proxyOutputs(this, this.el, ["ruxchange"]);
  }
};
RuxRadioGroup.ɵfac = function RuxRadioGroup_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxRadioGroup)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxRadioGroup.ɵcmp = ɵɵdefineComponent({
  type: RuxRadioGroup,
  selectors: [["rux-radio-group"]],
  inputs: {
    errorText: "errorText",
    helpText: "helpText",
    invalid: "invalid",
    label: "label",
    name: "name",
    required: "required",
    value: "value"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxRadioGroup_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxRadioGroup = __decorate([ProxyCmp({
  inputs: ["errorText", "helpText", "invalid", "label", "name", "required", "value"]
})], RuxRadioGroup);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxRadioGroup, [{
    type: Component,
    args: [{
      selector: "rux-radio-group",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["errorText", "helpText", "invalid", "label", "name", "required", "value"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxRuler = class RuxRuler2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxRuler.ɵfac = function RuxRuler_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxRuler)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxRuler.ɵcmp = ɵɵdefineComponent({
  type: RuxRuler,
  selectors: [["rux-ruler"]],
  inputs: {
    showStartOfDay: "showStartOfDay"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxRuler_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxRuler = __decorate([ProxyCmp({
  inputs: ["showStartOfDay"]
})], RuxRuler);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxRuler, [{
    type: Component,
    args: [{
      selector: "rux-ruler",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["showStartOfDay"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxSegmentedButton = class RuxSegmentedButton2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
    proxyOutputs(this, this.el, ["ruxchange"]);
  }
};
RuxSegmentedButton.ɵfac = function RuxSegmentedButton_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxSegmentedButton)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxSegmentedButton.ɵcmp = ɵɵdefineComponent({
  type: RuxSegmentedButton,
  selectors: [["rux-segmented-button"]],
  inputs: {
    data: "data",
    disabled: "disabled",
    selected: "selected",
    size: "size"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxSegmentedButton_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxSegmentedButton = __decorate([ProxyCmp({
  inputs: ["data", "disabled", "selected", "size"]
})], RuxSegmentedButton);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxSegmentedButton, [{
    type: Component,
    args: [{
      selector: "rux-segmented-button",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["data", "disabled", "selected", "size"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxSelect = class RuxSelect2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
    proxyOutputs(this, this.el, ["ruxchange", "ruxblur"]);
  }
};
RuxSelect.ɵfac = function RuxSelect_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxSelect)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxSelect.ɵcmp = ɵɵdefineComponent({
  type: RuxSelect,
  selectors: [["rux-select"]],
  inputs: {
    disabled: "disabled",
    errorText: "errorText",
    helpText: "helpText",
    inline: "inline",
    inputId: "inputId",
    invalid: "invalid",
    label: "label",
    labelId: "labelId",
    multiple: "multiple",
    name: "name",
    required: "required",
    size: "size",
    value: "value"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxSelect_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxSelect = __decorate([ProxyCmp({
  inputs: ["disabled", "errorText", "helpText", "inline", "inputId", "invalid", "label", "labelId", "multiple", "name", "required", "size", "value"],
  methods: ["setFocus"]
})], RuxSelect);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxSelect, [{
    type: Component,
    args: [{
      selector: "rux-select",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["disabled", "errorText", "helpText", "inline", "inputId", "invalid", "label", "labelId", "multiple", "name", "required", "size", "value"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxSlider = class RuxSlider2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
    proxyOutputs(this, this.el, ["ruxinput", "ruxblur", "ruxchange"]);
  }
};
RuxSlider.ɵfac = function RuxSlider_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxSlider)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxSlider.ɵcmp = ɵɵdefineComponent({
  type: RuxSlider,
  selectors: [["rux-slider"]],
  inputs: {
    axisLabels: "axisLabels",
    disabled: "disabled",
    errorText: "errorText",
    helpText: "helpText",
    label: "label",
    max: "max",
    min: "min",
    minVal: "minVal",
    name: "name",
    step: "step",
    strict: "strict",
    ticksOnly: "ticksOnly",
    value: "value"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxSlider_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxSlider = __decorate([ProxyCmp({
  inputs: ["axisLabels", "disabled", "errorText", "helpText", "label", "max", "min", "minVal", "name", "step", "strict", "ticksOnly", "value"]
})], RuxSlider);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxSlider, [{
    type: Component,
    args: [{
      selector: "rux-slider",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["axisLabels", "disabled", "errorText", "helpText", "label", "max", "min", "minVal", "name", "step", "strict", "ticksOnly", "value"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxStatus = class RuxStatus2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxStatus.ɵfac = function RuxStatus_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxStatus)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxStatus.ɵcmp = ɵɵdefineComponent({
  type: RuxStatus,
  selectors: [["rux-status"]],
  inputs: {
    status: "status"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxStatus_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxStatus = __decorate([ProxyCmp({
  inputs: ["status"]
})], RuxStatus);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxStatus, [{
    type: Component,
    args: [{
      selector: "rux-status",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["status"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxSwitch = class RuxSwitch2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
    proxyOutputs(this, this.el, ["ruxchange", "ruxinput", "ruxblur"]);
  }
};
RuxSwitch.ɵfac = function RuxSwitch_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxSwitch)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxSwitch.ɵcmp = ɵɵdefineComponent({
  type: RuxSwitch,
  selectors: [["rux-switch"]],
  inputs: {
    checked: "checked",
    disabled: "disabled",
    label: "label",
    name: "name",
    value: "value"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxSwitch_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxSwitch = __decorate([ProxyCmp({
  inputs: ["checked", "disabled", "label", "name", "value"]
})], RuxSwitch);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxSwitch, [{
    type: Component,
    args: [{
      selector: "rux-switch",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["checked", "disabled", "label", "name", "value"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxTab = class RuxTab2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
    proxyOutputs(this, this.el, ["ruxtabselected"]);
  }
};
RuxTab.ɵfac = function RuxTab_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxTab)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxTab.ɵcmp = ɵɵdefineComponent({
  type: RuxTab,
  selectors: [["rux-tab"]],
  inputs: {
    disabled: "disabled",
    selected: "selected",
    small: "small"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxTab_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxTab = __decorate([ProxyCmp({
  inputs: ["disabled", "selected", "small"]
})], RuxTab);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxTab, [{
    type: Component,
    args: [{
      selector: "rux-tab",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["disabled", "selected", "small"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxTabPanel = class RuxTabPanel2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxTabPanel.ɵfac = function RuxTabPanel_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxTabPanel)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxTabPanel.ɵcmp = ɵɵdefineComponent({
  type: RuxTabPanel,
  selectors: [["rux-tab-panel"]],
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxTabPanel_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxTabPanel = __decorate([ProxyCmp({})], RuxTabPanel);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxTabPanel, [{
    type: Component,
    args: [{
      selector: "rux-tab-panel",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: []
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxTabPanels = class RuxTabPanels2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
    proxyOutputs(this, this.el, ["ruxregisterpanels"]);
  }
};
RuxTabPanels.ɵfac = function RuxTabPanels_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxTabPanels)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxTabPanels.ɵcmp = ɵɵdefineComponent({
  type: RuxTabPanels,
  selectors: [["rux-tab-panels"]],
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxTabPanels_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxTabPanels = __decorate([ProxyCmp({})], RuxTabPanels);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxTabPanels, [{
    type: Component,
    args: [{
      selector: "rux-tab-panels",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: []
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxTable = class RuxTable2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxTable.ɵfac = function RuxTable_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxTable)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxTable.ɵcmp = ɵɵdefineComponent({
  type: RuxTable,
  selectors: [["rux-table"]],
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxTable_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxTable = __decorate([ProxyCmp({})], RuxTable);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxTable, [{
    type: Component,
    args: [{
      selector: "rux-table",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: []
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxTableBody = class RuxTableBody2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxTableBody.ɵfac = function RuxTableBody_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxTableBody)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxTableBody.ɵcmp = ɵɵdefineComponent({
  type: RuxTableBody,
  selectors: [["rux-table-body"]],
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxTableBody_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxTableBody = __decorate([ProxyCmp({})], RuxTableBody);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxTableBody, [{
    type: Component,
    args: [{
      selector: "rux-table-body",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: []
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxTableCell = class RuxTableCell2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxTableCell.ɵfac = function RuxTableCell_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxTableCell)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxTableCell.ɵcmp = ɵɵdefineComponent({
  type: RuxTableCell,
  selectors: [["rux-table-cell"]],
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxTableCell_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxTableCell = __decorate([ProxyCmp({})], RuxTableCell);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxTableCell, [{
    type: Component,
    args: [{
      selector: "rux-table-cell",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: []
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxTableHeader = class RuxTableHeader2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxTableHeader.ɵfac = function RuxTableHeader_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxTableHeader)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxTableHeader.ɵcmp = ɵɵdefineComponent({
  type: RuxTableHeader,
  selectors: [["rux-table-header"]],
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxTableHeader_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxTableHeader = __decorate([ProxyCmp({})], RuxTableHeader);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxTableHeader, [{
    type: Component,
    args: [{
      selector: "rux-table-header",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: []
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxTableHeaderCell = class RuxTableHeaderCell2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxTableHeaderCell.ɵfac = function RuxTableHeaderCell_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxTableHeaderCell)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxTableHeaderCell.ɵcmp = ɵɵdefineComponent({
  type: RuxTableHeaderCell,
  selectors: [["rux-table-header-cell"]],
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxTableHeaderCell_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxTableHeaderCell = __decorate([ProxyCmp({})], RuxTableHeaderCell);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxTableHeaderCell, [{
    type: Component,
    args: [{
      selector: "rux-table-header-cell",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: []
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxTableHeaderRow = class RuxTableHeaderRow2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxTableHeaderRow.ɵfac = function RuxTableHeaderRow_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxTableHeaderRow)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxTableHeaderRow.ɵcmp = ɵɵdefineComponent({
  type: RuxTableHeaderRow,
  selectors: [["rux-table-header-row"]],
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxTableHeaderRow_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxTableHeaderRow = __decorate([ProxyCmp({})], RuxTableHeaderRow);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxTableHeaderRow, [{
    type: Component,
    args: [{
      selector: "rux-table-header-row",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: []
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxTableRow = class RuxTableRow2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxTableRow.ɵfac = function RuxTableRow_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxTableRow)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxTableRow.ɵcmp = ɵɵdefineComponent({
  type: RuxTableRow,
  selectors: [["rux-table-row"]],
  inputs: {
    selected: "selected"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxTableRow_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxTableRow = __decorate([ProxyCmp({
  inputs: ["selected"]
})], RuxTableRow);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxTableRow, [{
    type: Component,
    args: [{
      selector: "rux-table-row",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["selected"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxTabs = class RuxTabs2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
    proxyOutputs(this, this.el, ["ruxselected"]);
  }
};
RuxTabs.ɵfac = function RuxTabs_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxTabs)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxTabs.ɵcmp = ɵɵdefineComponent({
  type: RuxTabs,
  selectors: [["rux-tabs"]],
  inputs: {
    small: "small"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxTabs_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxTabs = __decorate([ProxyCmp({
  inputs: ["small"]
})], RuxTabs);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxTabs, [{
    type: Component,
    args: [{
      selector: "rux-tabs",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["small"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxTag = class RuxTag2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxTag.ɵfac = function RuxTag_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxTag)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxTag.ɵcmp = ɵɵdefineComponent({
  type: RuxTag,
  selectors: [["rux-tag"]],
  inputs: {
    status: "status"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxTag_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxTag = __decorate([ProxyCmp({
  inputs: ["status"]
})], RuxTag);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxTag, [{
    type: Component,
    args: [{
      selector: "rux-tag",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["status"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxTextarea = class RuxTextarea2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
    proxyOutputs(this, this.el, ["ruxchange", "ruxinput", "ruxblur"]);
  }
};
RuxTextarea.ɵfac = function RuxTextarea_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxTextarea)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxTextarea.ɵcmp = ɵɵdefineComponent({
  type: RuxTextarea,
  selectors: [["rux-textarea"]],
  inputs: {
    disabled: "disabled",
    errorText: "errorText",
    helpText: "helpText",
    invalid: "invalid",
    label: "label",
    maxLength: "maxLength",
    minLength: "minLength",
    name: "name",
    placeholder: "placeholder",
    readonly: "readonly",
    required: "required",
    rows: "rows",
    size: "size",
    value: "value"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxTextarea_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxTextarea = __decorate([ProxyCmp({
  inputs: ["disabled", "errorText", "helpText", "invalid", "label", "maxLength", "minLength", "name", "placeholder", "readonly", "required", "rows", "size", "value"],
  methods: ["setFocus"]
})], RuxTextarea);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxTextarea, [{
    type: Component,
    args: [{
      selector: "rux-textarea",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["disabled", "errorText", "helpText", "invalid", "label", "maxLength", "minLength", "name", "placeholder", "readonly", "required", "rows", "size", "value"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxTimeRegion = class RuxTimeRegion2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxTimeRegion.ɵfac = function RuxTimeRegion_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxTimeRegion)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxTimeRegion.ɵcmp = ɵɵdefineComponent({
  type: RuxTimeRegion,
  selectors: [["rux-time-region"]],
  inputs: {
    end: "end",
    hideTimestamp: "hideTimestamp",
    partial: "partial",
    selected: "selected",
    start: "start",
    status: "status"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxTimeRegion_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxTimeRegion = __decorate([ProxyCmp({
  inputs: ["end", "hideTimestamp", "partial", "selected", "start", "status"]
})], RuxTimeRegion);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxTimeRegion, [{
    type: Component,
    args: [{
      selector: "rux-time-region",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["end", "hideTimestamp", "partial", "selected", "start", "status"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxTimeline = class RuxTimeline2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxTimeline.ɵfac = function RuxTimeline_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxTimeline)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxTimeline.ɵcmp = ɵɵdefineComponent({
  type: RuxTimeline,
  selectors: [["rux-timeline"]],
  inputs: {
    end: "end",
    hasPlayedIndicator: "hasPlayedIndicator",
    interval: "interval",
    playhead: "playhead",
    start: "start",
    timezone: "timezone",
    zoom: "zoom"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxTimeline_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxTimeline = __decorate([ProxyCmp({
  inputs: ["end", "hasPlayedIndicator", "interval", "playhead", "start", "timezone", "zoom"]
})], RuxTimeline);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxTimeline, [{
    type: Component,
    args: [{
      selector: "rux-timeline",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["end", "hasPlayedIndicator", "interval", "playhead", "start", "timezone", "zoom"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxToast = class RuxToast2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
    proxyOutputs(this, this.el, ["ruxtoastopen", "ruxtoastclosed"]);
  }
};
RuxToast.ɵfac = function RuxToast_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxToast)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxToast.ɵcmp = ɵɵdefineComponent({
  type: RuxToast,
  selectors: [["rux-toast"]],
  inputs: {
    closeAfter: "closeAfter",
    hideClose: "hideClose",
    message: "message"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxToast_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxToast = __decorate([ProxyCmp({
  inputs: ["closeAfter", "hideClose", "message"]
})], RuxToast);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxToast, [{
    type: Component,
    args: [{
      selector: "rux-toast",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["closeAfter", "hideClose", "message"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxToastStack = class RuxToastStack2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxToastStack.ɵfac = function RuxToastStack_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxToastStack)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxToastStack.ɵcmp = ɵɵdefineComponent({
  type: RuxToastStack,
  selectors: [["rux-toast-stack"]],
  inputs: {
    position: "position"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxToastStack_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxToastStack = __decorate([ProxyCmp({
  inputs: ["position"],
  methods: ["addToast"]
})], RuxToastStack);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxToastStack, [{
    type: Component,
    args: [{
      selector: "rux-toast-stack",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["position"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxTooltip = class RuxTooltip2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
    proxyOutputs(this, this.el, ["ruxtooltipopened", "ruxtooltipclosed"]);
  }
};
RuxTooltip.ɵfac = function RuxTooltip_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxTooltip)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxTooltip.ɵcmp = ɵɵdefineComponent({
  type: RuxTooltip,
  selectors: [["rux-tooltip"]],
  inputs: {
    delay: "delay",
    disableAutoUpdate: "disableAutoUpdate",
    message: "message",
    offset: "offset",
    open: "open",
    placement: "placement",
    strategy: "strategy"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxTooltip_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxTooltip = __decorate([ProxyCmp({
  inputs: ["delay", "disableAutoUpdate", "message", "offset", "open", "placement", "strategy"],
  methods: ["show", "hide"]
})], RuxTooltip);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxTooltip, [{
    type: Component,
    args: [{
      selector: "rux-tooltip",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["delay", "disableAutoUpdate", "message", "offset", "open", "placement", "strategy"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxTrack = class RuxTrack2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxTrack.ɵfac = function RuxTrack_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxTrack)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxTrack.ɵcmp = ɵɵdefineComponent({
  type: RuxTrack,
  selectors: [["rux-track"]],
  inputs: {
    playhead: "playhead"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxTrack_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxTrack = __decorate([ProxyCmp({
  inputs: ["playhead"]
})], RuxTrack);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxTrack, [{
    type: Component,
    args: [{
      selector: "rux-track",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["playhead"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxTree = class RuxTree2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
};
RuxTree.ɵfac = function RuxTree_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxTree)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxTree.ɵcmp = ɵɵdefineComponent({
  type: RuxTree,
  selectors: [["rux-tree"]],
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxTree_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxTree = __decorate([ProxyCmp({})], RuxTree);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxTree, [{
    type: Component,
    args: [{
      selector: "rux-tree",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: []
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var RuxTreeNode = class RuxTreeNode2 {
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
    proxyOutputs(this, this.el, ["ruxtreenodeselected", "ruxtreenodeexpanded", "ruxtreenodecollapsed"]);
  }
};
RuxTreeNode.ɵfac = function RuxTreeNode_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RuxTreeNode)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
RuxTreeNode.ɵcmp = ɵɵdefineComponent({
  type: RuxTreeNode,
  selectors: [["rux-tree-node"]],
  inputs: {
    expanded: "expanded",
    selected: "selected"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function RuxTreeNode_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
RuxTreeNode = __decorate([ProxyCmp({
  inputs: ["expanded", "selected"],
  methods: ["setExpanded", "setSelected"]
})], RuxTreeNode);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RuxTreeNode, [{
    type: Component,
    args: [{
      selector: "rux-tree-node",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>",
      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
      inputs: ["expanded", "selected"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var ValueAccessor = class {
  constructor(el) {
    this.el = el;
    this.onChange = () => {
    };
    this.onTouched = () => {
    };
  }
  writeValue(value) {
    this.el.nativeElement.value = this.lastValue = value == null ? "" : value;
  }
  handleChangeEvent(value) {
    if (value !== this.lastValue) {
      this.lastValue = value;
      this.onChange(value);
    }
  }
  _handleBlurEvent() {
    this.onTouched();
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  setDisabledState(isDisabled) {
    this.el.nativeElement.disabled = isDisabled;
  }
};
ValueAccessor.ɵfac = function ValueAccessor_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ValueAccessor)(ɵɵdirectiveInject(ElementRef));
};
ValueAccessor.ɵdir = ɵɵdefineDirective({
  type: ValueAccessor,
  hostBindings: function ValueAccessor_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("focusout", function ValueAccessor_focusout_HostBindingHandler() {
        return ctx._handleBlurEvent();
      });
    }
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ValueAccessor, [{
    type: Directive,
    args: [{}]
  }], function() {
    return [{
      type: ElementRef
    }];
  }, {
    _handleBlurEvent: [{
      type: HostListener,
      args: ["focusout"]
    }]
  });
})();
var RadioValueAccessor = class extends ValueAccessor {
  constructor(el) {
    super(el);
  }
};
RadioValueAccessor.ɵfac = function RadioValueAccessor_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RadioValueAccessor)(ɵɵdirectiveInject(ElementRef));
};
RadioValueAccessor.ɵdir = ɵɵdefineDirective({
  type: RadioValueAccessor,
  selectors: [["my-radio"]],
  hostBindings: function RadioValueAccessor_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("mySelect", function RadioValueAccessor_mySelect_HostBindingHandler($event) {
        return ctx.handleChangeEvent($event.target.checked);
      });
    }
  },
  standalone: false,
  features: [ɵɵProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: RadioValueAccessor,
    multi: true
  }]), ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RadioValueAccessor, [{
    type: Directive,
    args: [{
      /* tslint:disable-next-line:directive-selector */
      selector: "my-radio",
      host: {
        "(mySelect)": "handleChangeEvent($event.target.checked)"
      },
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: RadioValueAccessor,
        multi: true
      }]
    }]
  }], function() {
    return [{
      type: ElementRef
    }];
  }, null);
})();
var SelectValueAccessor = class extends ValueAccessor {
  constructor(el) {
    super(el);
  }
};
SelectValueAccessor.ɵfac = function SelectValueAccessor_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || SelectValueAccessor)(ɵɵdirectiveInject(ElementRef));
};
SelectValueAccessor.ɵdir = ɵɵdefineDirective({
  type: SelectValueAccessor,
  selectors: [["my-range"], ["my-radio-group"]],
  hostBindings: function SelectValueAccessor_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("myChange", function SelectValueAccessor_myChange_HostBindingHandler($event) {
        return ctx.handleChangeEvent($event.target.value);
      });
    }
  },
  standalone: false,
  features: [ɵɵProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: SelectValueAccessor,
    multi: true
  }]), ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectValueAccessor, [{
    type: Directive,
    args: [{
      /* tslint:disable-next-line:directive-selector */
      selector: "my-range, my-radio-group",
      host: {
        "(myChange)": "handleChangeEvent($event.target.value)"
      },
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: SelectValueAccessor,
        multi: true
      }]
    }]
  }], function() {
    return [{
      type: ElementRef
    }];
  }, null);
})();
var BooleanValueAccessor = class extends ValueAccessor {
  constructor(el) {
    super(el);
  }
  writeValue(value) {
    this.el.nativeElement.checked = this.lastValue = value == null ? false : value;
  }
};
BooleanValueAccessor.ɵfac = function BooleanValueAccessor_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || BooleanValueAccessor)(ɵɵdirectiveInject(ElementRef));
};
BooleanValueAccessor.ɵdir = ɵɵdefineDirective({
  type: BooleanValueAccessor,
  selectors: [["rux-checkbox"], ["rux-switch"]],
  hostBindings: function BooleanValueAccessor_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("ruxchange", function BooleanValueAccessor_ruxchange_HostBindingHandler($event) {
        return ctx.handleChangeEvent($event.target.checked);
      });
    }
  },
  standalone: false,
  features: [ɵɵProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: BooleanValueAccessor,
    multi: true
  }]), ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BooleanValueAccessor, [{
    type: Directive,
    args: [{
      /* tslint:disable-next-line:directive-selector */
      selector: "rux-checkbox, rux-switch",
      host: {
        "(ruxchange)": "handleChangeEvent($event.target.checked)"
      },
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: BooleanValueAccessor,
        multi: true
      }]
    }]
  }], function() {
    return [{
      type: ElementRef
    }];
  }, null);
})();
var TextValueAccessor = class extends ValueAccessor {
  constructor(el) {
    super(el);
  }
};
TextValueAccessor.ɵfac = function TextValueAccessor_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TextValueAccessor)(ɵɵdirectiveInject(ElementRef));
};
TextValueAccessor.ɵdir = ɵɵdefineDirective({
  type: TextValueAccessor,
  selectors: [["rux-input"], ["rux-textarea"], ["rux-slider"], ["rux-radio-group"], ["rux-select"]],
  hostBindings: function TextValueAccessor_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("ruxinput", function TextValueAccessor_ruxinput_HostBindingHandler($event) {
        return ctx.handleChangeEvent($event.target.value);
      })("ruxchange", function TextValueAccessor_ruxchange_HostBindingHandler($event) {
        return ctx.handleChangeEvent($event.target.value);
      });
    }
  },
  standalone: false,
  features: [ɵɵProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: TextValueAccessor,
    multi: true
  }]), ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TextValueAccessor, [{
    type: Directive,
    args: [{
      /* tslint:disable-next-line:directive-selector */
      selector: "rux-input, rux-textarea, rux-slider, rux-radio-group, rux-select",
      host: {
        "(ruxinput)": "handleChangeEvent($event.target.value)",
        "(ruxchange)": "handleChangeEvent($event.target.value)"
      },
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: TextValueAccessor,
        multi: true
      }]
    }]
  }], function() {
    return [{
      type: ElementRef
    }];
  }, null);
})();
var NumericValueAccessor = class extends ValueAccessor {
  constructor(el) {
    super(el);
  }
  //@ts-ignore
  registerOnChange(fn) {
    super.registerOnChange((value) => {
      fn(value === "" ? null : parseFloat(value));
    });
  }
};
NumericValueAccessor.ɵfac = function NumericValueAccessor_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || NumericValueAccessor)(ɵɵdirectiveInject(ElementRef));
};
NumericValueAccessor.ɵdir = ɵɵdefineDirective({
  type: NumericValueAccessor,
  selectors: [["my-input", "type", "number"]],
  hostBindings: function NumericValueAccessor_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("myChange", function NumericValueAccessor_myChange_HostBindingHandler($event) {
        return ctx.handleChangeEvent($event.target.value);
      });
    }
  },
  standalone: false,
  features: [ɵɵProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: NumericValueAccessor,
    multi: true
  }]), ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumericValueAccessor, [{
    type: Directive,
    args: [{
      /* tslint:disable-next-line:directive-selector */
      selector: "my-input[type=number]",
      host: {
        "(myChange)": "handleChangeEvent($event.target.value)"
      },
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: NumericValueAccessor,
        multi: true
      }]
    }]
  }], function() {
    return [{
      type: ElementRef
    }];
  }, null);
})();
var DIRECTIVES = [RuxAccordion, RuxAccordionItem, RuxBreadcrumb, RuxBreadcrumbItem, RuxButton, RuxButtonGroup, RuxCard, RuxCheckbox, RuxCheckboxGroup, RuxClassificationMarking, RuxClock, RuxContainer, RuxDatetime, RuxDialog, RuxGlobalStatusBar, RuxIcon, RuxIcon360, RuxIcon3dRotation, RuxIcon4k, RuxIconAcUnit, RuxIconAccessAlarms, RuxIconAccessTime, RuxIconAccessibility, RuxIconAccessibilityNew, RuxIconAccessible, RuxIconAccessibleForward, RuxIconAccountBalance, RuxIconAccountBalanceWallet, RuxIconAccountBox, RuxIconAccountCircle, RuxIconAdb, RuxIconAdd, RuxIconAddAPhoto, RuxIconAddAlarm, RuxIconAddAlert, RuxIconAddBox, RuxIconAddCircle, RuxIconAddCircleOutline, RuxIconAddComment, RuxIconAddLocation, RuxIconAddPhotoAlternate, RuxIconAddShoppingCart, RuxIconAddToHomeScreen, RuxIconAddToPhotos, RuxIconAddToQueue, RuxIconAdjust, RuxIconAirlineSeatFlat, RuxIconAirlineSeatFlatAngled, RuxIconAirlineSeatIndividualSuite, RuxIconAirlineSeatLegroomExtra, RuxIconAirlineSeatLegroomNormal, RuxIconAirlineSeatLegroomReduced, RuxIconAirlineSeatReclineExtra, RuxIconAirlineSeatReclineNormal, RuxIconAirplanemodeActive, RuxIconAirplanemodeInactive, RuxIconAirplay, RuxIconAirportShuttle, RuxIconAlarm, RuxIconAlarmAdd, RuxIconAlarmOff, RuxIconAlarmOn, RuxIconAlbum, RuxIconAllInbox, RuxIconAllInclusive, RuxIconAllOut, RuxIconAlternateEmail, RuxIconAltitude, RuxIconAndroid, RuxIconAnnouncement, RuxIconAntenna, RuxIconAntennaOff, RuxIconAntennaReceive, RuxIconAntennaTransmit, RuxIconApps, RuxIconArchive, RuxIconArrowBack, RuxIconArrowBackIos, RuxIconArrowDownward, RuxIconArrowDropDown, RuxIconArrowDropDownCircle, RuxIconArrowDropUp, RuxIconArrowForward, RuxIconArrowForwardIos, RuxIconArrowLeft, RuxIconArrowRight, RuxIconArrowRightAlt, RuxIconArrowUpward, RuxIconArtTrack, RuxIconAspectRatio, RuxIconAssessment, RuxIconAssignment, RuxIconAssignmentFind, RuxIconAssignmentLate, RuxIconAssignmentReturn, RuxIconAssignmentReturned, RuxIconAssignmentTurnedIn, RuxIconAssistant, RuxIconAssistantPhoto, RuxIconAttachFile, RuxIconAttachMoney, RuxIconAttachment, RuxIconAudiotrack, RuxIconAutorenew, RuxIconAvTimer, RuxIconBackspace, RuxIconBackup, RuxIconBallot, RuxIconBarChart, RuxIconBattery20, RuxIconBattery30, RuxIconBattery50, RuxIconBattery60, RuxIconBattery80, RuxIconBattery90, RuxIconBatteryAlert, RuxIconBatteryCharging20, RuxIconBatteryCharging30, RuxIconBatteryCharging50, RuxIconBatteryCharging60, RuxIconBatteryCharging80, RuxIconBatteryCharging90, RuxIconBatteryChargingFull, RuxIconBatteryFull, RuxIconBatteryStd, RuxIconBatteryUnknown, RuxIconBeachAccess, RuxIconBeenhere, RuxIconBlock, RuxIconBluetooth, RuxIconBluetoothAudio, RuxIconBluetoothConnected, RuxIconBluetoothDisabled, RuxIconBluetoothSearching, RuxIconBlurCircular, RuxIconBlurLinear, RuxIconBlurOff, RuxIconBlurOn, RuxIconBook, RuxIconBookmark, RuxIconBookmarkBorder, RuxIconBookmarks, RuxIconBorderAll, RuxIconBorderBottom, RuxIconBorderClear, RuxIconBorderColor, RuxIconBorderHorizontal, RuxIconBorderInner, RuxIconBorderLeft, RuxIconBorderOuter, RuxIconBorderRight, RuxIconBorderStyle, RuxIconBorderTop, RuxIconBorderVertical, RuxIconBrandingWatermark, RuxIconBrightness1, RuxIconBrightness2, RuxIconBrightness3, RuxIconBrightness4, RuxIconBrightness5, RuxIconBrightness6, RuxIconBrightness7, RuxIconBrightnessAuto, RuxIconBrightnessHigh, RuxIconBrightnessLow, RuxIconBrightnessMedium, RuxIconBrokenImage, RuxIconBrush, RuxIconBubbleChart, RuxIconBugReport, RuxIconBuild, RuxIconBurstMode, RuxIconBusiness, RuxIconBusinessCenter, RuxIconCached, RuxIconCake, RuxIconCalendarToday, RuxIconCalendarViewDay, RuxIconCall, RuxIconCallEnd, RuxIconCallMade, RuxIconCallMerge, RuxIconCallMissed, RuxIconCallMissedOutgoing, RuxIconCallReceived, RuxIconCallSplit, RuxIconCallToAction, RuxIconCamera, RuxIconCameraAlt, RuxIconCameraEnhance, RuxIconCameraFront, RuxIconCameraRear, RuxIconCameraRoll, RuxIconCancel, RuxIconCancelPresentation, RuxIconCardGiftcard, RuxIconCardMembership, RuxIconCardTravel, RuxIconCasino, RuxIconCast, RuxIconCastConnected, RuxIconCastForEducation, RuxIconCategory, RuxIconCellWifi, RuxIconCenterFocusStrong, RuxIconCenterFocusWeak, RuxIconChangeHistory, RuxIconChat, RuxIconChatBubble, RuxIconChatBubbleOutline, RuxIconCheck, RuxIconCheckBox, RuxIconCheckBoxOutlineBlank, RuxIconCheckCircle, RuxIconCheckCircleOutline, RuxIconChevronLeft, RuxIconChevronRight, RuxIconChildCare, RuxIconChildFriendly, RuxIconChromeReaderMode, RuxIconClass, RuxIconClear, RuxIconClearAll, RuxIconClose, RuxIconClosedCaption, RuxIconCloud, RuxIconCloudCircle, RuxIconCloudDone, RuxIconCloudDownload, RuxIconCloudOff, RuxIconCloudQueue, RuxIconCloudUpload, RuxIconCode, RuxIconCollections, RuxIconCollectionsBookmark, RuxIconColorLens, RuxIconColorize, RuxIconComment, RuxIconCommute, RuxIconCompare, RuxIconCompareArrows, RuxIconCompassCalibration, RuxIconComputer, RuxIconConfirmationNumber, RuxIconContactMail, RuxIconContactPhone, RuxIconContactSupport, RuxIconContacts, RuxIconControlCamera, RuxIconControlPoint, RuxIconControlPointDuplicate, RuxIconCopyright, RuxIconCreate, RuxIconCreateNewFolder, RuxIconCreditCard, RuxIconCrop, RuxIconCrop169, RuxIconCrop32, RuxIconCrop54, RuxIconCrop75, RuxIconCropDin, RuxIconCropFree, RuxIconCropLandscape, RuxIconCropOriginal, RuxIconCropPortrait, RuxIconCropRotate, RuxIconCropSquare, RuxIconDashboard, RuxIconDataUsage, RuxIconDateRange, RuxIconDehaze, RuxIconDelete, RuxIconDeleteForever, RuxIconDeleteOutline, RuxIconDeleteSweep, RuxIconDepartureBoard, RuxIconDescription, RuxIconDesktopAccessDisabled, RuxIconDesktopMac, RuxIconDesktopWindows, RuxIconDetails, RuxIconDeveloperBoard, RuxIconDeveloperMode, RuxIconDeviceHub, RuxIconDeviceUnknown, RuxIconDevices, RuxIconDevicesOther, RuxIconDialerSip, RuxIconDialpad, RuxIconDirections, RuxIconDirectionsBike, RuxIconDirectionsBoat, RuxIconDirectionsBus, RuxIconDirectionsCar, RuxIconDirectionsRailway, RuxIconDirectionsRun, RuxIconDirectionsSubway, RuxIconDirectionsTransit, RuxIconDirectionsWalk, RuxIconDiscFull, RuxIconDns, RuxIconDock, RuxIconDomain, RuxIconDomainDisabled, RuxIconDone, RuxIconDoneAll, RuxIconDoneOutline, RuxIconDonutLarge, RuxIconDonutSmall, RuxIconDrafts, RuxIconDragHandle, RuxIconDragIndicator, RuxIconDriveEta, RuxIconDuo, RuxIconDvr, RuxIconEdit, RuxIconEditAttributes, RuxIconEditLocation, RuxIconEject, RuxIconEmail, RuxIconEnhancedEncryption, RuxIconEqualizer, RuxIconEquipment, RuxIconError, RuxIconErrorOutline, RuxIconEuroSymbol, RuxIconEvStation, RuxIconEvent, RuxIconEventAvailable, RuxIconEventBusy, RuxIconEventNote, RuxIconExitToApp, RuxIconExpandLess, RuxIconExpandMore, RuxIconExplicit, RuxIconExplore, RuxIconExploreOff, RuxIconExposure, RuxIconExposureNeg1, RuxIconExposureNeg2, RuxIconExposurePlus1, RuxIconExposurePlus2, RuxIconExposureZero, RuxIconExtension, RuxIconFace, RuxIconFastForward, RuxIconFastRewind, RuxIconFastfood, RuxIconFavorite, RuxIconFavoriteBorder, RuxIconFeaturedPlayList, RuxIconFeaturedVideo, RuxIconFeedback, RuxIconFiberDvr, RuxIconFiberManualRecord, RuxIconFiberNew, RuxIconFiberPin, RuxIconFiberSmartRecord, RuxIconFileCopy, RuxIconFilter, RuxIconFilter1, RuxIconFilter22, RuxIconFilter3, RuxIconFilter4, RuxIconFilter5, RuxIconFilter6, RuxIconFilter7, RuxIconFilter8, RuxIconFilter9, RuxIconFilter9Plus, RuxIconFilterBAndW, RuxIconFilterCenterFocus, RuxIconFilterDrama, RuxIconFilterFrames, RuxIconFilterHdr, RuxIconFilterList, RuxIconFilterNone, RuxIconFilterTiltShift, RuxIconFilterVintage, RuxIconFindInPage, RuxIconFindReplace, RuxIconFingerprint, RuxIconFirstPage, RuxIconFitnessCenter, RuxIconFlag, RuxIconFlare, RuxIconFlashAuto, RuxIconFlashOff, RuxIconFlashOn, RuxIconFlight, RuxIconFlightLand, RuxIconFlightTakeoff, RuxIconFlip, RuxIconFlipToBack, RuxIconFlipToFront, RuxIconFolder, RuxIconFolderOpen, RuxIconFolderShared, RuxIconFolderSpecial, RuxIconFontDownload, RuxIconFormatAlignCenter, RuxIconFormatAlignJustify, RuxIconFormatAlignLeft, RuxIconFormatAlignRight, RuxIconFormatBold, RuxIconFormatClear, RuxIconFormatColorFill, RuxIconFormatColorReset, RuxIconFormatColorText, RuxIconFormatIndentDecrease, RuxIconFormatIndentIncrease, RuxIconFormatItalic, RuxIconFormatLineSpacing, RuxIconFormatListBulleted, RuxIconFormatListNumbered, RuxIconFormatListNumberedRtl, RuxIconFormatPaint, RuxIconFormatQuote, RuxIconFormatShapes, RuxIconFormatSize, RuxIconFormatStrikethrough, RuxIconFormatTextdirectionLToR, RuxIconFormatTextdirectionRToL, RuxIconFormatUnderlined, RuxIconForum, RuxIconForward, RuxIconForward10, RuxIconForward30, RuxIconForward5, RuxIconFreeBreakfast, RuxIconFullscreen, RuxIconFullscreenExit, RuxIconFunctions, RuxIconGTranslate, RuxIconGamepad, RuxIconGames, RuxIconGavel, RuxIconGesture, RuxIconGetApp, RuxIconGif, RuxIconGolfCourse, RuxIconGpsFixed, RuxIconGpsNotFixed, RuxIconGpsOff, RuxIconGrade, RuxIconGradient, RuxIconGrain, RuxIconGraphicEq, RuxIconGridOff, RuxIconGridOn, RuxIconGroup, RuxIconGroupAdd, RuxIconGroupWork, RuxIconHardware, RuxIconHd, RuxIconHdrOff, RuxIconHdrOn, RuxIconHdrStrong, RuxIconHdrWeak, RuxIconHeadset, RuxIconHeadsetMic, RuxIconHealing, RuxIconHearing, RuxIconHelp, RuxIconHelpOutline, RuxIconHighQuality, RuxIconHighlight, RuxIconHighlightOff, RuxIconHistory, RuxIconHome, RuxIconHorizontalSplit, RuxIconHotTub, RuxIconHotel, RuxIconHourglassEmpty, RuxIconHourglassFull, RuxIconHowToReg, RuxIconHowToVote, RuxIconHttp, RuxIconHttps, RuxIconImage, RuxIconImageAspectRatio, RuxIconImageSearch, RuxIconImportContacts, RuxIconImportExport, RuxIconImportantDevices, RuxIconInbox, RuxIconIndeterminateCheckBox, RuxIconInfo, RuxIconInput, RuxIconInsertChart, RuxIconInsertChartOutlined, RuxIconInsertComment, RuxIconInsertDriveFile, RuxIconInsertEmoticon, RuxIconInsertInvitation, RuxIconInsertLink, RuxIconInsertPhoto, RuxIconInvertColors, RuxIconInvertColorsOff, RuxIconIso, RuxIconKeyboard, RuxIconKeyboardArrowDown, RuxIconKeyboardArrowLeft, RuxIconKeyboardArrowRight, RuxIconKeyboardArrowUp, RuxIconKeyboardBackspace, RuxIconKeyboardCapslock, RuxIconKeyboardHide, RuxIconKeyboardReturn, RuxIconKeyboardTab, RuxIconKeyboardVoice, RuxIconKitchen, RuxIconLabel, RuxIconLabelImportant, RuxIconLabelOff, RuxIconLandscape, RuxIconLanguage, RuxIconLaptop, RuxIconLaptopChromebook, RuxIconLaptopMac, RuxIconLaptopWindows, RuxIconLastPage, RuxIconLaunch, RuxIconLayers, RuxIconLayersClear, RuxIconLeakAdd, RuxIconLeakRemove, RuxIconLens, RuxIconLibraryAdd, RuxIconLibraryBooks, RuxIconLibraryMusic, RuxIconLineStyle, RuxIconLineWeight, RuxIconLinearScale, RuxIconLink, RuxIconLinkOff, RuxIconLinkedCamera, RuxIconList, RuxIconListAlt, RuxIconLiveHelp, RuxIconLiveTv, RuxIconLocalActivity, RuxIconLocalAirport, RuxIconLocalAtm, RuxIconLocalBar, RuxIconLocalCafe, RuxIconLocalCarWash, RuxIconLocalConvenienceStore, RuxIconLocalDining, RuxIconLocalDrink, RuxIconLocalGasStation, RuxIconLocalGroceryStore, RuxIconLocalHospital, RuxIconLocalHotel, RuxIconLocalLaundryService, RuxIconLocalLibrary, RuxIconLocalMall, RuxIconLocalMovies, RuxIconLocalOffer, RuxIconLocalParking, RuxIconLocalPharmacy, RuxIconLocalPhone, RuxIconLocalPlay, RuxIconLocalPostOffice, RuxIconLocalPrintshop, RuxIconLocalSee, RuxIconLocalShipping, RuxIconLocalTaxi, RuxIconLocationCity, RuxIconLocationDisabled, RuxIconLocationOff, RuxIconLocationOn, RuxIconLocationSearching, RuxIconLock, RuxIconLockOpen, RuxIconLooks, RuxIconLooks1, RuxIconLooks22, RuxIconLooks3, RuxIconLooks4, RuxIconLooks5, RuxIconLooks6, RuxIconLoop, RuxIconLoupe, RuxIconLowPriority, RuxIconLoyalty, RuxIconMail, RuxIconMailOutline, RuxIconMap, RuxIconMarkunread, RuxIconMarkunreadMailbox, RuxIconMaximize, RuxIconMeetingRoom, RuxIconMemory, RuxIconMenu, RuxIconMergeType, RuxIconMessage, RuxIconMic, RuxIconMicNone, RuxIconMicOff, RuxIconMinimize, RuxIconMissedVideoCall, RuxIconMission, RuxIconMms, RuxIconMobileFriendly, RuxIconMobileOff, RuxIconMobileScreenShare, RuxIconModeComment, RuxIconMonetizationOn, RuxIconMoney, RuxIconMoneyOff, RuxIconMonochromePhotos, RuxIconMood, RuxIconMoodBad, RuxIconMore, RuxIconMoreHoriz, RuxIconMoreVert, RuxIconMotorcycle, RuxIconMouse, RuxIconMoveToInbox, RuxIconMovie, RuxIconMovieCreation, RuxIconMovieFilter, RuxIconMultilineChart, RuxIconMusicNote, RuxIconMusicOff, RuxIconMusicVideo, RuxIconMyLocation, RuxIconNature, RuxIconNaturePeople, RuxIconNavigateBefore, RuxIconNavigateNext, RuxIconNavigation, RuxIconNearMe, RuxIconNetcom, RuxIconNetworkCell, RuxIconNetworkCheck, RuxIconNetworkLocked, RuxIconNetworkWifi, RuxIconNewReleases, RuxIconNextWeek, RuxIconNfc, RuxIconNoEncryption, RuxIconNoMeetingRoom, RuxIconNoSim, RuxIconNotInterested, RuxIconNotListedLocation, RuxIconNote, RuxIconNoteAdd, RuxIconNotes, RuxIconNotificationImportant, RuxIconNotifications, RuxIconNotificationsActive, RuxIconNotificationsNone, RuxIconNotificationsOff, RuxIconNotificationsPaused, RuxIconOfflineBolt, RuxIconOfflinePin, RuxIconOndemandVideo, RuxIconOpacity, RuxIconOpenInBrowser, RuxIconOpenInNew, RuxIconOpenWith, RuxIconOutlinedFlag, RuxIconPages, RuxIconPageview, RuxIconPalette, RuxIconPanTool, RuxIconPanorama, RuxIconPanoramaFishEye, RuxIconPanoramaHorizontal, RuxIconPanoramaVertical, RuxIconPanoramaWideAngle, RuxIconPartyMode, RuxIconPause, RuxIconPauseCircleFilled, RuxIconPauseCircleOutline, RuxIconPausePresentation, RuxIconPayload, RuxIconPayment, RuxIconPeopleOutline, RuxIconPermCameraMic, RuxIconPermContactCalendar, RuxIconPermDataSetting, RuxIconPermDeviceInformation, RuxIconPermIdentity, RuxIconPermMedia, RuxIconPermPhoneMsg, RuxIconPermScanWifi, RuxIconPerson, RuxIconPersonAdd, RuxIconPersonAddDisabled, RuxIconPersonOutline, RuxIconPersonPin, RuxIconPersonPinCircle, RuxIconPersonalVideo, RuxIconPets, RuxIconPhone, RuxIconPhoneAndroid, RuxIconPhoneBluetoothSpeaker, RuxIconPhoneCallback, RuxIconPhoneForwarded, RuxIconPhoneInTalk, RuxIconPhoneIphone, RuxIconPhoneLocked, RuxIconPhoneMissed, RuxIconPhonePaused, RuxIconPhonelink, RuxIconPhonelinkErase, RuxIconPhonelinkLock, RuxIconPhonelinkOff, RuxIconPhonelinkRing, RuxIconPhonelinkSetup, RuxIconPhoto, RuxIconPhotoAlbum, RuxIconPhotoCamera, RuxIconPhotoFilter, RuxIconPhotoLibrary, RuxIconPhotoSizeSelectActual, RuxIconPhotoSizeSelectLarge, RuxIconPhotoSizeSelectSmall, RuxIconPictureAsPdf, RuxIconPictureInPicture, RuxIconPictureInPictureAlt, RuxIconPieChart, RuxIconPinDrop, RuxIconPlace, RuxIconPlayArrow, RuxIconPlayCircleFilled, RuxIconPlayCircleFilledWhite, RuxIconPlayCircleOutline, RuxIconPlayForWork, RuxIconPlaylistAdd, RuxIconPlaylistAddCheck, RuxIconPlaylistPlay, RuxIconPlusOne, RuxIconPoll, RuxIconPool, RuxIconPortableWifiOff, RuxIconPortrait, RuxIconPower, RuxIconPowerInput, RuxIconPowerOff, RuxIconPowerSettingsNew, RuxIconPregnantWoman, RuxIconPresentToAll, RuxIconPrint, RuxIconPrintDisabled, RuxIconPriorityHigh, RuxIconProcessor, RuxIconProcessorAlt, RuxIconPropulsionPower, RuxIconPublic, RuxIconPublish, RuxIconQueryBuilder, RuxIconQuestionAnswer, RuxIconQueue, RuxIconQueueMusic, RuxIconQueuePlayNext, RuxIconRadio, RuxIconRadioButtonChecked, RuxIconRadioButtonUnchecked, RuxIconRateReview, RuxIconReceipt, RuxIconRecentActors, RuxIconRecordVoiceOver, RuxIconRedeem, RuxIconRedo, RuxIconRefresh, RuxIconRelease, RuxIconRemove, RuxIconRemoveCircle, RuxIconRemoveCircleOutline, RuxIconRemoveFromQueue, RuxIconRemoveRedEye, RuxIconRemoveShoppingCart, RuxIconReorder, RuxIconRepeat, RuxIconRepeatOne, RuxIconReplay, RuxIconReplay10, RuxIconReplay30, RuxIconReplay5, RuxIconReply, RuxIconReplyAll, RuxIconReport, RuxIconReportOff, RuxIconReportProblem, RuxIconRestaurant, RuxIconRestaurantMenu, RuxIconRestore, RuxIconRestoreFromTrash, RuxIconRestorePage, RuxIconRingVolume, RuxIconRoom, RuxIconRoomService, RuxIconRotate90DegreesCc, RuxIconRotateLeft, RuxIconRotateRight, RuxIconRoundedCorner, RuxIconRouter, RuxIconRowing, RuxIconRssFeed, RuxIconRvHookup, RuxIconSatellite, RuxIconSatelliteOff, RuxIconSatelliteReceive, RuxIconSatelliteTransmit, RuxIconSave, RuxIconSaveAlt, RuxIconScanner, RuxIconScatterPlot, RuxIconSchedule, RuxIconSchool, RuxIconScore, RuxIconScreenLockLandscape, RuxIconScreenLockPortrait, RuxIconScreenLockRotation, RuxIconScreenRotation, RuxIconScreenShare, RuxIconSdCard, RuxIconSdStorage, RuxIconSearch, RuxIconSeat, RuxIconSecurity, RuxIconSelectAll, RuxIconSend, RuxIconSentimentDissatisfied, RuxIconSentimentSatisfied, RuxIconSentimentSatisfiedAlt, RuxIconSentimentVeryDissatisfied, RuxIconSentimentVerySatisfied, RuxIconSetPower, RuxIconSettings, RuxIconSettingsApplications, RuxIconSettingsBackupRestore, RuxIconSettingsBluetooth, RuxIconSettingsBrightness, RuxIconSettingsCell, RuxIconSettingsEthernet, RuxIconSettingsInputAntenna, RuxIconSettingsInputComponent, RuxIconSettingsInputComposite, RuxIconSettingsInputHdmi, RuxIconSettingsInputSvideo, RuxIconSettingsOverscan, RuxIconSettingsPhone, RuxIconSettingsPower, RuxIconSettingsRemote, RuxIconSettingsSystemDaydream, RuxIconSettingsVoice, RuxIconShare, RuxIconShop, RuxIconShopTwo, RuxIconShoppingBasket, RuxIconShoppingCart, RuxIconShortText, RuxIconShowChart, RuxIconShuffle, RuxIconShutterSpeed, RuxIconSignalCellular0Bar, RuxIconSignalCellular1Bar, RuxIconSignalCellular2Bar, RuxIconSignalCellular3Bar, RuxIconSignalCellular4Bar, RuxIconSignalCellularAlt, RuxIconSignalCellularConnectedNoInternet0Bar, RuxIconSignalCellularConnectedNoInternet1Bar, RuxIconSignalCellularConnectedNoInternet2Bar, RuxIconSignalCellularConnectedNoInternet3Bar, RuxIconSignalCellularConnectedNoInternet4Bar, RuxIconSignalCellularNoSim, RuxIconSignalCellularNull, RuxIconSignalCellularOff, RuxIconSignalWifi0Bar, RuxIconSignalWifi1Bar, RuxIconSignalWifi1BarLock, RuxIconSignalWifi2Bar, RuxIconSignalWifi2BarLock, RuxIconSignalWifi3Bar, RuxIconSignalWifi3BarLock, RuxIconSignalWifi4Bar, RuxIconSignalWifi4BarLock, RuxIconSignalWifiOff, RuxIconSimCard, RuxIconSkipNext, RuxIconSkipPrevious, RuxIconSlideshow, RuxIconSlowMotionVideo, RuxIconSmartphone, RuxIconSmokeFree, RuxIconSmokingRooms, RuxIconSms, RuxIconSmsFailed, RuxIconSnooze, RuxIconSolar, RuxIconSort, RuxIconSortByAlpha, RuxIconSpa, RuxIconSpaceBar, RuxIconSpeaker, RuxIconSpeakerGroup, RuxIconSpeakerNotes, RuxIconSpeakerNotesOff, RuxIconSpeakerPhone, RuxIconSpellcheck, RuxIconStar, RuxIconStarBorder, RuxIconStarHalf, RuxIconStarRate, RuxIconStars, RuxIconStayCurrentLandscape, RuxIconStayCurrentPortrait, RuxIconStayPrimaryLandscape, RuxIconStayPrimaryPortrait, RuxIconStop, RuxIconStopScreenShare, RuxIconStorage, RuxIconStore, RuxIconStoreMallDirectory, RuxIconStraighten, RuxIconStreetview, RuxIconStrikethroughS, RuxIconStyle, RuxIconSubdirectoryArrowLeft, RuxIconSubdirectoryArrowRight, RuxIconSubject, RuxIconSubscriptions, RuxIconSubtitles, RuxIconSubway, RuxIconSupervisedUserCircle, RuxIconSupervisorAccount, RuxIconSurroundSound, RuxIconSwapCalls, RuxIconSwapHoriz, RuxIconSwapHorizontalCircle, RuxIconSwapVert, RuxIconSwapVerticalCircle, RuxIconSwitchCamera, RuxIconSwitchVideo, RuxIconSync, RuxIconSyncDisabled, RuxIconSyncProblem, RuxIconSystemUpdate, RuxIconTab, RuxIconTabUnselected, RuxIconTableChart, RuxIconTablet, RuxIconTabletAndroid, RuxIconTabletMac, RuxIconTagFaces, RuxIconTapAndPlay, RuxIconTerrain, RuxIconTextFields, RuxIconTextFormat, RuxIconTextRotateUp, RuxIconTextRotateVertical, RuxIconTextRotationNone, RuxIconTextsms, RuxIconTexture, RuxIconTheaters, RuxIconThermal, RuxIconThumbDown, RuxIconThumbDownAlt, RuxIconThumbUp, RuxIconThumbUpAlt, RuxIconThumbsUpDown, RuxIconTimeToLeave, RuxIconTimelapse, RuxIconTimeline, RuxIconTimer, RuxIconTimer10, RuxIconTimer3, RuxIconTimerOff, RuxIconTitle, RuxIconToc, RuxIconToday, RuxIconToggleOff, RuxIconToggleOn, RuxIconToll, RuxIconTonality, RuxIconTouchApp, RuxIconToys, RuxIconTrackChanges, RuxIconTraffic, RuxIconTrain, RuxIconTram, RuxIconTransferWithinAStation, RuxIconTransform, RuxIconTransitEnterexit, RuxIconTranslate, RuxIconTrendingDown, RuxIconTrendingFlat, RuxIconTrendingUp, RuxIconTripOrigin, RuxIconTune, RuxIconTurnedIn, RuxIconTurnedInNot, RuxIconTv, RuxIconTvOff, RuxIconUnarchive, RuxIconUndo, RuxIconUnfoldLess, RuxIconUnfoldMore, RuxIconUnsubscribe, RuxIconUpdate, RuxIconUsb, RuxIconVerifiedUser, RuxIconVerticalAlignBottom, RuxIconVerticalAlignCenter, RuxIconVerticalAlignTop, RuxIconVerticalSplit, RuxIconVibration, RuxIconVideoCall, RuxIconVideoLabel, RuxIconVideoLibrary, RuxIconVideocam, RuxIconVideocamOff, RuxIconVideogameAsset, RuxIconViewAgenda, RuxIconViewArray, RuxIconViewCarousel, RuxIconViewColumn, RuxIconViewComfy, RuxIconViewCompact, RuxIconViewDay, RuxIconViewHeadline, RuxIconViewList, RuxIconViewModule, RuxIconViewQuilt, RuxIconViewStream, RuxIconViewWeek, RuxIconVignette, RuxIconVisibility, RuxIconVisibilityOff, RuxIconVoiceChat, RuxIconVoiceOverOff, RuxIconVoicemail, RuxIconVolumeDown, RuxIconVolumeMute, RuxIconVolumeOff, RuxIconVolumeUp, RuxIconVpnKey, RuxIconVpnLock, RuxIconWallpaper, RuxIconWarning, RuxIconWatch, RuxIconWatchLater, RuxIconWaves, RuxIconWbAuto, RuxIconWbCloudy, RuxIconWbIncandescent, RuxIconWbIridescent, RuxIconWbSunny, RuxIconWc, RuxIconWeb, RuxIconWebAsset, RuxIconWeekend, RuxIconWhatshot, RuxIconWhereToVote, RuxIconWidgets, RuxIconWifi, RuxIconWifiLock, RuxIconWifiOff, RuxIconWifiTethering, RuxIconWork, RuxIconWorkOff, RuxIconWorkOutline, RuxIconWrapText, RuxIconYoutubeSearchedFor, RuxIconZoomIn, RuxIconZoomInMap, RuxIconZoomOut, RuxIconZoomOutMap, RuxIndeterminateProgress, RuxInput, RuxLog, RuxMenu, RuxMenuItem, RuxMenuItemDivider, RuxMonitoringIcon, RuxMonitoringProgressIcon, RuxNotification, RuxOption, RuxOptionGroup, RuxPopUp, RuxProgress, RuxPushButton, RuxRadio, RuxRadioGroup, RuxRuler, RuxSegmentedButton, RuxSelect, RuxSlider, RuxStatus, RuxSwitch, RuxTab, RuxTabPanel, RuxTabPanels, RuxTable, RuxTableBody, RuxTableCell, RuxTableHeader, RuxTableHeaderCell, RuxTableHeaderRow, RuxTableRow, RuxTabs, RuxTag, RuxTextarea, RuxTimeRegion, RuxTimeline, RuxToast, RuxToastStack, RuxTooltip, RuxTrack, RuxTree, RuxTreeNode];
defineCustomElements(window);
var DECLARATIONS = [...DIRECTIVES, BooleanValueAccessor, NumericValueAccessor, RadioValueAccessor, SelectValueAccessor, TextValueAccessor];
var AstroComponentsModule = class {
};
AstroComponentsModule.ɵfac = function AstroComponentsModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || AstroComponentsModule)();
};
AstroComponentsModule.ɵmod = ɵɵdefineNgModule({
  type: AstroComponentsModule,
  declarations: [RuxAccordion, RuxAccordionItem, RuxBreadcrumb, RuxBreadcrumbItem, RuxButton, RuxButtonGroup, RuxCard, RuxCheckbox, RuxCheckboxGroup, RuxClassificationMarking, RuxClock, RuxContainer, RuxDatetime, RuxDialog, RuxGlobalStatusBar, RuxIcon, RuxIcon360, RuxIcon3dRotation, RuxIcon4k, RuxIconAcUnit, RuxIconAccessAlarms, RuxIconAccessTime, RuxIconAccessibility, RuxIconAccessibilityNew, RuxIconAccessible, RuxIconAccessibleForward, RuxIconAccountBalance, RuxIconAccountBalanceWallet, RuxIconAccountBox, RuxIconAccountCircle, RuxIconAdb, RuxIconAdd, RuxIconAddAPhoto, RuxIconAddAlarm, RuxIconAddAlert, RuxIconAddBox, RuxIconAddCircle, RuxIconAddCircleOutline, RuxIconAddComment, RuxIconAddLocation, RuxIconAddPhotoAlternate, RuxIconAddShoppingCart, RuxIconAddToHomeScreen, RuxIconAddToPhotos, RuxIconAddToQueue, RuxIconAdjust, RuxIconAirlineSeatFlat, RuxIconAirlineSeatFlatAngled, RuxIconAirlineSeatIndividualSuite, RuxIconAirlineSeatLegroomExtra, RuxIconAirlineSeatLegroomNormal, RuxIconAirlineSeatLegroomReduced, RuxIconAirlineSeatReclineExtra, RuxIconAirlineSeatReclineNormal, RuxIconAirplanemodeActive, RuxIconAirplanemodeInactive, RuxIconAirplay, RuxIconAirportShuttle, RuxIconAlarm, RuxIconAlarmAdd, RuxIconAlarmOff, RuxIconAlarmOn, RuxIconAlbum, RuxIconAllInbox, RuxIconAllInclusive, RuxIconAllOut, RuxIconAlternateEmail, RuxIconAltitude, RuxIconAndroid, RuxIconAnnouncement, RuxIconAntenna, RuxIconAntennaOff, RuxIconAntennaReceive, RuxIconAntennaTransmit, RuxIconApps, RuxIconArchive, RuxIconArrowBack, RuxIconArrowBackIos, RuxIconArrowDownward, RuxIconArrowDropDown, RuxIconArrowDropDownCircle, RuxIconArrowDropUp, RuxIconArrowForward, RuxIconArrowForwardIos, RuxIconArrowLeft, RuxIconArrowRight, RuxIconArrowRightAlt, RuxIconArrowUpward, RuxIconArtTrack, RuxIconAspectRatio, RuxIconAssessment, RuxIconAssignment, RuxIconAssignmentFind, RuxIconAssignmentLate, RuxIconAssignmentReturn, RuxIconAssignmentReturned, RuxIconAssignmentTurnedIn, RuxIconAssistant, RuxIconAssistantPhoto, RuxIconAttachFile, RuxIconAttachMoney, RuxIconAttachment, RuxIconAudiotrack, RuxIconAutorenew, RuxIconAvTimer, RuxIconBackspace, RuxIconBackup, RuxIconBallot, RuxIconBarChart, RuxIconBattery20, RuxIconBattery30, RuxIconBattery50, RuxIconBattery60, RuxIconBattery80, RuxIconBattery90, RuxIconBatteryAlert, RuxIconBatteryCharging20, RuxIconBatteryCharging30, RuxIconBatteryCharging50, RuxIconBatteryCharging60, RuxIconBatteryCharging80, RuxIconBatteryCharging90, RuxIconBatteryChargingFull, RuxIconBatteryFull, RuxIconBatteryStd, RuxIconBatteryUnknown, RuxIconBeachAccess, RuxIconBeenhere, RuxIconBlock, RuxIconBluetooth, RuxIconBluetoothAudio, RuxIconBluetoothConnected, RuxIconBluetoothDisabled, RuxIconBluetoothSearching, RuxIconBlurCircular, RuxIconBlurLinear, RuxIconBlurOff, RuxIconBlurOn, RuxIconBook, RuxIconBookmark, RuxIconBookmarkBorder, RuxIconBookmarks, RuxIconBorderAll, RuxIconBorderBottom, RuxIconBorderClear, RuxIconBorderColor, RuxIconBorderHorizontal, RuxIconBorderInner, RuxIconBorderLeft, RuxIconBorderOuter, RuxIconBorderRight, RuxIconBorderStyle, RuxIconBorderTop, RuxIconBorderVertical, RuxIconBrandingWatermark, RuxIconBrightness1, RuxIconBrightness2, RuxIconBrightness3, RuxIconBrightness4, RuxIconBrightness5, RuxIconBrightness6, RuxIconBrightness7, RuxIconBrightnessAuto, RuxIconBrightnessHigh, RuxIconBrightnessLow, RuxIconBrightnessMedium, RuxIconBrokenImage, RuxIconBrush, RuxIconBubbleChart, RuxIconBugReport, RuxIconBuild, RuxIconBurstMode, RuxIconBusiness, RuxIconBusinessCenter, RuxIconCached, RuxIconCake, RuxIconCalendarToday, RuxIconCalendarViewDay, RuxIconCall, RuxIconCallEnd, RuxIconCallMade, RuxIconCallMerge, RuxIconCallMissed, RuxIconCallMissedOutgoing, RuxIconCallReceived, RuxIconCallSplit, RuxIconCallToAction, RuxIconCamera, RuxIconCameraAlt, RuxIconCameraEnhance, RuxIconCameraFront, RuxIconCameraRear, RuxIconCameraRoll, RuxIconCancel, RuxIconCancelPresentation, RuxIconCardGiftcard, RuxIconCardMembership, RuxIconCardTravel, RuxIconCasino, RuxIconCast, RuxIconCastConnected, RuxIconCastForEducation, RuxIconCategory, RuxIconCellWifi, RuxIconCenterFocusStrong, RuxIconCenterFocusWeak, RuxIconChangeHistory, RuxIconChat, RuxIconChatBubble, RuxIconChatBubbleOutline, RuxIconCheck, RuxIconCheckBox, RuxIconCheckBoxOutlineBlank, RuxIconCheckCircle, RuxIconCheckCircleOutline, RuxIconChevronLeft, RuxIconChevronRight, RuxIconChildCare, RuxIconChildFriendly, RuxIconChromeReaderMode, RuxIconClass, RuxIconClear, RuxIconClearAll, RuxIconClose, RuxIconClosedCaption, RuxIconCloud, RuxIconCloudCircle, RuxIconCloudDone, RuxIconCloudDownload, RuxIconCloudOff, RuxIconCloudQueue, RuxIconCloudUpload, RuxIconCode, RuxIconCollections, RuxIconCollectionsBookmark, RuxIconColorLens, RuxIconColorize, RuxIconComment, RuxIconCommute, RuxIconCompare, RuxIconCompareArrows, RuxIconCompassCalibration, RuxIconComputer, RuxIconConfirmationNumber, RuxIconContactMail, RuxIconContactPhone, RuxIconContactSupport, RuxIconContacts, RuxIconControlCamera, RuxIconControlPoint, RuxIconControlPointDuplicate, RuxIconCopyright, RuxIconCreate, RuxIconCreateNewFolder, RuxIconCreditCard, RuxIconCrop, RuxIconCrop169, RuxIconCrop32, RuxIconCrop54, RuxIconCrop75, RuxIconCropDin, RuxIconCropFree, RuxIconCropLandscape, RuxIconCropOriginal, RuxIconCropPortrait, RuxIconCropRotate, RuxIconCropSquare, RuxIconDashboard, RuxIconDataUsage, RuxIconDateRange, RuxIconDehaze, RuxIconDelete, RuxIconDeleteForever, RuxIconDeleteOutline, RuxIconDeleteSweep, RuxIconDepartureBoard, RuxIconDescription, RuxIconDesktopAccessDisabled, RuxIconDesktopMac, RuxIconDesktopWindows, RuxIconDetails, RuxIconDeveloperBoard, RuxIconDeveloperMode, RuxIconDeviceHub, RuxIconDeviceUnknown, RuxIconDevices, RuxIconDevicesOther, RuxIconDialerSip, RuxIconDialpad, RuxIconDirections, RuxIconDirectionsBike, RuxIconDirectionsBoat, RuxIconDirectionsBus, RuxIconDirectionsCar, RuxIconDirectionsRailway, RuxIconDirectionsRun, RuxIconDirectionsSubway, RuxIconDirectionsTransit, RuxIconDirectionsWalk, RuxIconDiscFull, RuxIconDns, RuxIconDock, RuxIconDomain, RuxIconDomainDisabled, RuxIconDone, RuxIconDoneAll, RuxIconDoneOutline, RuxIconDonutLarge, RuxIconDonutSmall, RuxIconDrafts, RuxIconDragHandle, RuxIconDragIndicator, RuxIconDriveEta, RuxIconDuo, RuxIconDvr, RuxIconEdit, RuxIconEditAttributes, RuxIconEditLocation, RuxIconEject, RuxIconEmail, RuxIconEnhancedEncryption, RuxIconEqualizer, RuxIconEquipment, RuxIconError, RuxIconErrorOutline, RuxIconEuroSymbol, RuxIconEvStation, RuxIconEvent, RuxIconEventAvailable, RuxIconEventBusy, RuxIconEventNote, RuxIconExitToApp, RuxIconExpandLess, RuxIconExpandMore, RuxIconExplicit, RuxIconExplore, RuxIconExploreOff, RuxIconExposure, RuxIconExposureNeg1, RuxIconExposureNeg2, RuxIconExposurePlus1, RuxIconExposurePlus2, RuxIconExposureZero, RuxIconExtension, RuxIconFace, RuxIconFastForward, RuxIconFastRewind, RuxIconFastfood, RuxIconFavorite, RuxIconFavoriteBorder, RuxIconFeaturedPlayList, RuxIconFeaturedVideo, RuxIconFeedback, RuxIconFiberDvr, RuxIconFiberManualRecord, RuxIconFiberNew, RuxIconFiberPin, RuxIconFiberSmartRecord, RuxIconFileCopy, RuxIconFilter, RuxIconFilter1, RuxIconFilter22, RuxIconFilter3, RuxIconFilter4, RuxIconFilter5, RuxIconFilter6, RuxIconFilter7, RuxIconFilter8, RuxIconFilter9, RuxIconFilter9Plus, RuxIconFilterBAndW, RuxIconFilterCenterFocus, RuxIconFilterDrama, RuxIconFilterFrames, RuxIconFilterHdr, RuxIconFilterList, RuxIconFilterNone, RuxIconFilterTiltShift, RuxIconFilterVintage, RuxIconFindInPage, RuxIconFindReplace, RuxIconFingerprint, RuxIconFirstPage, RuxIconFitnessCenter, RuxIconFlag, RuxIconFlare, RuxIconFlashAuto, RuxIconFlashOff, RuxIconFlashOn, RuxIconFlight, RuxIconFlightLand, RuxIconFlightTakeoff, RuxIconFlip, RuxIconFlipToBack, RuxIconFlipToFront, RuxIconFolder, RuxIconFolderOpen, RuxIconFolderShared, RuxIconFolderSpecial, RuxIconFontDownload, RuxIconFormatAlignCenter, RuxIconFormatAlignJustify, RuxIconFormatAlignLeft, RuxIconFormatAlignRight, RuxIconFormatBold, RuxIconFormatClear, RuxIconFormatColorFill, RuxIconFormatColorReset, RuxIconFormatColorText, RuxIconFormatIndentDecrease, RuxIconFormatIndentIncrease, RuxIconFormatItalic, RuxIconFormatLineSpacing, RuxIconFormatListBulleted, RuxIconFormatListNumbered, RuxIconFormatListNumberedRtl, RuxIconFormatPaint, RuxIconFormatQuote, RuxIconFormatShapes, RuxIconFormatSize, RuxIconFormatStrikethrough, RuxIconFormatTextdirectionLToR, RuxIconFormatTextdirectionRToL, RuxIconFormatUnderlined, RuxIconForum, RuxIconForward, RuxIconForward10, RuxIconForward30, RuxIconForward5, RuxIconFreeBreakfast, RuxIconFullscreen, RuxIconFullscreenExit, RuxIconFunctions, RuxIconGTranslate, RuxIconGamepad, RuxIconGames, RuxIconGavel, RuxIconGesture, RuxIconGetApp, RuxIconGif, RuxIconGolfCourse, RuxIconGpsFixed, RuxIconGpsNotFixed, RuxIconGpsOff, RuxIconGrade, RuxIconGradient, RuxIconGrain, RuxIconGraphicEq, RuxIconGridOff, RuxIconGridOn, RuxIconGroup, RuxIconGroupAdd, RuxIconGroupWork, RuxIconHardware, RuxIconHd, RuxIconHdrOff, RuxIconHdrOn, RuxIconHdrStrong, RuxIconHdrWeak, RuxIconHeadset, RuxIconHeadsetMic, RuxIconHealing, RuxIconHearing, RuxIconHelp, RuxIconHelpOutline, RuxIconHighQuality, RuxIconHighlight, RuxIconHighlightOff, RuxIconHistory, RuxIconHome, RuxIconHorizontalSplit, RuxIconHotTub, RuxIconHotel, RuxIconHourglassEmpty, RuxIconHourglassFull, RuxIconHowToReg, RuxIconHowToVote, RuxIconHttp, RuxIconHttps, RuxIconImage, RuxIconImageAspectRatio, RuxIconImageSearch, RuxIconImportContacts, RuxIconImportExport, RuxIconImportantDevices, RuxIconInbox, RuxIconIndeterminateCheckBox, RuxIconInfo, RuxIconInput, RuxIconInsertChart, RuxIconInsertChartOutlined, RuxIconInsertComment, RuxIconInsertDriveFile, RuxIconInsertEmoticon, RuxIconInsertInvitation, RuxIconInsertLink, RuxIconInsertPhoto, RuxIconInvertColors, RuxIconInvertColorsOff, RuxIconIso, RuxIconKeyboard, RuxIconKeyboardArrowDown, RuxIconKeyboardArrowLeft, RuxIconKeyboardArrowRight, RuxIconKeyboardArrowUp, RuxIconKeyboardBackspace, RuxIconKeyboardCapslock, RuxIconKeyboardHide, RuxIconKeyboardReturn, RuxIconKeyboardTab, RuxIconKeyboardVoice, RuxIconKitchen, RuxIconLabel, RuxIconLabelImportant, RuxIconLabelOff, RuxIconLandscape, RuxIconLanguage, RuxIconLaptop, RuxIconLaptopChromebook, RuxIconLaptopMac, RuxIconLaptopWindows, RuxIconLastPage, RuxIconLaunch, RuxIconLayers, RuxIconLayersClear, RuxIconLeakAdd, RuxIconLeakRemove, RuxIconLens, RuxIconLibraryAdd, RuxIconLibraryBooks, RuxIconLibraryMusic, RuxIconLineStyle, RuxIconLineWeight, RuxIconLinearScale, RuxIconLink, RuxIconLinkOff, RuxIconLinkedCamera, RuxIconList, RuxIconListAlt, RuxIconLiveHelp, RuxIconLiveTv, RuxIconLocalActivity, RuxIconLocalAirport, RuxIconLocalAtm, RuxIconLocalBar, RuxIconLocalCafe, RuxIconLocalCarWash, RuxIconLocalConvenienceStore, RuxIconLocalDining, RuxIconLocalDrink, RuxIconLocalGasStation, RuxIconLocalGroceryStore, RuxIconLocalHospital, RuxIconLocalHotel, RuxIconLocalLaundryService, RuxIconLocalLibrary, RuxIconLocalMall, RuxIconLocalMovies, RuxIconLocalOffer, RuxIconLocalParking, RuxIconLocalPharmacy, RuxIconLocalPhone, RuxIconLocalPlay, RuxIconLocalPostOffice, RuxIconLocalPrintshop, RuxIconLocalSee, RuxIconLocalShipping, RuxIconLocalTaxi, RuxIconLocationCity, RuxIconLocationDisabled, RuxIconLocationOff, RuxIconLocationOn, RuxIconLocationSearching, RuxIconLock, RuxIconLockOpen, RuxIconLooks, RuxIconLooks1, RuxIconLooks22, RuxIconLooks3, RuxIconLooks4, RuxIconLooks5, RuxIconLooks6, RuxIconLoop, RuxIconLoupe, RuxIconLowPriority, RuxIconLoyalty, RuxIconMail, RuxIconMailOutline, RuxIconMap, RuxIconMarkunread, RuxIconMarkunreadMailbox, RuxIconMaximize, RuxIconMeetingRoom, RuxIconMemory, RuxIconMenu, RuxIconMergeType, RuxIconMessage, RuxIconMic, RuxIconMicNone, RuxIconMicOff, RuxIconMinimize, RuxIconMissedVideoCall, RuxIconMission, RuxIconMms, RuxIconMobileFriendly, RuxIconMobileOff, RuxIconMobileScreenShare, RuxIconModeComment, RuxIconMonetizationOn, RuxIconMoney, RuxIconMoneyOff, RuxIconMonochromePhotos, RuxIconMood, RuxIconMoodBad, RuxIconMore, RuxIconMoreHoriz, RuxIconMoreVert, RuxIconMotorcycle, RuxIconMouse, RuxIconMoveToInbox, RuxIconMovie, RuxIconMovieCreation, RuxIconMovieFilter, RuxIconMultilineChart, RuxIconMusicNote, RuxIconMusicOff, RuxIconMusicVideo, RuxIconMyLocation, RuxIconNature, RuxIconNaturePeople, RuxIconNavigateBefore, RuxIconNavigateNext, RuxIconNavigation, RuxIconNearMe, RuxIconNetcom, RuxIconNetworkCell, RuxIconNetworkCheck, RuxIconNetworkLocked, RuxIconNetworkWifi, RuxIconNewReleases, RuxIconNextWeek, RuxIconNfc, RuxIconNoEncryption, RuxIconNoMeetingRoom, RuxIconNoSim, RuxIconNotInterested, RuxIconNotListedLocation, RuxIconNote, RuxIconNoteAdd, RuxIconNotes, RuxIconNotificationImportant, RuxIconNotifications, RuxIconNotificationsActive, RuxIconNotificationsNone, RuxIconNotificationsOff, RuxIconNotificationsPaused, RuxIconOfflineBolt, RuxIconOfflinePin, RuxIconOndemandVideo, RuxIconOpacity, RuxIconOpenInBrowser, RuxIconOpenInNew, RuxIconOpenWith, RuxIconOutlinedFlag, RuxIconPages, RuxIconPageview, RuxIconPalette, RuxIconPanTool, RuxIconPanorama, RuxIconPanoramaFishEye, RuxIconPanoramaHorizontal, RuxIconPanoramaVertical, RuxIconPanoramaWideAngle, RuxIconPartyMode, RuxIconPause, RuxIconPauseCircleFilled, RuxIconPauseCircleOutline, RuxIconPausePresentation, RuxIconPayload, RuxIconPayment, RuxIconPeopleOutline, RuxIconPermCameraMic, RuxIconPermContactCalendar, RuxIconPermDataSetting, RuxIconPermDeviceInformation, RuxIconPermIdentity, RuxIconPermMedia, RuxIconPermPhoneMsg, RuxIconPermScanWifi, RuxIconPerson, RuxIconPersonAdd, RuxIconPersonAddDisabled, RuxIconPersonOutline, RuxIconPersonPin, RuxIconPersonPinCircle, RuxIconPersonalVideo, RuxIconPets, RuxIconPhone, RuxIconPhoneAndroid, RuxIconPhoneBluetoothSpeaker, RuxIconPhoneCallback, RuxIconPhoneForwarded, RuxIconPhoneInTalk, RuxIconPhoneIphone, RuxIconPhoneLocked, RuxIconPhoneMissed, RuxIconPhonePaused, RuxIconPhonelink, RuxIconPhonelinkErase, RuxIconPhonelinkLock, RuxIconPhonelinkOff, RuxIconPhonelinkRing, RuxIconPhonelinkSetup, RuxIconPhoto, RuxIconPhotoAlbum, RuxIconPhotoCamera, RuxIconPhotoFilter, RuxIconPhotoLibrary, RuxIconPhotoSizeSelectActual, RuxIconPhotoSizeSelectLarge, RuxIconPhotoSizeSelectSmall, RuxIconPictureAsPdf, RuxIconPictureInPicture, RuxIconPictureInPictureAlt, RuxIconPieChart, RuxIconPinDrop, RuxIconPlace, RuxIconPlayArrow, RuxIconPlayCircleFilled, RuxIconPlayCircleFilledWhite, RuxIconPlayCircleOutline, RuxIconPlayForWork, RuxIconPlaylistAdd, RuxIconPlaylistAddCheck, RuxIconPlaylistPlay, RuxIconPlusOne, RuxIconPoll, RuxIconPool, RuxIconPortableWifiOff, RuxIconPortrait, RuxIconPower, RuxIconPowerInput, RuxIconPowerOff, RuxIconPowerSettingsNew, RuxIconPregnantWoman, RuxIconPresentToAll, RuxIconPrint, RuxIconPrintDisabled, RuxIconPriorityHigh, RuxIconProcessor, RuxIconProcessorAlt, RuxIconPropulsionPower, RuxIconPublic, RuxIconPublish, RuxIconQueryBuilder, RuxIconQuestionAnswer, RuxIconQueue, RuxIconQueueMusic, RuxIconQueuePlayNext, RuxIconRadio, RuxIconRadioButtonChecked, RuxIconRadioButtonUnchecked, RuxIconRateReview, RuxIconReceipt, RuxIconRecentActors, RuxIconRecordVoiceOver, RuxIconRedeem, RuxIconRedo, RuxIconRefresh, RuxIconRelease, RuxIconRemove, RuxIconRemoveCircle, RuxIconRemoveCircleOutline, RuxIconRemoveFromQueue, RuxIconRemoveRedEye, RuxIconRemoveShoppingCart, RuxIconReorder, RuxIconRepeat, RuxIconRepeatOne, RuxIconReplay, RuxIconReplay10, RuxIconReplay30, RuxIconReplay5, RuxIconReply, RuxIconReplyAll, RuxIconReport, RuxIconReportOff, RuxIconReportProblem, RuxIconRestaurant, RuxIconRestaurantMenu, RuxIconRestore, RuxIconRestoreFromTrash, RuxIconRestorePage, RuxIconRingVolume, RuxIconRoom, RuxIconRoomService, RuxIconRotate90DegreesCc, RuxIconRotateLeft, RuxIconRotateRight, RuxIconRoundedCorner, RuxIconRouter, RuxIconRowing, RuxIconRssFeed, RuxIconRvHookup, RuxIconSatellite, RuxIconSatelliteOff, RuxIconSatelliteReceive, RuxIconSatelliteTransmit, RuxIconSave, RuxIconSaveAlt, RuxIconScanner, RuxIconScatterPlot, RuxIconSchedule, RuxIconSchool, RuxIconScore, RuxIconScreenLockLandscape, RuxIconScreenLockPortrait, RuxIconScreenLockRotation, RuxIconScreenRotation, RuxIconScreenShare, RuxIconSdCard, RuxIconSdStorage, RuxIconSearch, RuxIconSeat, RuxIconSecurity, RuxIconSelectAll, RuxIconSend, RuxIconSentimentDissatisfied, RuxIconSentimentSatisfied, RuxIconSentimentSatisfiedAlt, RuxIconSentimentVeryDissatisfied, RuxIconSentimentVerySatisfied, RuxIconSetPower, RuxIconSettings, RuxIconSettingsApplications, RuxIconSettingsBackupRestore, RuxIconSettingsBluetooth, RuxIconSettingsBrightness, RuxIconSettingsCell, RuxIconSettingsEthernet, RuxIconSettingsInputAntenna, RuxIconSettingsInputComponent, RuxIconSettingsInputComposite, RuxIconSettingsInputHdmi, RuxIconSettingsInputSvideo, RuxIconSettingsOverscan, RuxIconSettingsPhone, RuxIconSettingsPower, RuxIconSettingsRemote, RuxIconSettingsSystemDaydream, RuxIconSettingsVoice, RuxIconShare, RuxIconShop, RuxIconShopTwo, RuxIconShoppingBasket, RuxIconShoppingCart, RuxIconShortText, RuxIconShowChart, RuxIconShuffle, RuxIconShutterSpeed, RuxIconSignalCellular0Bar, RuxIconSignalCellular1Bar, RuxIconSignalCellular2Bar, RuxIconSignalCellular3Bar, RuxIconSignalCellular4Bar, RuxIconSignalCellularAlt, RuxIconSignalCellularConnectedNoInternet0Bar, RuxIconSignalCellularConnectedNoInternet1Bar, RuxIconSignalCellularConnectedNoInternet2Bar, RuxIconSignalCellularConnectedNoInternet3Bar, RuxIconSignalCellularConnectedNoInternet4Bar, RuxIconSignalCellularNoSim, RuxIconSignalCellularNull, RuxIconSignalCellularOff, RuxIconSignalWifi0Bar, RuxIconSignalWifi1Bar, RuxIconSignalWifi1BarLock, RuxIconSignalWifi2Bar, RuxIconSignalWifi2BarLock, RuxIconSignalWifi3Bar, RuxIconSignalWifi3BarLock, RuxIconSignalWifi4Bar, RuxIconSignalWifi4BarLock, RuxIconSignalWifiOff, RuxIconSimCard, RuxIconSkipNext, RuxIconSkipPrevious, RuxIconSlideshow, RuxIconSlowMotionVideo, RuxIconSmartphone, RuxIconSmokeFree, RuxIconSmokingRooms, RuxIconSms, RuxIconSmsFailed, RuxIconSnooze, RuxIconSolar, RuxIconSort, RuxIconSortByAlpha, RuxIconSpa, RuxIconSpaceBar, RuxIconSpeaker, RuxIconSpeakerGroup, RuxIconSpeakerNotes, RuxIconSpeakerNotesOff, RuxIconSpeakerPhone, RuxIconSpellcheck, RuxIconStar, RuxIconStarBorder, RuxIconStarHalf, RuxIconStarRate, RuxIconStars, RuxIconStayCurrentLandscape, RuxIconStayCurrentPortrait, RuxIconStayPrimaryLandscape, RuxIconStayPrimaryPortrait, RuxIconStop, RuxIconStopScreenShare, RuxIconStorage, RuxIconStore, RuxIconStoreMallDirectory, RuxIconStraighten, RuxIconStreetview, RuxIconStrikethroughS, RuxIconStyle, RuxIconSubdirectoryArrowLeft, RuxIconSubdirectoryArrowRight, RuxIconSubject, RuxIconSubscriptions, RuxIconSubtitles, RuxIconSubway, RuxIconSupervisedUserCircle, RuxIconSupervisorAccount, RuxIconSurroundSound, RuxIconSwapCalls, RuxIconSwapHoriz, RuxIconSwapHorizontalCircle, RuxIconSwapVert, RuxIconSwapVerticalCircle, RuxIconSwitchCamera, RuxIconSwitchVideo, RuxIconSync, RuxIconSyncDisabled, RuxIconSyncProblem, RuxIconSystemUpdate, RuxIconTab, RuxIconTabUnselected, RuxIconTableChart, RuxIconTablet, RuxIconTabletAndroid, RuxIconTabletMac, RuxIconTagFaces, RuxIconTapAndPlay, RuxIconTerrain, RuxIconTextFields, RuxIconTextFormat, RuxIconTextRotateUp, RuxIconTextRotateVertical, RuxIconTextRotationNone, RuxIconTextsms, RuxIconTexture, RuxIconTheaters, RuxIconThermal, RuxIconThumbDown, RuxIconThumbDownAlt, RuxIconThumbUp, RuxIconThumbUpAlt, RuxIconThumbsUpDown, RuxIconTimeToLeave, RuxIconTimelapse, RuxIconTimeline, RuxIconTimer, RuxIconTimer10, RuxIconTimer3, RuxIconTimerOff, RuxIconTitle, RuxIconToc, RuxIconToday, RuxIconToggleOff, RuxIconToggleOn, RuxIconToll, RuxIconTonality, RuxIconTouchApp, RuxIconToys, RuxIconTrackChanges, RuxIconTraffic, RuxIconTrain, RuxIconTram, RuxIconTransferWithinAStation, RuxIconTransform, RuxIconTransitEnterexit, RuxIconTranslate, RuxIconTrendingDown, RuxIconTrendingFlat, RuxIconTrendingUp, RuxIconTripOrigin, RuxIconTune, RuxIconTurnedIn, RuxIconTurnedInNot, RuxIconTv, RuxIconTvOff, RuxIconUnarchive, RuxIconUndo, RuxIconUnfoldLess, RuxIconUnfoldMore, RuxIconUnsubscribe, RuxIconUpdate, RuxIconUsb, RuxIconVerifiedUser, RuxIconVerticalAlignBottom, RuxIconVerticalAlignCenter, RuxIconVerticalAlignTop, RuxIconVerticalSplit, RuxIconVibration, RuxIconVideoCall, RuxIconVideoLabel, RuxIconVideoLibrary, RuxIconVideocam, RuxIconVideocamOff, RuxIconVideogameAsset, RuxIconViewAgenda, RuxIconViewArray, RuxIconViewCarousel, RuxIconViewColumn, RuxIconViewComfy, RuxIconViewCompact, RuxIconViewDay, RuxIconViewHeadline, RuxIconViewList, RuxIconViewModule, RuxIconViewQuilt, RuxIconViewStream, RuxIconViewWeek, RuxIconVignette, RuxIconVisibility, RuxIconVisibilityOff, RuxIconVoiceChat, RuxIconVoiceOverOff, RuxIconVoicemail, RuxIconVolumeDown, RuxIconVolumeMute, RuxIconVolumeOff, RuxIconVolumeUp, RuxIconVpnKey, RuxIconVpnLock, RuxIconWallpaper, RuxIconWarning, RuxIconWatch, RuxIconWatchLater, RuxIconWaves, RuxIconWbAuto, RuxIconWbCloudy, RuxIconWbIncandescent, RuxIconWbIridescent, RuxIconWbSunny, RuxIconWc, RuxIconWeb, RuxIconWebAsset, RuxIconWeekend, RuxIconWhatshot, RuxIconWhereToVote, RuxIconWidgets, RuxIconWifi, RuxIconWifiLock, RuxIconWifiOff, RuxIconWifiTethering, RuxIconWork, RuxIconWorkOff, RuxIconWorkOutline, RuxIconWrapText, RuxIconYoutubeSearchedFor, RuxIconZoomIn, RuxIconZoomInMap, RuxIconZoomOut, RuxIconZoomOutMap, RuxIndeterminateProgress, RuxInput, RuxLog, RuxMenu, RuxMenuItem, RuxMenuItemDivider, RuxMonitoringIcon, RuxMonitoringProgressIcon, RuxNotification, RuxOption, RuxOptionGroup, RuxPopUp, RuxProgress, RuxPushButton, RuxRadio, RuxRadioGroup, RuxRuler, RuxSegmentedButton, RuxSelect, RuxSlider, RuxStatus, RuxSwitch, RuxTab, RuxTabPanel, RuxTabPanels, RuxTable, RuxTableBody, RuxTableCell, RuxTableHeader, RuxTableHeaderCell, RuxTableHeaderRow, RuxTableRow, RuxTabs, RuxTag, RuxTextarea, RuxTimeRegion, RuxTimeline, RuxToast, RuxToastStack, RuxTooltip, RuxTrack, RuxTree, RuxTreeNode, BooleanValueAccessor, NumericValueAccessor, RadioValueAccessor, SelectValueAccessor, TextValueAccessor],
  exports: [RuxAccordion, RuxAccordionItem, RuxBreadcrumb, RuxBreadcrumbItem, RuxButton, RuxButtonGroup, RuxCard, RuxCheckbox, RuxCheckboxGroup, RuxClassificationMarking, RuxClock, RuxContainer, RuxDatetime, RuxDialog, RuxGlobalStatusBar, RuxIcon, RuxIcon360, RuxIcon3dRotation, RuxIcon4k, RuxIconAcUnit, RuxIconAccessAlarms, RuxIconAccessTime, RuxIconAccessibility, RuxIconAccessibilityNew, RuxIconAccessible, RuxIconAccessibleForward, RuxIconAccountBalance, RuxIconAccountBalanceWallet, RuxIconAccountBox, RuxIconAccountCircle, RuxIconAdb, RuxIconAdd, RuxIconAddAPhoto, RuxIconAddAlarm, RuxIconAddAlert, RuxIconAddBox, RuxIconAddCircle, RuxIconAddCircleOutline, RuxIconAddComment, RuxIconAddLocation, RuxIconAddPhotoAlternate, RuxIconAddShoppingCart, RuxIconAddToHomeScreen, RuxIconAddToPhotos, RuxIconAddToQueue, RuxIconAdjust, RuxIconAirlineSeatFlat, RuxIconAirlineSeatFlatAngled, RuxIconAirlineSeatIndividualSuite, RuxIconAirlineSeatLegroomExtra, RuxIconAirlineSeatLegroomNormal, RuxIconAirlineSeatLegroomReduced, RuxIconAirlineSeatReclineExtra, RuxIconAirlineSeatReclineNormal, RuxIconAirplanemodeActive, RuxIconAirplanemodeInactive, RuxIconAirplay, RuxIconAirportShuttle, RuxIconAlarm, RuxIconAlarmAdd, RuxIconAlarmOff, RuxIconAlarmOn, RuxIconAlbum, RuxIconAllInbox, RuxIconAllInclusive, RuxIconAllOut, RuxIconAlternateEmail, RuxIconAltitude, RuxIconAndroid, RuxIconAnnouncement, RuxIconAntenna, RuxIconAntennaOff, RuxIconAntennaReceive, RuxIconAntennaTransmit, RuxIconApps, RuxIconArchive, RuxIconArrowBack, RuxIconArrowBackIos, RuxIconArrowDownward, RuxIconArrowDropDown, RuxIconArrowDropDownCircle, RuxIconArrowDropUp, RuxIconArrowForward, RuxIconArrowForwardIos, RuxIconArrowLeft, RuxIconArrowRight, RuxIconArrowRightAlt, RuxIconArrowUpward, RuxIconArtTrack, RuxIconAspectRatio, RuxIconAssessment, RuxIconAssignment, RuxIconAssignmentFind, RuxIconAssignmentLate, RuxIconAssignmentReturn, RuxIconAssignmentReturned, RuxIconAssignmentTurnedIn, RuxIconAssistant, RuxIconAssistantPhoto, RuxIconAttachFile, RuxIconAttachMoney, RuxIconAttachment, RuxIconAudiotrack, RuxIconAutorenew, RuxIconAvTimer, RuxIconBackspace, RuxIconBackup, RuxIconBallot, RuxIconBarChart, RuxIconBattery20, RuxIconBattery30, RuxIconBattery50, RuxIconBattery60, RuxIconBattery80, RuxIconBattery90, RuxIconBatteryAlert, RuxIconBatteryCharging20, RuxIconBatteryCharging30, RuxIconBatteryCharging50, RuxIconBatteryCharging60, RuxIconBatteryCharging80, RuxIconBatteryCharging90, RuxIconBatteryChargingFull, RuxIconBatteryFull, RuxIconBatteryStd, RuxIconBatteryUnknown, RuxIconBeachAccess, RuxIconBeenhere, RuxIconBlock, RuxIconBluetooth, RuxIconBluetoothAudio, RuxIconBluetoothConnected, RuxIconBluetoothDisabled, RuxIconBluetoothSearching, RuxIconBlurCircular, RuxIconBlurLinear, RuxIconBlurOff, RuxIconBlurOn, RuxIconBook, RuxIconBookmark, RuxIconBookmarkBorder, RuxIconBookmarks, RuxIconBorderAll, RuxIconBorderBottom, RuxIconBorderClear, RuxIconBorderColor, RuxIconBorderHorizontal, RuxIconBorderInner, RuxIconBorderLeft, RuxIconBorderOuter, RuxIconBorderRight, RuxIconBorderStyle, RuxIconBorderTop, RuxIconBorderVertical, RuxIconBrandingWatermark, RuxIconBrightness1, RuxIconBrightness2, RuxIconBrightness3, RuxIconBrightness4, RuxIconBrightness5, RuxIconBrightness6, RuxIconBrightness7, RuxIconBrightnessAuto, RuxIconBrightnessHigh, RuxIconBrightnessLow, RuxIconBrightnessMedium, RuxIconBrokenImage, RuxIconBrush, RuxIconBubbleChart, RuxIconBugReport, RuxIconBuild, RuxIconBurstMode, RuxIconBusiness, RuxIconBusinessCenter, RuxIconCached, RuxIconCake, RuxIconCalendarToday, RuxIconCalendarViewDay, RuxIconCall, RuxIconCallEnd, RuxIconCallMade, RuxIconCallMerge, RuxIconCallMissed, RuxIconCallMissedOutgoing, RuxIconCallReceived, RuxIconCallSplit, RuxIconCallToAction, RuxIconCamera, RuxIconCameraAlt, RuxIconCameraEnhance, RuxIconCameraFront, RuxIconCameraRear, RuxIconCameraRoll, RuxIconCancel, RuxIconCancelPresentation, RuxIconCardGiftcard, RuxIconCardMembership, RuxIconCardTravel, RuxIconCasino, RuxIconCast, RuxIconCastConnected, RuxIconCastForEducation, RuxIconCategory, RuxIconCellWifi, RuxIconCenterFocusStrong, RuxIconCenterFocusWeak, RuxIconChangeHistory, RuxIconChat, RuxIconChatBubble, RuxIconChatBubbleOutline, RuxIconCheck, RuxIconCheckBox, RuxIconCheckBoxOutlineBlank, RuxIconCheckCircle, RuxIconCheckCircleOutline, RuxIconChevronLeft, RuxIconChevronRight, RuxIconChildCare, RuxIconChildFriendly, RuxIconChromeReaderMode, RuxIconClass, RuxIconClear, RuxIconClearAll, RuxIconClose, RuxIconClosedCaption, RuxIconCloud, RuxIconCloudCircle, RuxIconCloudDone, RuxIconCloudDownload, RuxIconCloudOff, RuxIconCloudQueue, RuxIconCloudUpload, RuxIconCode, RuxIconCollections, RuxIconCollectionsBookmark, RuxIconColorLens, RuxIconColorize, RuxIconComment, RuxIconCommute, RuxIconCompare, RuxIconCompareArrows, RuxIconCompassCalibration, RuxIconComputer, RuxIconConfirmationNumber, RuxIconContactMail, RuxIconContactPhone, RuxIconContactSupport, RuxIconContacts, RuxIconControlCamera, RuxIconControlPoint, RuxIconControlPointDuplicate, RuxIconCopyright, RuxIconCreate, RuxIconCreateNewFolder, RuxIconCreditCard, RuxIconCrop, RuxIconCrop169, RuxIconCrop32, RuxIconCrop54, RuxIconCrop75, RuxIconCropDin, RuxIconCropFree, RuxIconCropLandscape, RuxIconCropOriginal, RuxIconCropPortrait, RuxIconCropRotate, RuxIconCropSquare, RuxIconDashboard, RuxIconDataUsage, RuxIconDateRange, RuxIconDehaze, RuxIconDelete, RuxIconDeleteForever, RuxIconDeleteOutline, RuxIconDeleteSweep, RuxIconDepartureBoard, RuxIconDescription, RuxIconDesktopAccessDisabled, RuxIconDesktopMac, RuxIconDesktopWindows, RuxIconDetails, RuxIconDeveloperBoard, RuxIconDeveloperMode, RuxIconDeviceHub, RuxIconDeviceUnknown, RuxIconDevices, RuxIconDevicesOther, RuxIconDialerSip, RuxIconDialpad, RuxIconDirections, RuxIconDirectionsBike, RuxIconDirectionsBoat, RuxIconDirectionsBus, RuxIconDirectionsCar, RuxIconDirectionsRailway, RuxIconDirectionsRun, RuxIconDirectionsSubway, RuxIconDirectionsTransit, RuxIconDirectionsWalk, RuxIconDiscFull, RuxIconDns, RuxIconDock, RuxIconDomain, RuxIconDomainDisabled, RuxIconDone, RuxIconDoneAll, RuxIconDoneOutline, RuxIconDonutLarge, RuxIconDonutSmall, RuxIconDrafts, RuxIconDragHandle, RuxIconDragIndicator, RuxIconDriveEta, RuxIconDuo, RuxIconDvr, RuxIconEdit, RuxIconEditAttributes, RuxIconEditLocation, RuxIconEject, RuxIconEmail, RuxIconEnhancedEncryption, RuxIconEqualizer, RuxIconEquipment, RuxIconError, RuxIconErrorOutline, RuxIconEuroSymbol, RuxIconEvStation, RuxIconEvent, RuxIconEventAvailable, RuxIconEventBusy, RuxIconEventNote, RuxIconExitToApp, RuxIconExpandLess, RuxIconExpandMore, RuxIconExplicit, RuxIconExplore, RuxIconExploreOff, RuxIconExposure, RuxIconExposureNeg1, RuxIconExposureNeg2, RuxIconExposurePlus1, RuxIconExposurePlus2, RuxIconExposureZero, RuxIconExtension, RuxIconFace, RuxIconFastForward, RuxIconFastRewind, RuxIconFastfood, RuxIconFavorite, RuxIconFavoriteBorder, RuxIconFeaturedPlayList, RuxIconFeaturedVideo, RuxIconFeedback, RuxIconFiberDvr, RuxIconFiberManualRecord, RuxIconFiberNew, RuxIconFiberPin, RuxIconFiberSmartRecord, RuxIconFileCopy, RuxIconFilter, RuxIconFilter1, RuxIconFilter22, RuxIconFilter3, RuxIconFilter4, RuxIconFilter5, RuxIconFilter6, RuxIconFilter7, RuxIconFilter8, RuxIconFilter9, RuxIconFilter9Plus, RuxIconFilterBAndW, RuxIconFilterCenterFocus, RuxIconFilterDrama, RuxIconFilterFrames, RuxIconFilterHdr, RuxIconFilterList, RuxIconFilterNone, RuxIconFilterTiltShift, RuxIconFilterVintage, RuxIconFindInPage, RuxIconFindReplace, RuxIconFingerprint, RuxIconFirstPage, RuxIconFitnessCenter, RuxIconFlag, RuxIconFlare, RuxIconFlashAuto, RuxIconFlashOff, RuxIconFlashOn, RuxIconFlight, RuxIconFlightLand, RuxIconFlightTakeoff, RuxIconFlip, RuxIconFlipToBack, RuxIconFlipToFront, RuxIconFolder, RuxIconFolderOpen, RuxIconFolderShared, RuxIconFolderSpecial, RuxIconFontDownload, RuxIconFormatAlignCenter, RuxIconFormatAlignJustify, RuxIconFormatAlignLeft, RuxIconFormatAlignRight, RuxIconFormatBold, RuxIconFormatClear, RuxIconFormatColorFill, RuxIconFormatColorReset, RuxIconFormatColorText, RuxIconFormatIndentDecrease, RuxIconFormatIndentIncrease, RuxIconFormatItalic, RuxIconFormatLineSpacing, RuxIconFormatListBulleted, RuxIconFormatListNumbered, RuxIconFormatListNumberedRtl, RuxIconFormatPaint, RuxIconFormatQuote, RuxIconFormatShapes, RuxIconFormatSize, RuxIconFormatStrikethrough, RuxIconFormatTextdirectionLToR, RuxIconFormatTextdirectionRToL, RuxIconFormatUnderlined, RuxIconForum, RuxIconForward, RuxIconForward10, RuxIconForward30, RuxIconForward5, RuxIconFreeBreakfast, RuxIconFullscreen, RuxIconFullscreenExit, RuxIconFunctions, RuxIconGTranslate, RuxIconGamepad, RuxIconGames, RuxIconGavel, RuxIconGesture, RuxIconGetApp, RuxIconGif, RuxIconGolfCourse, RuxIconGpsFixed, RuxIconGpsNotFixed, RuxIconGpsOff, RuxIconGrade, RuxIconGradient, RuxIconGrain, RuxIconGraphicEq, RuxIconGridOff, RuxIconGridOn, RuxIconGroup, RuxIconGroupAdd, RuxIconGroupWork, RuxIconHardware, RuxIconHd, RuxIconHdrOff, RuxIconHdrOn, RuxIconHdrStrong, RuxIconHdrWeak, RuxIconHeadset, RuxIconHeadsetMic, RuxIconHealing, RuxIconHearing, RuxIconHelp, RuxIconHelpOutline, RuxIconHighQuality, RuxIconHighlight, RuxIconHighlightOff, RuxIconHistory, RuxIconHome, RuxIconHorizontalSplit, RuxIconHotTub, RuxIconHotel, RuxIconHourglassEmpty, RuxIconHourglassFull, RuxIconHowToReg, RuxIconHowToVote, RuxIconHttp, RuxIconHttps, RuxIconImage, RuxIconImageAspectRatio, RuxIconImageSearch, RuxIconImportContacts, RuxIconImportExport, RuxIconImportantDevices, RuxIconInbox, RuxIconIndeterminateCheckBox, RuxIconInfo, RuxIconInput, RuxIconInsertChart, RuxIconInsertChartOutlined, RuxIconInsertComment, RuxIconInsertDriveFile, RuxIconInsertEmoticon, RuxIconInsertInvitation, RuxIconInsertLink, RuxIconInsertPhoto, RuxIconInvertColors, RuxIconInvertColorsOff, RuxIconIso, RuxIconKeyboard, RuxIconKeyboardArrowDown, RuxIconKeyboardArrowLeft, RuxIconKeyboardArrowRight, RuxIconKeyboardArrowUp, RuxIconKeyboardBackspace, RuxIconKeyboardCapslock, RuxIconKeyboardHide, RuxIconKeyboardReturn, RuxIconKeyboardTab, RuxIconKeyboardVoice, RuxIconKitchen, RuxIconLabel, RuxIconLabelImportant, RuxIconLabelOff, RuxIconLandscape, RuxIconLanguage, RuxIconLaptop, RuxIconLaptopChromebook, RuxIconLaptopMac, RuxIconLaptopWindows, RuxIconLastPage, RuxIconLaunch, RuxIconLayers, RuxIconLayersClear, RuxIconLeakAdd, RuxIconLeakRemove, RuxIconLens, RuxIconLibraryAdd, RuxIconLibraryBooks, RuxIconLibraryMusic, RuxIconLineStyle, RuxIconLineWeight, RuxIconLinearScale, RuxIconLink, RuxIconLinkOff, RuxIconLinkedCamera, RuxIconList, RuxIconListAlt, RuxIconLiveHelp, RuxIconLiveTv, RuxIconLocalActivity, RuxIconLocalAirport, RuxIconLocalAtm, RuxIconLocalBar, RuxIconLocalCafe, RuxIconLocalCarWash, RuxIconLocalConvenienceStore, RuxIconLocalDining, RuxIconLocalDrink, RuxIconLocalGasStation, RuxIconLocalGroceryStore, RuxIconLocalHospital, RuxIconLocalHotel, RuxIconLocalLaundryService, RuxIconLocalLibrary, RuxIconLocalMall, RuxIconLocalMovies, RuxIconLocalOffer, RuxIconLocalParking, RuxIconLocalPharmacy, RuxIconLocalPhone, RuxIconLocalPlay, RuxIconLocalPostOffice, RuxIconLocalPrintshop, RuxIconLocalSee, RuxIconLocalShipping, RuxIconLocalTaxi, RuxIconLocationCity, RuxIconLocationDisabled, RuxIconLocationOff, RuxIconLocationOn, RuxIconLocationSearching, RuxIconLock, RuxIconLockOpen, RuxIconLooks, RuxIconLooks1, RuxIconLooks22, RuxIconLooks3, RuxIconLooks4, RuxIconLooks5, RuxIconLooks6, RuxIconLoop, RuxIconLoupe, RuxIconLowPriority, RuxIconLoyalty, RuxIconMail, RuxIconMailOutline, RuxIconMap, RuxIconMarkunread, RuxIconMarkunreadMailbox, RuxIconMaximize, RuxIconMeetingRoom, RuxIconMemory, RuxIconMenu, RuxIconMergeType, RuxIconMessage, RuxIconMic, RuxIconMicNone, RuxIconMicOff, RuxIconMinimize, RuxIconMissedVideoCall, RuxIconMission, RuxIconMms, RuxIconMobileFriendly, RuxIconMobileOff, RuxIconMobileScreenShare, RuxIconModeComment, RuxIconMonetizationOn, RuxIconMoney, RuxIconMoneyOff, RuxIconMonochromePhotos, RuxIconMood, RuxIconMoodBad, RuxIconMore, RuxIconMoreHoriz, RuxIconMoreVert, RuxIconMotorcycle, RuxIconMouse, RuxIconMoveToInbox, RuxIconMovie, RuxIconMovieCreation, RuxIconMovieFilter, RuxIconMultilineChart, RuxIconMusicNote, RuxIconMusicOff, RuxIconMusicVideo, RuxIconMyLocation, RuxIconNature, RuxIconNaturePeople, RuxIconNavigateBefore, RuxIconNavigateNext, RuxIconNavigation, RuxIconNearMe, RuxIconNetcom, RuxIconNetworkCell, RuxIconNetworkCheck, RuxIconNetworkLocked, RuxIconNetworkWifi, RuxIconNewReleases, RuxIconNextWeek, RuxIconNfc, RuxIconNoEncryption, RuxIconNoMeetingRoom, RuxIconNoSim, RuxIconNotInterested, RuxIconNotListedLocation, RuxIconNote, RuxIconNoteAdd, RuxIconNotes, RuxIconNotificationImportant, RuxIconNotifications, RuxIconNotificationsActive, RuxIconNotificationsNone, RuxIconNotificationsOff, RuxIconNotificationsPaused, RuxIconOfflineBolt, RuxIconOfflinePin, RuxIconOndemandVideo, RuxIconOpacity, RuxIconOpenInBrowser, RuxIconOpenInNew, RuxIconOpenWith, RuxIconOutlinedFlag, RuxIconPages, RuxIconPageview, RuxIconPalette, RuxIconPanTool, RuxIconPanorama, RuxIconPanoramaFishEye, RuxIconPanoramaHorizontal, RuxIconPanoramaVertical, RuxIconPanoramaWideAngle, RuxIconPartyMode, RuxIconPause, RuxIconPauseCircleFilled, RuxIconPauseCircleOutline, RuxIconPausePresentation, RuxIconPayload, RuxIconPayment, RuxIconPeopleOutline, RuxIconPermCameraMic, RuxIconPermContactCalendar, RuxIconPermDataSetting, RuxIconPermDeviceInformation, RuxIconPermIdentity, RuxIconPermMedia, RuxIconPermPhoneMsg, RuxIconPermScanWifi, RuxIconPerson, RuxIconPersonAdd, RuxIconPersonAddDisabled, RuxIconPersonOutline, RuxIconPersonPin, RuxIconPersonPinCircle, RuxIconPersonalVideo, RuxIconPets, RuxIconPhone, RuxIconPhoneAndroid, RuxIconPhoneBluetoothSpeaker, RuxIconPhoneCallback, RuxIconPhoneForwarded, RuxIconPhoneInTalk, RuxIconPhoneIphone, RuxIconPhoneLocked, RuxIconPhoneMissed, RuxIconPhonePaused, RuxIconPhonelink, RuxIconPhonelinkErase, RuxIconPhonelinkLock, RuxIconPhonelinkOff, RuxIconPhonelinkRing, RuxIconPhonelinkSetup, RuxIconPhoto, RuxIconPhotoAlbum, RuxIconPhotoCamera, RuxIconPhotoFilter, RuxIconPhotoLibrary, RuxIconPhotoSizeSelectActual, RuxIconPhotoSizeSelectLarge, RuxIconPhotoSizeSelectSmall, RuxIconPictureAsPdf, RuxIconPictureInPicture, RuxIconPictureInPictureAlt, RuxIconPieChart, RuxIconPinDrop, RuxIconPlace, RuxIconPlayArrow, RuxIconPlayCircleFilled, RuxIconPlayCircleFilledWhite, RuxIconPlayCircleOutline, RuxIconPlayForWork, RuxIconPlaylistAdd, RuxIconPlaylistAddCheck, RuxIconPlaylistPlay, RuxIconPlusOne, RuxIconPoll, RuxIconPool, RuxIconPortableWifiOff, RuxIconPortrait, RuxIconPower, RuxIconPowerInput, RuxIconPowerOff, RuxIconPowerSettingsNew, RuxIconPregnantWoman, RuxIconPresentToAll, RuxIconPrint, RuxIconPrintDisabled, RuxIconPriorityHigh, RuxIconProcessor, RuxIconProcessorAlt, RuxIconPropulsionPower, RuxIconPublic, RuxIconPublish, RuxIconQueryBuilder, RuxIconQuestionAnswer, RuxIconQueue, RuxIconQueueMusic, RuxIconQueuePlayNext, RuxIconRadio, RuxIconRadioButtonChecked, RuxIconRadioButtonUnchecked, RuxIconRateReview, RuxIconReceipt, RuxIconRecentActors, RuxIconRecordVoiceOver, RuxIconRedeem, RuxIconRedo, RuxIconRefresh, RuxIconRelease, RuxIconRemove, RuxIconRemoveCircle, RuxIconRemoveCircleOutline, RuxIconRemoveFromQueue, RuxIconRemoveRedEye, RuxIconRemoveShoppingCart, RuxIconReorder, RuxIconRepeat, RuxIconRepeatOne, RuxIconReplay, RuxIconReplay10, RuxIconReplay30, RuxIconReplay5, RuxIconReply, RuxIconReplyAll, RuxIconReport, RuxIconReportOff, RuxIconReportProblem, RuxIconRestaurant, RuxIconRestaurantMenu, RuxIconRestore, RuxIconRestoreFromTrash, RuxIconRestorePage, RuxIconRingVolume, RuxIconRoom, RuxIconRoomService, RuxIconRotate90DegreesCc, RuxIconRotateLeft, RuxIconRotateRight, RuxIconRoundedCorner, RuxIconRouter, RuxIconRowing, RuxIconRssFeed, RuxIconRvHookup, RuxIconSatellite, RuxIconSatelliteOff, RuxIconSatelliteReceive, RuxIconSatelliteTransmit, RuxIconSave, RuxIconSaveAlt, RuxIconScanner, RuxIconScatterPlot, RuxIconSchedule, RuxIconSchool, RuxIconScore, RuxIconScreenLockLandscape, RuxIconScreenLockPortrait, RuxIconScreenLockRotation, RuxIconScreenRotation, RuxIconScreenShare, RuxIconSdCard, RuxIconSdStorage, RuxIconSearch, RuxIconSeat, RuxIconSecurity, RuxIconSelectAll, RuxIconSend, RuxIconSentimentDissatisfied, RuxIconSentimentSatisfied, RuxIconSentimentSatisfiedAlt, RuxIconSentimentVeryDissatisfied, RuxIconSentimentVerySatisfied, RuxIconSetPower, RuxIconSettings, RuxIconSettingsApplications, RuxIconSettingsBackupRestore, RuxIconSettingsBluetooth, RuxIconSettingsBrightness, RuxIconSettingsCell, RuxIconSettingsEthernet, RuxIconSettingsInputAntenna, RuxIconSettingsInputComponent, RuxIconSettingsInputComposite, RuxIconSettingsInputHdmi, RuxIconSettingsInputSvideo, RuxIconSettingsOverscan, RuxIconSettingsPhone, RuxIconSettingsPower, RuxIconSettingsRemote, RuxIconSettingsSystemDaydream, RuxIconSettingsVoice, RuxIconShare, RuxIconShop, RuxIconShopTwo, RuxIconShoppingBasket, RuxIconShoppingCart, RuxIconShortText, RuxIconShowChart, RuxIconShuffle, RuxIconShutterSpeed, RuxIconSignalCellular0Bar, RuxIconSignalCellular1Bar, RuxIconSignalCellular2Bar, RuxIconSignalCellular3Bar, RuxIconSignalCellular4Bar, RuxIconSignalCellularAlt, RuxIconSignalCellularConnectedNoInternet0Bar, RuxIconSignalCellularConnectedNoInternet1Bar, RuxIconSignalCellularConnectedNoInternet2Bar, RuxIconSignalCellularConnectedNoInternet3Bar, RuxIconSignalCellularConnectedNoInternet4Bar, RuxIconSignalCellularNoSim, RuxIconSignalCellularNull, RuxIconSignalCellularOff, RuxIconSignalWifi0Bar, RuxIconSignalWifi1Bar, RuxIconSignalWifi1BarLock, RuxIconSignalWifi2Bar, RuxIconSignalWifi2BarLock, RuxIconSignalWifi3Bar, RuxIconSignalWifi3BarLock, RuxIconSignalWifi4Bar, RuxIconSignalWifi4BarLock, RuxIconSignalWifiOff, RuxIconSimCard, RuxIconSkipNext, RuxIconSkipPrevious, RuxIconSlideshow, RuxIconSlowMotionVideo, RuxIconSmartphone, RuxIconSmokeFree, RuxIconSmokingRooms, RuxIconSms, RuxIconSmsFailed, RuxIconSnooze, RuxIconSolar, RuxIconSort, RuxIconSortByAlpha, RuxIconSpa, RuxIconSpaceBar, RuxIconSpeaker, RuxIconSpeakerGroup, RuxIconSpeakerNotes, RuxIconSpeakerNotesOff, RuxIconSpeakerPhone, RuxIconSpellcheck, RuxIconStar, RuxIconStarBorder, RuxIconStarHalf, RuxIconStarRate, RuxIconStars, RuxIconStayCurrentLandscape, RuxIconStayCurrentPortrait, RuxIconStayPrimaryLandscape, RuxIconStayPrimaryPortrait, RuxIconStop, RuxIconStopScreenShare, RuxIconStorage, RuxIconStore, RuxIconStoreMallDirectory, RuxIconStraighten, RuxIconStreetview, RuxIconStrikethroughS, RuxIconStyle, RuxIconSubdirectoryArrowLeft, RuxIconSubdirectoryArrowRight, RuxIconSubject, RuxIconSubscriptions, RuxIconSubtitles, RuxIconSubway, RuxIconSupervisedUserCircle, RuxIconSupervisorAccount, RuxIconSurroundSound, RuxIconSwapCalls, RuxIconSwapHoriz, RuxIconSwapHorizontalCircle, RuxIconSwapVert, RuxIconSwapVerticalCircle, RuxIconSwitchCamera, RuxIconSwitchVideo, RuxIconSync, RuxIconSyncDisabled, RuxIconSyncProblem, RuxIconSystemUpdate, RuxIconTab, RuxIconTabUnselected, RuxIconTableChart, RuxIconTablet, RuxIconTabletAndroid, RuxIconTabletMac, RuxIconTagFaces, RuxIconTapAndPlay, RuxIconTerrain, RuxIconTextFields, RuxIconTextFormat, RuxIconTextRotateUp, RuxIconTextRotateVertical, RuxIconTextRotationNone, RuxIconTextsms, RuxIconTexture, RuxIconTheaters, RuxIconThermal, RuxIconThumbDown, RuxIconThumbDownAlt, RuxIconThumbUp, RuxIconThumbUpAlt, RuxIconThumbsUpDown, RuxIconTimeToLeave, RuxIconTimelapse, RuxIconTimeline, RuxIconTimer, RuxIconTimer10, RuxIconTimer3, RuxIconTimerOff, RuxIconTitle, RuxIconToc, RuxIconToday, RuxIconToggleOff, RuxIconToggleOn, RuxIconToll, RuxIconTonality, RuxIconTouchApp, RuxIconToys, RuxIconTrackChanges, RuxIconTraffic, RuxIconTrain, RuxIconTram, RuxIconTransferWithinAStation, RuxIconTransform, RuxIconTransitEnterexit, RuxIconTranslate, RuxIconTrendingDown, RuxIconTrendingFlat, RuxIconTrendingUp, RuxIconTripOrigin, RuxIconTune, RuxIconTurnedIn, RuxIconTurnedInNot, RuxIconTv, RuxIconTvOff, RuxIconUnarchive, RuxIconUndo, RuxIconUnfoldLess, RuxIconUnfoldMore, RuxIconUnsubscribe, RuxIconUpdate, RuxIconUsb, RuxIconVerifiedUser, RuxIconVerticalAlignBottom, RuxIconVerticalAlignCenter, RuxIconVerticalAlignTop, RuxIconVerticalSplit, RuxIconVibration, RuxIconVideoCall, RuxIconVideoLabel, RuxIconVideoLibrary, RuxIconVideocam, RuxIconVideocamOff, RuxIconVideogameAsset, RuxIconViewAgenda, RuxIconViewArray, RuxIconViewCarousel, RuxIconViewColumn, RuxIconViewComfy, RuxIconViewCompact, RuxIconViewDay, RuxIconViewHeadline, RuxIconViewList, RuxIconViewModule, RuxIconViewQuilt, RuxIconViewStream, RuxIconViewWeek, RuxIconVignette, RuxIconVisibility, RuxIconVisibilityOff, RuxIconVoiceChat, RuxIconVoiceOverOff, RuxIconVoicemail, RuxIconVolumeDown, RuxIconVolumeMute, RuxIconVolumeOff, RuxIconVolumeUp, RuxIconVpnKey, RuxIconVpnLock, RuxIconWallpaper, RuxIconWarning, RuxIconWatch, RuxIconWatchLater, RuxIconWaves, RuxIconWbAuto, RuxIconWbCloudy, RuxIconWbIncandescent, RuxIconWbIridescent, RuxIconWbSunny, RuxIconWc, RuxIconWeb, RuxIconWebAsset, RuxIconWeekend, RuxIconWhatshot, RuxIconWhereToVote, RuxIconWidgets, RuxIconWifi, RuxIconWifiLock, RuxIconWifiOff, RuxIconWifiTethering, RuxIconWork, RuxIconWorkOff, RuxIconWorkOutline, RuxIconWrapText, RuxIconYoutubeSearchedFor, RuxIconZoomIn, RuxIconZoomInMap, RuxIconZoomOut, RuxIconZoomOutMap, RuxIndeterminateProgress, RuxInput, RuxLog, RuxMenu, RuxMenuItem, RuxMenuItemDivider, RuxMonitoringIcon, RuxMonitoringProgressIcon, RuxNotification, RuxOption, RuxOptionGroup, RuxPopUp, RuxProgress, RuxPushButton, RuxRadio, RuxRadioGroup, RuxRuler, RuxSegmentedButton, RuxSelect, RuxSlider, RuxStatus, RuxSwitch, RuxTab, RuxTabPanel, RuxTabPanels, RuxTable, RuxTableBody, RuxTableCell, RuxTableHeader, RuxTableHeaderCell, RuxTableHeaderRow, RuxTableRow, RuxTabs, RuxTag, RuxTextarea, RuxTimeRegion, RuxTimeline, RuxToast, RuxToastStack, RuxTooltip, RuxTrack, RuxTree, RuxTreeNode, BooleanValueAccessor, NumericValueAccessor, RadioValueAccessor, SelectValueAccessor, TextValueAccessor]
});
AstroComponentsModule.ɵinj = ɵɵdefineInjector({
  providers: [],
  imports: [[]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AstroComponentsModule, [{
    type: NgModule,
    args: [{
      declarations: DECLARATIONS,
      exports: DECLARATIONS,
      imports: [],
      providers: []
    }]
  }], null, null);
})();
export {
  AngularLibComponent,
  AngularLibService,
  AstroComponentsModule,
  DIRECTIVES,
  RuxAccordion,
  RuxAccordionItem,
  RuxBreadcrumb,
  RuxBreadcrumbItem,
  RuxButton,
  RuxButtonGroup,
  RuxCard,
  RuxCheckbox,
  RuxCheckboxGroup,
  RuxClassificationMarking,
  RuxClock,
  RuxContainer,
  RuxDatetime,
  RuxDialog,
  RuxGlobalStatusBar,
  RuxIcon,
  RuxIcon360,
  RuxIcon3dRotation,
  RuxIcon4k,
  RuxIconAcUnit,
  RuxIconAccessAlarms,
  RuxIconAccessTime,
  RuxIconAccessibility,
  RuxIconAccessibilityNew,
  RuxIconAccessible,
  RuxIconAccessibleForward,
  RuxIconAccountBalance,
  RuxIconAccountBalanceWallet,
  RuxIconAccountBox,
  RuxIconAccountCircle,
  RuxIconAdb,
  RuxIconAdd,
  RuxIconAddAPhoto,
  RuxIconAddAlarm,
  RuxIconAddAlert,
  RuxIconAddBox,
  RuxIconAddCircle,
  RuxIconAddCircleOutline,
  RuxIconAddComment,
  RuxIconAddLocation,
  RuxIconAddPhotoAlternate,
  RuxIconAddShoppingCart,
  RuxIconAddToHomeScreen,
  RuxIconAddToPhotos,
  RuxIconAddToQueue,
  RuxIconAdjust,
  RuxIconAirlineSeatFlat,
  RuxIconAirlineSeatFlatAngled,
  RuxIconAirlineSeatIndividualSuite,
  RuxIconAirlineSeatLegroomExtra,
  RuxIconAirlineSeatLegroomNormal,
  RuxIconAirlineSeatLegroomReduced,
  RuxIconAirlineSeatReclineExtra,
  RuxIconAirlineSeatReclineNormal,
  RuxIconAirplanemodeActive,
  RuxIconAirplanemodeInactive,
  RuxIconAirplay,
  RuxIconAirportShuttle,
  RuxIconAlarm,
  RuxIconAlarmAdd,
  RuxIconAlarmOff,
  RuxIconAlarmOn,
  RuxIconAlbum,
  RuxIconAllInbox,
  RuxIconAllInclusive,
  RuxIconAllOut,
  RuxIconAlternateEmail,
  RuxIconAltitude,
  RuxIconAndroid,
  RuxIconAnnouncement,
  RuxIconAntenna,
  RuxIconAntennaOff,
  RuxIconAntennaReceive,
  RuxIconAntennaTransmit,
  RuxIconApps,
  RuxIconArchive,
  RuxIconArrowBack,
  RuxIconArrowBackIos,
  RuxIconArrowDownward,
  RuxIconArrowDropDown,
  RuxIconArrowDropDownCircle,
  RuxIconArrowDropUp,
  RuxIconArrowForward,
  RuxIconArrowForwardIos,
  RuxIconArrowLeft,
  RuxIconArrowRight,
  RuxIconArrowRightAlt,
  RuxIconArrowUpward,
  RuxIconArtTrack,
  RuxIconAspectRatio,
  RuxIconAssessment,
  RuxIconAssignment,
  RuxIconAssignmentFind,
  RuxIconAssignmentLate,
  RuxIconAssignmentReturn,
  RuxIconAssignmentReturned,
  RuxIconAssignmentTurnedIn,
  RuxIconAssistant,
  RuxIconAssistantPhoto,
  RuxIconAttachFile,
  RuxIconAttachMoney,
  RuxIconAttachment,
  RuxIconAudiotrack,
  RuxIconAutorenew,
  RuxIconAvTimer,
  RuxIconBackspace,
  RuxIconBackup,
  RuxIconBallot,
  RuxIconBarChart,
  RuxIconBattery20,
  RuxIconBattery30,
  RuxIconBattery50,
  RuxIconBattery60,
  RuxIconBattery80,
  RuxIconBattery90,
  RuxIconBatteryAlert,
  RuxIconBatteryCharging20,
  RuxIconBatteryCharging30,
  RuxIconBatteryCharging50,
  RuxIconBatteryCharging60,
  RuxIconBatteryCharging80,
  RuxIconBatteryCharging90,
  RuxIconBatteryChargingFull,
  RuxIconBatteryFull,
  RuxIconBatteryStd,
  RuxIconBatteryUnknown,
  RuxIconBeachAccess,
  RuxIconBeenhere,
  RuxIconBlock,
  RuxIconBluetooth,
  RuxIconBluetoothAudio,
  RuxIconBluetoothConnected,
  RuxIconBluetoothDisabled,
  RuxIconBluetoothSearching,
  RuxIconBlurCircular,
  RuxIconBlurLinear,
  RuxIconBlurOff,
  RuxIconBlurOn,
  RuxIconBook,
  RuxIconBookmark,
  RuxIconBookmarkBorder,
  RuxIconBookmarks,
  RuxIconBorderAll,
  RuxIconBorderBottom,
  RuxIconBorderClear,
  RuxIconBorderColor,
  RuxIconBorderHorizontal,
  RuxIconBorderInner,
  RuxIconBorderLeft,
  RuxIconBorderOuter,
  RuxIconBorderRight,
  RuxIconBorderStyle,
  RuxIconBorderTop,
  RuxIconBorderVertical,
  RuxIconBrandingWatermark,
  RuxIconBrightness1,
  RuxIconBrightness2,
  RuxIconBrightness3,
  RuxIconBrightness4,
  RuxIconBrightness5,
  RuxIconBrightness6,
  RuxIconBrightness7,
  RuxIconBrightnessAuto,
  RuxIconBrightnessHigh,
  RuxIconBrightnessLow,
  RuxIconBrightnessMedium,
  RuxIconBrokenImage,
  RuxIconBrush,
  RuxIconBubbleChart,
  RuxIconBugReport,
  RuxIconBuild,
  RuxIconBurstMode,
  RuxIconBusiness,
  RuxIconBusinessCenter,
  RuxIconCached,
  RuxIconCake,
  RuxIconCalendarToday,
  RuxIconCalendarViewDay,
  RuxIconCall,
  RuxIconCallEnd,
  RuxIconCallMade,
  RuxIconCallMerge,
  RuxIconCallMissed,
  RuxIconCallMissedOutgoing,
  RuxIconCallReceived,
  RuxIconCallSplit,
  RuxIconCallToAction,
  RuxIconCamera,
  RuxIconCameraAlt,
  RuxIconCameraEnhance,
  RuxIconCameraFront,
  RuxIconCameraRear,
  RuxIconCameraRoll,
  RuxIconCancel,
  RuxIconCancelPresentation,
  RuxIconCardGiftcard,
  RuxIconCardMembership,
  RuxIconCardTravel,
  RuxIconCasino,
  RuxIconCast,
  RuxIconCastConnected,
  RuxIconCastForEducation,
  RuxIconCategory,
  RuxIconCellWifi,
  RuxIconCenterFocusStrong,
  RuxIconCenterFocusWeak,
  RuxIconChangeHistory,
  RuxIconChat,
  RuxIconChatBubble,
  RuxIconChatBubbleOutline,
  RuxIconCheck,
  RuxIconCheckBox,
  RuxIconCheckBoxOutlineBlank,
  RuxIconCheckCircle,
  RuxIconCheckCircleOutline,
  RuxIconChevronLeft,
  RuxIconChevronRight,
  RuxIconChildCare,
  RuxIconChildFriendly,
  RuxIconChromeReaderMode,
  RuxIconClass,
  RuxIconClear,
  RuxIconClearAll,
  RuxIconClose,
  RuxIconClosedCaption,
  RuxIconCloud,
  RuxIconCloudCircle,
  RuxIconCloudDone,
  RuxIconCloudDownload,
  RuxIconCloudOff,
  RuxIconCloudQueue,
  RuxIconCloudUpload,
  RuxIconCode,
  RuxIconCollections,
  RuxIconCollectionsBookmark,
  RuxIconColorLens,
  RuxIconColorize,
  RuxIconComment,
  RuxIconCommute,
  RuxIconCompare,
  RuxIconCompareArrows,
  RuxIconCompassCalibration,
  RuxIconComputer,
  RuxIconConfirmationNumber,
  RuxIconContactMail,
  RuxIconContactPhone,
  RuxIconContactSupport,
  RuxIconContacts,
  RuxIconControlCamera,
  RuxIconControlPoint,
  RuxIconControlPointDuplicate,
  RuxIconCopyright,
  RuxIconCreate,
  RuxIconCreateNewFolder,
  RuxIconCreditCard,
  RuxIconCrop,
  RuxIconCrop169,
  RuxIconCrop32,
  RuxIconCrop54,
  RuxIconCrop75,
  RuxIconCropDin,
  RuxIconCropFree,
  RuxIconCropLandscape,
  RuxIconCropOriginal,
  RuxIconCropPortrait,
  RuxIconCropRotate,
  RuxIconCropSquare,
  RuxIconDashboard,
  RuxIconDataUsage,
  RuxIconDateRange,
  RuxIconDehaze,
  RuxIconDelete,
  RuxIconDeleteForever,
  RuxIconDeleteOutline,
  RuxIconDeleteSweep,
  RuxIconDepartureBoard,
  RuxIconDescription,
  RuxIconDesktopAccessDisabled,
  RuxIconDesktopMac,
  RuxIconDesktopWindows,
  RuxIconDetails,
  RuxIconDeveloperBoard,
  RuxIconDeveloperMode,
  RuxIconDeviceHub,
  RuxIconDeviceUnknown,
  RuxIconDevices,
  RuxIconDevicesOther,
  RuxIconDialerSip,
  RuxIconDialpad,
  RuxIconDirections,
  RuxIconDirectionsBike,
  RuxIconDirectionsBoat,
  RuxIconDirectionsBus,
  RuxIconDirectionsCar,
  RuxIconDirectionsRailway,
  RuxIconDirectionsRun,
  RuxIconDirectionsSubway,
  RuxIconDirectionsTransit,
  RuxIconDirectionsWalk,
  RuxIconDiscFull,
  RuxIconDns,
  RuxIconDock,
  RuxIconDomain,
  RuxIconDomainDisabled,
  RuxIconDone,
  RuxIconDoneAll,
  RuxIconDoneOutline,
  RuxIconDonutLarge,
  RuxIconDonutSmall,
  RuxIconDrafts,
  RuxIconDragHandle,
  RuxIconDragIndicator,
  RuxIconDriveEta,
  RuxIconDuo,
  RuxIconDvr,
  RuxIconEdit,
  RuxIconEditAttributes,
  RuxIconEditLocation,
  RuxIconEject,
  RuxIconEmail,
  RuxIconEnhancedEncryption,
  RuxIconEqualizer,
  RuxIconEquipment,
  RuxIconError,
  RuxIconErrorOutline,
  RuxIconEuroSymbol,
  RuxIconEvStation,
  RuxIconEvent,
  RuxIconEventAvailable,
  RuxIconEventBusy,
  RuxIconEventNote,
  RuxIconExitToApp,
  RuxIconExpandLess,
  RuxIconExpandMore,
  RuxIconExplicit,
  RuxIconExplore,
  RuxIconExploreOff,
  RuxIconExposure,
  RuxIconExposureNeg1,
  RuxIconExposureNeg2,
  RuxIconExposurePlus1,
  RuxIconExposurePlus2,
  RuxIconExposureZero,
  RuxIconExtension,
  RuxIconFace,
  RuxIconFastForward,
  RuxIconFastRewind,
  RuxIconFastfood,
  RuxIconFavorite,
  RuxIconFavoriteBorder,
  RuxIconFeaturedPlayList,
  RuxIconFeaturedVideo,
  RuxIconFeedback,
  RuxIconFiberDvr,
  RuxIconFiberManualRecord,
  RuxIconFiberNew,
  RuxIconFiberPin,
  RuxIconFiberSmartRecord,
  RuxIconFileCopy,
  RuxIconFilter,
  RuxIconFilter1,
  RuxIconFilter22 as RuxIconFilter2,
  RuxIconFilter3,
  RuxIconFilter4,
  RuxIconFilter5,
  RuxIconFilter6,
  RuxIconFilter7,
  RuxIconFilter8,
  RuxIconFilter9,
  RuxIconFilter9Plus,
  RuxIconFilterBAndW,
  RuxIconFilterCenterFocus,
  RuxIconFilterDrama,
  RuxIconFilterFrames,
  RuxIconFilterHdr,
  RuxIconFilterList,
  RuxIconFilterNone,
  RuxIconFilterTiltShift,
  RuxIconFilterVintage,
  RuxIconFindInPage,
  RuxIconFindReplace,
  RuxIconFingerprint,
  RuxIconFirstPage,
  RuxIconFitnessCenter,
  RuxIconFlag,
  RuxIconFlare,
  RuxIconFlashAuto,
  RuxIconFlashOff,
  RuxIconFlashOn,
  RuxIconFlight,
  RuxIconFlightLand,
  RuxIconFlightTakeoff,
  RuxIconFlip,
  RuxIconFlipToBack,
  RuxIconFlipToFront,
  RuxIconFolder,
  RuxIconFolderOpen,
  RuxIconFolderShared,
  RuxIconFolderSpecial,
  RuxIconFontDownload,
  RuxIconFormatAlignCenter,
  RuxIconFormatAlignJustify,
  RuxIconFormatAlignLeft,
  RuxIconFormatAlignRight,
  RuxIconFormatBold,
  RuxIconFormatClear,
  RuxIconFormatColorFill,
  RuxIconFormatColorReset,
  RuxIconFormatColorText,
  RuxIconFormatIndentDecrease,
  RuxIconFormatIndentIncrease,
  RuxIconFormatItalic,
  RuxIconFormatLineSpacing,
  RuxIconFormatListBulleted,
  RuxIconFormatListNumbered,
  RuxIconFormatListNumberedRtl,
  RuxIconFormatPaint,
  RuxIconFormatQuote,
  RuxIconFormatShapes,
  RuxIconFormatSize,
  RuxIconFormatStrikethrough,
  RuxIconFormatTextdirectionLToR,
  RuxIconFormatTextdirectionRToL,
  RuxIconFormatUnderlined,
  RuxIconForum,
  RuxIconForward,
  RuxIconForward10,
  RuxIconForward30,
  RuxIconForward5,
  RuxIconFreeBreakfast,
  RuxIconFullscreen,
  RuxIconFullscreenExit,
  RuxIconFunctions,
  RuxIconGTranslate,
  RuxIconGamepad,
  RuxIconGames,
  RuxIconGavel,
  RuxIconGesture,
  RuxIconGetApp,
  RuxIconGif,
  RuxIconGolfCourse,
  RuxIconGpsFixed,
  RuxIconGpsNotFixed,
  RuxIconGpsOff,
  RuxIconGrade,
  RuxIconGradient,
  RuxIconGrain,
  RuxIconGraphicEq,
  RuxIconGridOff,
  RuxIconGridOn,
  RuxIconGroup,
  RuxIconGroupAdd,
  RuxIconGroupWork,
  RuxIconHardware,
  RuxIconHd,
  RuxIconHdrOff,
  RuxIconHdrOn,
  RuxIconHdrStrong,
  RuxIconHdrWeak,
  RuxIconHeadset,
  RuxIconHeadsetMic,
  RuxIconHealing,
  RuxIconHearing,
  RuxIconHelp,
  RuxIconHelpOutline,
  RuxIconHighQuality,
  RuxIconHighlight,
  RuxIconHighlightOff,
  RuxIconHistory,
  RuxIconHome,
  RuxIconHorizontalSplit,
  RuxIconHotTub,
  RuxIconHotel,
  RuxIconHourglassEmpty,
  RuxIconHourglassFull,
  RuxIconHowToReg,
  RuxIconHowToVote,
  RuxIconHttp,
  RuxIconHttps,
  RuxIconImage,
  RuxIconImageAspectRatio,
  RuxIconImageSearch,
  RuxIconImportContacts,
  RuxIconImportExport,
  RuxIconImportantDevices,
  RuxIconInbox,
  RuxIconIndeterminateCheckBox,
  RuxIconInfo,
  RuxIconInput,
  RuxIconInsertChart,
  RuxIconInsertChartOutlined,
  RuxIconInsertComment,
  RuxIconInsertDriveFile,
  RuxIconInsertEmoticon,
  RuxIconInsertInvitation,
  RuxIconInsertLink,
  RuxIconInsertPhoto,
  RuxIconInvertColors,
  RuxIconInvertColorsOff,
  RuxIconIso,
  RuxIconKeyboard,
  RuxIconKeyboardArrowDown,
  RuxIconKeyboardArrowLeft,
  RuxIconKeyboardArrowRight,
  RuxIconKeyboardArrowUp,
  RuxIconKeyboardBackspace,
  RuxIconKeyboardCapslock,
  RuxIconKeyboardHide,
  RuxIconKeyboardReturn,
  RuxIconKeyboardTab,
  RuxIconKeyboardVoice,
  RuxIconKitchen,
  RuxIconLabel,
  RuxIconLabelImportant,
  RuxIconLabelOff,
  RuxIconLandscape,
  RuxIconLanguage,
  RuxIconLaptop,
  RuxIconLaptopChromebook,
  RuxIconLaptopMac,
  RuxIconLaptopWindows,
  RuxIconLastPage,
  RuxIconLaunch,
  RuxIconLayers,
  RuxIconLayersClear,
  RuxIconLeakAdd,
  RuxIconLeakRemove,
  RuxIconLens,
  RuxIconLibraryAdd,
  RuxIconLibraryBooks,
  RuxIconLibraryMusic,
  RuxIconLineStyle,
  RuxIconLineWeight,
  RuxIconLinearScale,
  RuxIconLink,
  RuxIconLinkOff,
  RuxIconLinkedCamera,
  RuxIconList,
  RuxIconListAlt,
  RuxIconLiveHelp,
  RuxIconLiveTv,
  RuxIconLocalActivity,
  RuxIconLocalAirport,
  RuxIconLocalAtm,
  RuxIconLocalBar,
  RuxIconLocalCafe,
  RuxIconLocalCarWash,
  RuxIconLocalConvenienceStore,
  RuxIconLocalDining,
  RuxIconLocalDrink,
  RuxIconLocalGasStation,
  RuxIconLocalGroceryStore,
  RuxIconLocalHospital,
  RuxIconLocalHotel,
  RuxIconLocalLaundryService,
  RuxIconLocalLibrary,
  RuxIconLocalMall,
  RuxIconLocalMovies,
  RuxIconLocalOffer,
  RuxIconLocalParking,
  RuxIconLocalPharmacy,
  RuxIconLocalPhone,
  RuxIconLocalPlay,
  RuxIconLocalPostOffice,
  RuxIconLocalPrintshop,
  RuxIconLocalSee,
  RuxIconLocalShipping,
  RuxIconLocalTaxi,
  RuxIconLocationCity,
  RuxIconLocationDisabled,
  RuxIconLocationOff,
  RuxIconLocationOn,
  RuxIconLocationSearching,
  RuxIconLock,
  RuxIconLockOpen,
  RuxIconLooks,
  RuxIconLooks1,
  RuxIconLooks22 as RuxIconLooks2,
  RuxIconLooks3,
  RuxIconLooks4,
  RuxIconLooks5,
  RuxIconLooks6,
  RuxIconLoop,
  RuxIconLoupe,
  RuxIconLowPriority,
  RuxIconLoyalty,
  RuxIconMail,
  RuxIconMailOutline,
  RuxIconMap,
  RuxIconMarkunread,
  RuxIconMarkunreadMailbox,
  RuxIconMaximize,
  RuxIconMeetingRoom,
  RuxIconMemory,
  RuxIconMenu,
  RuxIconMergeType,
  RuxIconMessage,
  RuxIconMic,
  RuxIconMicNone,
  RuxIconMicOff,
  RuxIconMinimize,
  RuxIconMissedVideoCall,
  RuxIconMission,
  RuxIconMms,
  RuxIconMobileFriendly,
  RuxIconMobileOff,
  RuxIconMobileScreenShare,
  RuxIconModeComment,
  RuxIconMonetizationOn,
  RuxIconMoney,
  RuxIconMoneyOff,
  RuxIconMonochromePhotos,
  RuxIconMood,
  RuxIconMoodBad,
  RuxIconMore,
  RuxIconMoreHoriz,
  RuxIconMoreVert,
  RuxIconMotorcycle,
  RuxIconMouse,
  RuxIconMoveToInbox,
  RuxIconMovie,
  RuxIconMovieCreation,
  RuxIconMovieFilter,
  RuxIconMultilineChart,
  RuxIconMusicNote,
  RuxIconMusicOff,
  RuxIconMusicVideo,
  RuxIconMyLocation,
  RuxIconNature,
  RuxIconNaturePeople,
  RuxIconNavigateBefore,
  RuxIconNavigateNext,
  RuxIconNavigation,
  RuxIconNearMe,
  RuxIconNetcom,
  RuxIconNetworkCell,
  RuxIconNetworkCheck,
  RuxIconNetworkLocked,
  RuxIconNetworkWifi,
  RuxIconNewReleases,
  RuxIconNextWeek,
  RuxIconNfc,
  RuxIconNoEncryption,
  RuxIconNoMeetingRoom,
  RuxIconNoSim,
  RuxIconNotInterested,
  RuxIconNotListedLocation,
  RuxIconNote,
  RuxIconNoteAdd,
  RuxIconNotes,
  RuxIconNotificationImportant,
  RuxIconNotifications,
  RuxIconNotificationsActive,
  RuxIconNotificationsNone,
  RuxIconNotificationsOff,
  RuxIconNotificationsPaused,
  RuxIconOfflineBolt,
  RuxIconOfflinePin,
  RuxIconOndemandVideo,
  RuxIconOpacity,
  RuxIconOpenInBrowser,
  RuxIconOpenInNew,
  RuxIconOpenWith,
  RuxIconOutlinedFlag,
  RuxIconPages,
  RuxIconPageview,
  RuxIconPalette,
  RuxIconPanTool,
  RuxIconPanorama,
  RuxIconPanoramaFishEye,
  RuxIconPanoramaHorizontal,
  RuxIconPanoramaVertical,
  RuxIconPanoramaWideAngle,
  RuxIconPartyMode,
  RuxIconPause,
  RuxIconPauseCircleFilled,
  RuxIconPauseCircleOutline,
  RuxIconPausePresentation,
  RuxIconPayload,
  RuxIconPayment,
  RuxIconPeopleOutline,
  RuxIconPermCameraMic,
  RuxIconPermContactCalendar,
  RuxIconPermDataSetting,
  RuxIconPermDeviceInformation,
  RuxIconPermIdentity,
  RuxIconPermMedia,
  RuxIconPermPhoneMsg,
  RuxIconPermScanWifi,
  RuxIconPerson,
  RuxIconPersonAdd,
  RuxIconPersonAddDisabled,
  RuxIconPersonOutline,
  RuxIconPersonPin,
  RuxIconPersonPinCircle,
  RuxIconPersonalVideo,
  RuxIconPets,
  RuxIconPhone,
  RuxIconPhoneAndroid,
  RuxIconPhoneBluetoothSpeaker,
  RuxIconPhoneCallback,
  RuxIconPhoneForwarded,
  RuxIconPhoneInTalk,
  RuxIconPhoneIphone,
  RuxIconPhoneLocked,
  RuxIconPhoneMissed,
  RuxIconPhonePaused,
  RuxIconPhonelink,
  RuxIconPhonelinkErase,
  RuxIconPhonelinkLock,
  RuxIconPhonelinkOff,
  RuxIconPhonelinkRing,
  RuxIconPhonelinkSetup,
  RuxIconPhoto,
  RuxIconPhotoAlbum,
  RuxIconPhotoCamera,
  RuxIconPhotoFilter,
  RuxIconPhotoLibrary,
  RuxIconPhotoSizeSelectActual,
  RuxIconPhotoSizeSelectLarge,
  RuxIconPhotoSizeSelectSmall,
  RuxIconPictureAsPdf,
  RuxIconPictureInPicture,
  RuxIconPictureInPictureAlt,
  RuxIconPieChart,
  RuxIconPinDrop,
  RuxIconPlace,
  RuxIconPlayArrow,
  RuxIconPlayCircleFilled,
  RuxIconPlayCircleFilledWhite,
  RuxIconPlayCircleOutline,
  RuxIconPlayForWork,
  RuxIconPlaylistAdd,
  RuxIconPlaylistAddCheck,
  RuxIconPlaylistPlay,
  RuxIconPlusOne,
  RuxIconPoll,
  RuxIconPool,
  RuxIconPortableWifiOff,
  RuxIconPortrait,
  RuxIconPower,
  RuxIconPowerInput,
  RuxIconPowerOff,
  RuxIconPowerSettingsNew,
  RuxIconPregnantWoman,
  RuxIconPresentToAll,
  RuxIconPrint,
  RuxIconPrintDisabled,
  RuxIconPriorityHigh,
  RuxIconProcessor,
  RuxIconProcessorAlt,
  RuxIconPropulsionPower,
  RuxIconPublic,
  RuxIconPublish,
  RuxIconQueryBuilder,
  RuxIconQuestionAnswer,
  RuxIconQueue,
  RuxIconQueueMusic,
  RuxIconQueuePlayNext,
  RuxIconRadio,
  RuxIconRadioButtonChecked,
  RuxIconRadioButtonUnchecked,
  RuxIconRateReview,
  RuxIconReceipt,
  RuxIconRecentActors,
  RuxIconRecordVoiceOver,
  RuxIconRedeem,
  RuxIconRedo,
  RuxIconRefresh,
  RuxIconRelease,
  RuxIconRemove,
  RuxIconRemoveCircle,
  RuxIconRemoveCircleOutline,
  RuxIconRemoveFromQueue,
  RuxIconRemoveRedEye,
  RuxIconRemoveShoppingCart,
  RuxIconReorder,
  RuxIconRepeat,
  RuxIconRepeatOne,
  RuxIconReplay,
  RuxIconReplay10,
  RuxIconReplay30,
  RuxIconReplay5,
  RuxIconReply,
  RuxIconReplyAll,
  RuxIconReport,
  RuxIconReportOff,
  RuxIconReportProblem,
  RuxIconRestaurant,
  RuxIconRestaurantMenu,
  RuxIconRestore,
  RuxIconRestoreFromTrash,
  RuxIconRestorePage,
  RuxIconRingVolume,
  RuxIconRoom,
  RuxIconRoomService,
  RuxIconRotate90DegreesCc,
  RuxIconRotateLeft,
  RuxIconRotateRight,
  RuxIconRoundedCorner,
  RuxIconRouter,
  RuxIconRowing,
  RuxIconRssFeed,
  RuxIconRvHookup,
  RuxIconSatellite,
  RuxIconSatelliteOff,
  RuxIconSatelliteReceive,
  RuxIconSatelliteTransmit,
  RuxIconSave,
  RuxIconSaveAlt,
  RuxIconScanner,
  RuxIconScatterPlot,
  RuxIconSchedule,
  RuxIconSchool,
  RuxIconScore,
  RuxIconScreenLockLandscape,
  RuxIconScreenLockPortrait,
  RuxIconScreenLockRotation,
  RuxIconScreenRotation,
  RuxIconScreenShare,
  RuxIconSdCard,
  RuxIconSdStorage,
  RuxIconSearch,
  RuxIconSeat,
  RuxIconSecurity,
  RuxIconSelectAll,
  RuxIconSend,
  RuxIconSentimentDissatisfied,
  RuxIconSentimentSatisfied,
  RuxIconSentimentSatisfiedAlt,
  RuxIconSentimentVeryDissatisfied,
  RuxIconSentimentVerySatisfied,
  RuxIconSetPower,
  RuxIconSettings,
  RuxIconSettingsApplications,
  RuxIconSettingsBackupRestore,
  RuxIconSettingsBluetooth,
  RuxIconSettingsBrightness,
  RuxIconSettingsCell,
  RuxIconSettingsEthernet,
  RuxIconSettingsInputAntenna,
  RuxIconSettingsInputComponent,
  RuxIconSettingsInputComposite,
  RuxIconSettingsInputHdmi,
  RuxIconSettingsInputSvideo,
  RuxIconSettingsOverscan,
  RuxIconSettingsPhone,
  RuxIconSettingsPower,
  RuxIconSettingsRemote,
  RuxIconSettingsSystemDaydream,
  RuxIconSettingsVoice,
  RuxIconShare,
  RuxIconShop,
  RuxIconShopTwo,
  RuxIconShoppingBasket,
  RuxIconShoppingCart,
  RuxIconShortText,
  RuxIconShowChart,
  RuxIconShuffle,
  RuxIconShutterSpeed,
  RuxIconSignalCellular0Bar,
  RuxIconSignalCellular1Bar,
  RuxIconSignalCellular2Bar,
  RuxIconSignalCellular3Bar,
  RuxIconSignalCellular4Bar,
  RuxIconSignalCellularAlt,
  RuxIconSignalCellularConnectedNoInternet0Bar,
  RuxIconSignalCellularConnectedNoInternet1Bar,
  RuxIconSignalCellularConnectedNoInternet2Bar,
  RuxIconSignalCellularConnectedNoInternet3Bar,
  RuxIconSignalCellularConnectedNoInternet4Bar,
  RuxIconSignalCellularNoSim,
  RuxIconSignalCellularNull,
  RuxIconSignalCellularOff,
  RuxIconSignalWifi0Bar,
  RuxIconSignalWifi1Bar,
  RuxIconSignalWifi1BarLock,
  RuxIconSignalWifi2Bar,
  RuxIconSignalWifi2BarLock,
  RuxIconSignalWifi3Bar,
  RuxIconSignalWifi3BarLock,
  RuxIconSignalWifi4Bar,
  RuxIconSignalWifi4BarLock,
  RuxIconSignalWifiOff,
  RuxIconSimCard,
  RuxIconSkipNext,
  RuxIconSkipPrevious,
  RuxIconSlideshow,
  RuxIconSlowMotionVideo,
  RuxIconSmartphone,
  RuxIconSmokeFree,
  RuxIconSmokingRooms,
  RuxIconSms,
  RuxIconSmsFailed,
  RuxIconSnooze,
  RuxIconSolar,
  RuxIconSort,
  RuxIconSortByAlpha,
  RuxIconSpa,
  RuxIconSpaceBar,
  RuxIconSpeaker,
  RuxIconSpeakerGroup,
  RuxIconSpeakerNotes,
  RuxIconSpeakerNotesOff,
  RuxIconSpeakerPhone,
  RuxIconSpellcheck,
  RuxIconStar,
  RuxIconStarBorder,
  RuxIconStarHalf,
  RuxIconStarRate,
  RuxIconStars,
  RuxIconStayCurrentLandscape,
  RuxIconStayCurrentPortrait,
  RuxIconStayPrimaryLandscape,
  RuxIconStayPrimaryPortrait,
  RuxIconStop,
  RuxIconStopScreenShare,
  RuxIconStorage,
  RuxIconStore,
  RuxIconStoreMallDirectory,
  RuxIconStraighten,
  RuxIconStreetview,
  RuxIconStrikethroughS,
  RuxIconStyle,
  RuxIconSubdirectoryArrowLeft,
  RuxIconSubdirectoryArrowRight,
  RuxIconSubject,
  RuxIconSubscriptions,
  RuxIconSubtitles,
  RuxIconSubway,
  RuxIconSupervisedUserCircle,
  RuxIconSupervisorAccount,
  RuxIconSurroundSound,
  RuxIconSwapCalls,
  RuxIconSwapHoriz,
  RuxIconSwapHorizontalCircle,
  RuxIconSwapVert,
  RuxIconSwapVerticalCircle,
  RuxIconSwitchCamera,
  RuxIconSwitchVideo,
  RuxIconSync,
  RuxIconSyncDisabled,
  RuxIconSyncProblem,
  RuxIconSystemUpdate,
  RuxIconTab,
  RuxIconTabUnselected,
  RuxIconTableChart,
  RuxIconTablet,
  RuxIconTabletAndroid,
  RuxIconTabletMac,
  RuxIconTagFaces,
  RuxIconTapAndPlay,
  RuxIconTerrain,
  RuxIconTextFields,
  RuxIconTextFormat,
  RuxIconTextRotateUp,
  RuxIconTextRotateVertical,
  RuxIconTextRotationNone,
  RuxIconTextsms,
  RuxIconTexture,
  RuxIconTheaters,
  RuxIconThermal,
  RuxIconThumbDown,
  RuxIconThumbDownAlt,
  RuxIconThumbUp,
  RuxIconThumbUpAlt,
  RuxIconThumbsUpDown,
  RuxIconTimeToLeave,
  RuxIconTimelapse,
  RuxIconTimeline,
  RuxIconTimer,
  RuxIconTimer10,
  RuxIconTimer3,
  RuxIconTimerOff,
  RuxIconTitle,
  RuxIconToc,
  RuxIconToday,
  RuxIconToggleOff,
  RuxIconToggleOn,
  RuxIconToll,
  RuxIconTonality,
  RuxIconTouchApp,
  RuxIconToys,
  RuxIconTrackChanges,
  RuxIconTraffic,
  RuxIconTrain,
  RuxIconTram,
  RuxIconTransferWithinAStation,
  RuxIconTransform,
  RuxIconTransitEnterexit,
  RuxIconTranslate,
  RuxIconTrendingDown,
  RuxIconTrendingFlat,
  RuxIconTrendingUp,
  RuxIconTripOrigin,
  RuxIconTune,
  RuxIconTurnedIn,
  RuxIconTurnedInNot,
  RuxIconTv,
  RuxIconTvOff,
  RuxIconUnarchive,
  RuxIconUndo,
  RuxIconUnfoldLess,
  RuxIconUnfoldMore,
  RuxIconUnsubscribe,
  RuxIconUpdate,
  RuxIconUsb,
  RuxIconVerifiedUser,
  RuxIconVerticalAlignBottom,
  RuxIconVerticalAlignCenter,
  RuxIconVerticalAlignTop,
  RuxIconVerticalSplit,
  RuxIconVibration,
  RuxIconVideoCall,
  RuxIconVideoLabel,
  RuxIconVideoLibrary,
  RuxIconVideocam,
  RuxIconVideocamOff,
  RuxIconVideogameAsset,
  RuxIconViewAgenda,
  RuxIconViewArray,
  RuxIconViewCarousel,
  RuxIconViewColumn,
  RuxIconViewComfy,
  RuxIconViewCompact,
  RuxIconViewDay,
  RuxIconViewHeadline,
  RuxIconViewList,
  RuxIconViewModule,
  RuxIconViewQuilt,
  RuxIconViewStream,
  RuxIconViewWeek,
  RuxIconVignette,
  RuxIconVisibility,
  RuxIconVisibilityOff,
  RuxIconVoiceChat,
  RuxIconVoiceOverOff,
  RuxIconVoicemail,
  RuxIconVolumeDown,
  RuxIconVolumeMute,
  RuxIconVolumeOff,
  RuxIconVolumeUp,
  RuxIconVpnKey,
  RuxIconVpnLock,
  RuxIconWallpaper,
  RuxIconWarning,
  RuxIconWatch,
  RuxIconWatchLater,
  RuxIconWaves,
  RuxIconWbAuto,
  RuxIconWbCloudy,
  RuxIconWbIncandescent,
  RuxIconWbIridescent,
  RuxIconWbSunny,
  RuxIconWc,
  RuxIconWeb,
  RuxIconWebAsset,
  RuxIconWeekend,
  RuxIconWhatshot,
  RuxIconWhereToVote,
  RuxIconWidgets,
  RuxIconWifi,
  RuxIconWifiLock,
  RuxIconWifiOff,
  RuxIconWifiTethering,
  RuxIconWork,
  RuxIconWorkOff,
  RuxIconWorkOutline,
  RuxIconWrapText,
  RuxIconYoutubeSearchedFor,
  RuxIconZoomIn,
  RuxIconZoomInMap,
  RuxIconZoomOut,
  RuxIconZoomOutMap,
  RuxIndeterminateProgress,
  RuxInput,
  RuxLog,
  RuxMenu,
  RuxMenuItem,
  RuxMenuItemDivider,
  RuxMonitoringIcon,
  RuxMonitoringProgressIcon,
  RuxNotification,
  RuxOption,
  RuxOptionGroup,
  RuxPopUp,
  RuxProgress,
  RuxPushButton,
  RuxRadio,
  RuxRadioGroup,
  RuxRuler,
  RuxSegmentedButton,
  RuxSelect,
  RuxSlider,
  RuxStatus,
  RuxSwitch,
  RuxTab,
  RuxTabPanel,
  RuxTabPanels,
  RuxTable,
  RuxTableBody,
  RuxTableCell,
  RuxTableHeader,
  RuxTableHeaderCell,
  RuxTableHeaderRow,
  RuxTableRow,
  RuxTabs,
  RuxTag,
  RuxTextarea,
  RuxTimeRegion,
  RuxTimeline,
  RuxToast,
  RuxToastStack,
  RuxTooltip,
  RuxTrack,
  RuxTree,
  RuxTreeNode,
  ProxyCmp as ɵa,
  RadioValueAccessor as ɵb,
  SelectValueAccessor as ɵc,
  BooleanValueAccessor as ɵd,
  TextValueAccessor as ɵe,
  NumericValueAccessor as ɵf,
  ValueAccessor as ɵg
};
/*! Bundled license information:

@angular/forms/fesm2022/forms.mjs:
  (**
   * @license Angular v19.2.13
   * (c) 2010-2025 Google LLC. https://angular.io/
   * License: MIT
   *)
*/
//# sourceMappingURL=@astrouxds_angular.js.map
