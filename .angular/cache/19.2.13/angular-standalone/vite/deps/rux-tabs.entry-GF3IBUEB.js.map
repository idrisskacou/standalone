{
  "version": 3,
  "sources": ["../../../../../../node_modules/@astrouxds/astro-web-components/dist/esm/rux-tabs.entry.js"],
  "sourcesContent": ["import { r as registerInstance, c as createEvent, h, H as Host, g as getElement } from './index-416188d1.js';\nconst ruxTabsCss = \":host{box-sizing:border-box;display:flex;justify-content:flex-start;height:100%;width:auto;margin:0;padding:0;-moz-user-select:none;-khtml-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}:host(:not(:focus-within)){contain:content;}:host([hidden]){display:none}\";\nconst RuxTabs = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n    this.ruxSelected = createEvent(this, \"ruxselected\", 7);\n    this._panels = [];\n    this._tabs = [];\n    this.small = undefined;\n  }\n  // This allows us to hear the selected prop change on tab.\n  // Once we hear it, we need to update the related panels visibilty accordingly.\n  handleTabselected(e) {\n    const target = e.target;\n    //* only change the classlist of panels associated with this rux-tabs component\n    const children = Array.from(this.el.children);\n    if (target.selected && children.includes(target)) {\n      //filter through tabs and set the corresponding panel to not be hidden\n      const selectedPanel = this._panels.find(panel => panel.getAttribute('aria-labelledby') === target.getAttribute('id'));\n      this._panels.forEach(panel => panel.classList.add('hidden'));\n      selectedPanel === null || selectedPanel === void 0 ? void 0 : selectedPanel.classList.remove('hidden');\n    }\n    this._checkSelected();\n  }\n  handleListen(e) {\n    const sourcePanel = e.target;\n    const sourcePanelLabelId = sourcePanel.getAttribute('aria-labelledby');\n    /**\n     * The registerPanel event will be emitted from any Tab Panel,\n     * not just the Panels associated with this component.\n     * In scenarios where there could be multiple tab panels,\n     * we want to filter out and only add the panels that belong\n     * to this specific Tab group.\n     */\n    if (sourcePanelLabelId === this.el.id) {\n      this._registerPanels(e);\n    }\n  }\n  handleSmallChange() {\n    //determine whether or not to pass small attr to child tabs\n    if (this.small) {\n      this._tabs.forEach(tab => tab.setAttribute('small', ''));\n    } else {\n      this._tabs.forEach(tab => {\n        if (tab.hasAttribute('small')) {\n          tab.removeAttribute('small');\n        }\n      });\n    }\n  }\n  onKeydown(e) {\n    var _a;\n    // Get all tabs inside of the tab group and then\n    // filter out disabled tabs since we need to skip those\n    const tabs = this._tabs.filter(tab => !tab.disabled);\n    // Only move the tab if the current focus is in the tab group\n    if (e.target && tabs.includes(e.target)) {\n      const index = tabs.findIndex(tab => tab === e.target);\n      let next;\n      // If hitting arrow down or arrow right, move to the next tab\n      // If we're on the last tab, move to the first tab\n      if (['ArrowDown', 'ArrowRight'].includes(e.code)) {\n        next = index === tabs.length - 1 ? tabs[0] : tabs[index + 1];\n      }\n      // If hitting arrow up or arrow left, move to the previous tab\n      // If we're on the first tab, move to the last tab\n      if (['ArrowUp', 'ArrowLeft'].includes(e.code)) {\n        next = index === 0 ? tabs[tabs.length - 1] : tabs[index - 1];\n      }\n      if (next && tabs.includes(next)) {\n        const nextFocus = (_a = next.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('.rux-tab');\n        nextFocus.focus();\n      }\n    }\n  }\n  connectedCallback() {\n    this._addTabs();\n  }\n  componentWillUpdate() {\n    this._checkSelected();\n  }\n  _addTabs() {\n    var _a;\n    this._tabs = Array.from((_a = this.el) === null || _a === void 0 ? void 0 : _a.querySelectorAll('rux-tab'));\n  }\n  _checkSelected() {\n    // If no selected tab exists, we need to set an item to tabindex = 0\n    // so that we can still tab into the tabs list\n    //** note: we also have to account for if the first tab IS selected\n    //** otherwise it is possible to have tab 1 selected but also be tabIndex = -1\n    const firstTab = this._tabs[0].shadowRoot.querySelector('[part=\"container\"]');\n    if (firstTab) {\n      firstTab.tabIndex = !this._tabs.find(tab => tab.selected) || this._tabs[0].hasAttribute('selected') ? 0 : -1;\n    }\n  }\n  _registerPanels(e) {\n    this._panels = [];\n    e.detail.forEach(panel => {\n      this._panels.push(panel);\n    });\n    // run addTabs if this event was heard.\n    this._addTabs();\n    // Default to first tab if none are selected\n    const selectedTab = this._tabs.find(tab => tab.selected) || this._tabs[0];\n    this._setTab(selectedTab);\n  }\n  _onPress(e) {\n    e.key === 'Enter' ? this._onClick(e) : null;\n  }\n  _onClick(e) {\n    const target = e.target;\n    //get the tab in case complex html is nested inside rux-tab\n    const tab = target.closest('rux-tab');\n    //if user does not click on a tab but instead on rux-tabs, tab will be null\n    if (tab !== null) {\n      this.ruxSelected.emit(tab);\n      if (tab.getAttribute('disabled') === null) {\n        this._setTab(tab);\n      }\n    }\n  }\n  _reset() {\n    // hide everything\n    // Only reset the tabs and panels that are part of this instance of rux-tabs\n    this._tabs.forEach(tab => {\n      if (tab.parentElement === this.el) tab.selected = false;\n    });\n    this._panels.forEach(panel => {\n      var _a;\n      if (((_a = panel.parentElement) === null || _a === void 0 ? void 0 : _a.getAttribute('aria-labelledby')) === this.el.id) panel.classList.add('hidden');\n    });\n  }\n  _setTab(selectedTab) {\n    this._reset();\n    // find the panel whose aria-labeldby attribute matches the tabâ€™s id\n    const selectedPanel = this._panels.find(panel => panel.getAttribute('aria-labelledby') === selectedTab.getAttribute('id'));\n    if (selectedTab) selectedTab.selected = true;\n    if (selectedPanel) selectedPanel.classList.remove('hidden');\n  }\n  render() {\n    return h(Host, {\n      onClick: e => this._onClick(e),\n      onKeyPress: e => this._onPress(e),\n      role: \"tablist\"\n    }, h(\"slot\", {\n      onSlotchange: this._addTabs.bind(this)\n    }));\n  }\n  get el() {\n    return getElement(this);\n  }\n  static get watchers() {\n    return {\n      \"small\": [\"handleSmallChange\"]\n    };\n  }\n};\nRuxTabs.style = ruxTabsCss;\nexport { RuxTabs as rux_tabs };"],
  "mappings": "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",
  "names": []
}
